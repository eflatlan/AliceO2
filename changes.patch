diff --git a/CMakeLists.txt b/CMakeLists.txt
index deacb50958..d28f191021 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -41,10 +41,7 @@ o2_build_sanity_checks()
 set(CMAKE_CXX_STANDARD 20)
 set(CMAKE_CXX_STANDARD_REQUIRED TRUE)
 
-find_package(ONNXRuntime::ONNXRuntime CONFIG)
-if (ONNXRuntime::ONNXRuntime_FOUND)
-  add_definitions(-DZDC_FASTSIM_ONNX)
-endif()
+include(dependencies/FindONNXRuntime.cmake)
 
 include(O2CheckCXXFeatures)
 o2_check_cxx_features()
diff --git a/CODEOWNERS b/CODEOWNERS
index 7eb5c0e544..144380ff96 100644
--- a/CODEOWNERS
+++ b/CODEOWNERS
@@ -49,7 +49,7 @@
 #/DataFormats/Legacy
 #/DataFormats/MemoryResources
 /DataFormats/Parameters        @shahor02
-/DataFormats/QualityControl    @knopers8 @Barthelemy @chiarazampolli
+/DataFormats/QualityControl    @knopers8 @Barthelemy @justonedev1 @chiarazampolli
 /DataFormats/Reconstruction    @shahor02
 #/DataFormats/TimeFrame
 /DataFormats/common            @shahor02
@@ -121,8 +121,8 @@
 /Testing
 
 /Utilities  @AliceO2Group/framework-admins
-/Utilities/Mergers @Barthelemy @knopers8
-/Utilities/DataSampling @Barthelemy @knopers8
+/Utilities/Mergers @Barthelemy @knopers8 @justonedev1
+/Utilities/DataSampling @Barthelemy @knopers8 @justonedev1
 #/Utilities/DataCompression
 #/Utilities/DataFlow
 #/Utilities/MCStepLogger
diff --git a/Common/SimConfig/include/SimConfig/SimConfig.h b/Common/SimConfig/include/SimConfig/SimConfig.h
index 36babc2159..b288083098 100644
--- a/Common/SimConfig/include/SimConfig/SimConfig.h
+++ b/Common/SimConfig/include/SimConfig/SimConfig.h
@@ -180,7 +180,7 @@ class SimConfig
   SimConfigData mConfigData; //!
 
   // adjust/overwrite some option settings when collision context is used
-  void adjustFromCollContext();
+  void adjustFromCollContext(std::string const& collcontextfile, std::string const& prefix);
 
   ClassDefNV(SimConfig, 1);
 };
diff --git a/Common/SimConfig/src/SimConfig.cxx b/Common/SimConfig/src/SimConfig.cxx
index 016e6e05a6..ce5d268797 100644
--- a/Common/SimConfig/src/SimConfig.cxx
+++ b/Common/SimConfig/src/SimConfig.cxx
@@ -256,7 +256,17 @@ bool SimConfig::resetFromParsedMap(boost::program_options::variables_map const&
     mConfigData.mFilterNoHitEvents = true;
   }
   mConfigData.mFromCollisionContext = vm["fromCollContext"].as<std::string>();
-  adjustFromCollContext();
+  // we decompose the argument to fetch
+  // (a) collision contextfilename
+  // (b) sim prefix to use from the context
+  auto pos = mConfigData.mFromCollisionContext.find(':');
+  std::string collcontextfile{mConfigData.mFromCollisionContext};
+  std::string simprefix{mConfigData.mOutputPrefix};
+  if (pos != std::string::npos) {
+    collcontextfile = mConfigData.mFromCollisionContext.substr(0, pos);
+    simprefix = mConfigData.mFromCollisionContext.substr(pos + 1);
+  }
+  adjustFromCollContext(collcontextfile, simprefix);
 
   // analyse vertex options
   if (!parseVertexModeString(vm["vertexMode"].as<std::string>(), mConfigData.mVertexMode)) {
@@ -323,28 +333,28 @@ bool SimConfig::parseFieldString(std::string const& fieldstring, int& fieldvalue
   return true;
 }
 
-void SimConfig::adjustFromCollContext()
+void SimConfig::adjustFromCollContext(std::string const& collcontextfile, std::string const& prefix)
 {
   // When we use pregenerated collision contexts, some options
   // need to be auto-adjusted. Do so and inform about this in the logs.
-  if (mConfigData.mFromCollisionContext == "") {
+  if (collcontextfile == "") {
     return;
   }
 
-  auto context = o2::steer::DigitizationContext::loadFromFile(mConfigData.mFromCollisionContext);
+  auto context = o2::steer::DigitizationContext::loadFromFile(collcontextfile);
   if (context) {
     //  find the events belonging to a source that corresponds to a sim prefix
-    LOG(info) << "Looking up simprefixes " << mConfigData.mOutputPrefix;
-    int sourceid = context->findSimPrefix(mConfigData.mOutputPrefix);
+    LOG(info) << "Looking up simprefixes " << prefix;
+    int sourceid = context->findSimPrefix(prefix);
     if (sourceid == -1) {
-      LOG(error) << "Could not find collisions with sim prefix " << mConfigData.mOutputPrefix << " in the collision context. The collision contet specifies the following prefixes:";
-      for (auto& prefix : context->getSimPrefixes()) {
-        LOG(info) << prefix;
+      LOG(error) << "Could not find collisions with sim prefix " << prefix << " in the collision context. The collision context specifies the following prefixes:";
+      for (auto& sp : context->getSimPrefixes()) {
+        LOG(info) << sp;
       }
       LOG(fatal) << "Aborting due to prefix error";
     } else {
       auto collisionmap = context->getCollisionIndicesForSource(sourceid);
-      LOG(info) << "Found " << collisionmap.size() << " events in the collisioncontext for prefix " << mConfigData.mOutputPrefix;
+      LOG(info) << "Found " << collisionmap.size() << " events in the collisioncontext for prefix " << prefix;
 
       // check if collisionmap is dense (otherwise it will get screwed up with order/indexing in ROOT output)
       bool good = true;
@@ -368,7 +378,7 @@ void SimConfig::adjustFromCollContext()
       LOG(info) << "Setting number of events to simulate to " << mConfigData.mNEvents;
     }
   } else {
-    LOG(fatal) << "Could not open collision context file " << mConfigData.mFromCollisionContext;
+    LOG(fatal) << "Could not open collision context file " << collcontextfile;
   }
 }
 
diff --git a/Common/Utils/include/CommonUtils/RootSerializableKeyValueStore.h b/Common/Utils/include/CommonUtils/RootSerializableKeyValueStore.h
index e3261f8b96..c29a3024de 100644
--- a/Common/Utils/include/CommonUtils/RootSerializableKeyValueStore.h
+++ b/Common/Utils/include/CommonUtils/RootSerializableKeyValueStore.h
@@ -144,13 +144,11 @@ class RootSerializableKeyValueStore
   /// print list of keys, values (and optionally type information)
   void print(bool includetypeinfo = false) const;
 
+  /// resets store to the store of another object
   void copyFrom(RootSerializableKeyValueStore const& other)
   {
-    for (auto& p : other.mStore) {
-      if (mStore.find(p.first) == mStore.end()) {
-        mStore.insert(std::pair<std::string, SerializedInfo>(p.first, SerializedInfo(p.second)));
-      }
-    }
+    mStore.clear();
+    mStore = other.mStore;
   }
 
  private:
diff --git a/DataFormats/Detectors/GlobalTracking/include/DataFormatsGlobalTracking/RecoContainer.h b/DataFormats/Detectors/GlobalTracking/include/DataFormatsGlobalTracking/RecoContainer.h
index a766b7d72b..3f063c8b85 100644
--- a/DataFormats/Detectors/GlobalTracking/include/DataFormatsGlobalTracking/RecoContainer.h
+++ b/DataFormats/Detectors/GlobalTracking/include/DataFormatsGlobalTracking/RecoContainer.h
@@ -340,6 +340,7 @@ struct RecoContainer {
   o2::ctp::LumiInfo mCTPLumi;
 
   gsl::span<const unsigned char> clusterShMapTPC; ///< externally set TPC clusters sharing map
+  gsl::span<const unsigned int> occupancyMapTPC;  ///< externally set TPC clusters occupancy map
 
   std::unique_ptr<o2::tpc::internal::getWorkflowTPCInput_ret> inputsTPCclusters; // special struct for TPC clusters access
   std::unique_ptr<o2::trd::RecoInputContainer> inputsTRD;                        // special struct for TRD tracklets, trigger records
@@ -371,7 +372,7 @@ struct RecoContainer {
 
   void addITSClusters(o2::framework::ProcessingContext& pc, bool mc);
   void addMFTClusters(o2::framework::ProcessingContext& pc, bool mc);
-  void addTPCClusters(o2::framework::ProcessingContext& pc, bool mc, bool shmap);
+  void addTPCClusters(o2::framework::ProcessingContext& pc, bool mc, bool shmap, bool occmap);
   void addTPCTriggers(o2::framework::ProcessingContext& pc);
   void addTOFClusters(o2::framework::ProcessingContext& pc, bool mc);
   void addHMPClusters(o2::framework::ProcessingContext& pc, bool mc);
diff --git a/DataFormats/Detectors/GlobalTracking/src/RecoContainer.cxx b/DataFormats/Detectors/GlobalTracking/src/RecoContainer.cxx
index fdfdf1e18f..a79e2736dd 100644
--- a/DataFormats/Detectors/GlobalTracking/src/RecoContainer.cxx
+++ b/DataFormats/Detectors/GlobalTracking/src/RecoContainer.cxx
@@ -119,6 +119,7 @@ void DataRequest::requestTPCTracks(bool mc)
   addInput({"trackTPCClRefs", "TPC", "CLUSREFS", 0, Lifetime::Timeframe});
   if (requestMap.find("clusTPC") != requestMap.end()) {
     addInput({"clusTPCshmap", "TPC", "CLSHAREDMAP", 0, Lifetime::Timeframe});
+    addInput({"clusTPCoccmap", "TPC", "TPCOCCUPANCYMAP", 0, Lifetime::Timeframe});
   }
   if (mc) {
     addInput({"trackTPCMCTR", "TPC", "TRACKSMCLBL", 0, Lifetime::Timeframe});
@@ -255,6 +256,7 @@ void DataRequest::requestTPCClusters(bool mc)
   }
   if (requestMap.find("trackTPC") != requestMap.end()) {
     addInput({"clusTPCshmap", "TPC", "CLSHAREDMAP", 0, Lifetime::Timeframe});
+    addInput({"clusTPCoccmap", "TPC", "TPCOCCUPANCYMAP", 0, Lifetime::Timeframe});
   }
   if (mc) {
     addInput({"clusTPCMC", ConcreteDataTypeMatcher{"TPC", "CLNATIVEMCLBL"}, Lifetime::Timeframe});
@@ -678,7 +680,8 @@ void RecoContainer::collectData(ProcessingContext& pc, const DataRequest& reques
 
   req = reqMap.find("clusTPC");
   if (req != reqMap.end()) {
-    addTPCClusters(pc, req->second, reqMap.find("trackTPC") != reqMap.end());
+    auto tracksON = reqMap.find("trackTPC") != reqMap.end();
+    addTPCClusters(pc, req->second, tracksON, tracksON);
   }
 
   req = reqMap.find("trigTPC");
@@ -1060,12 +1063,15 @@ void RecoContainer::addMFTClusters(ProcessingContext& pc, bool mc)
 }
 
 //__________________________________________________________
-void RecoContainer::addTPCClusters(ProcessingContext& pc, bool mc, bool shmap)
+void RecoContainer::addTPCClusters(ProcessingContext& pc, bool mc, bool shmap, bool occmap)
 {
   inputsTPCclusters = o2::tpc::getWorkflowTPCInput(pc, 0, mc);
   if (shmap) {
     clusterShMapTPC = pc.inputs().get<gsl::span<unsigned char>>("clusTPCshmap");
   }
+  if (occmap) {
+    occupancyMapTPC = pc.inputs().get<gsl::span<unsigned int>>("clusTPCoccmap");
+  }
 }
 
 //__________________________________________________________
diff --git a/DataFormats/Detectors/HMPID/include/DataFormatsHMP/Cluster.h b/DataFormats/Detectors/HMPID/include/DataFormatsHMP/Cluster.h
index 9c777d5afb..81cd7f5bdb 100644
--- a/DataFormats/Detectors/HMPID/include/DataFormatsHMP/Cluster.h
+++ b/DataFormats/Detectors/HMPID/include/DataFormatsHMP/Cluster.h
@@ -16,10 +16,12 @@
 #include "CommonDataFormat/RangeReference.h"
 #include "DataFormatsHMP/Digit.h"
 #include "HMPIDBase/Param.h"
+#include "FairLogger.h"
 
 namespace o2
 {
 namespace hmpid
+
 {
 /// \class Cluster
 /// \brief HMPID cluster implementation
@@ -40,40 +42,54 @@ class Cluster
                         kEmp = -1 }; // status flags
 
  public:
-  Cluster() : mCh(-1), mSi(-1), mSt(kEmp), mBox(-1), mNlocMax(-1), mMaxQpad(-1), mMaxQ(-1), mQRaw(0), mQ(0), mErrQ(-1), mXX(0), mErrX(-1), mYY(0), mErrY(-1), mChi2(-1) {}
+  
+  Cluster()
+    : mCh(-1), mSi(-1), mSt(kEmp), mBox(-1), mNlocMax(-1), mMaxQpad(-1), mMaxQ(-1), mQRaw(0), mQ(0), mErrQ(-1), mXX(0), mErrX(-1), mYY(0), mErrY(-1), mChi2(-1) {}
 
   // Methods
-  // void draw(Option_t *opt=""); //overloaded TObject::Print() to draw cluster in current canvas
-  void print(Option_t* opt = "") const;                                                  // overloaded TObject::Print() to print cluster info
-  static void fitFunc(int& iNpars, double* deriv, double& chi2, double* par, int iflag); // fit function to be used by MINUIT
+
+  // void draw(Option_t *opt=""); //overloaded TObject::Print() to draw cluster
+  // in current canvas
+
+  void print(Option_t* opt = "")
+    const; // overloaded TObject::Print() to print cluster info
+
+  static void fitFunc(int& iNpars, double* deriv, double& chi2, double* par,
+                      int iflag); // fit function to be used by MINUIT
+
   void cleanPointers()
+
   {
     mDigs = nullptr;
   }
-  void coG();                                                                            // calculates center of gravity
-  void corrSin();                                                                        // sinoidal correction
-  void digAdd(const o2::hmpid::Digit* pDig);                                             // add new digit to the cluster
-  const o2::hmpid::Digit* dig(int i) const { return mDigs ? (*mDigs)[i] : nullptr; }     // pointer to i-th digi
+
+  void coG(); // calculates center of gravity
+
+  void corrSin(); // sinoidal correction
+
+  void digAdd(const o2::hmpid::Digit* pDig); // add new digit to the cluster
+
+  const o2::hmpid::Digit* dig(int i) const { return mDigs ? (*mDigs)[i] : nullptr; } // pointer to i-th digi
+
   const std::vector<const o2::hmpid::Digit*>* getDigits() const { return mDigs; }
+
   void setDigits(std::vector<const o2::hmpid::Digit*>* v = nullptr) { mDigs = v; }
-  inline bool isInPc();                                                                  // check if is in the current PC
-  void reset();                                                                          // cleans the cluster
+
+  inline bool isInPc(); // check if is in the current PC
+
+  void reset(); // cleans the cluster
+
   // void setClusterParams(float xL, float yL, int iCh); //Set AliCluster3D part
+
   int solve(std::vector<o2::hmpid::Cluster>* pCluLst, float* pSigmaCut, bool isUnfold); // solve cluster: MINUIT fit or CoG
+
+  // ef :added
+  int solveMC(std::vector<o2::hmpid::Cluster>* pCluLst, float* pSigmaCut, bool isTryUnfold, std::map<int, std::vector<int>>& resolvedIndicesMap);
+  void findClusterSizeMC(int i, float* pSigmaCut, std::vector<int>& indicesResolved);
+
   // Getters
-  int box() { return mBox; }     // Dimension of the cluster
-  int ch() { return mCh; }       // chamber number
-  int size() { return mSi; }     // returns number of pads in formed cluster
-  int status() { return mSt; }   // Status of cluster
-  float qRaw() { return mQRaw; } // raw cluster charge in QDC channels
-  float q() { return mQ; }       // given cluster charge in QDC channels
-  float qe() { return mErrQ; }   // Error in cluster charge in QDC channels
-  float x() { return mXX; }      // cluster x position in LRS
-  float xe() { return mErrX; }   // cluster charge in QDC channels
-  float y() { return mYY; }      // cluster y position in LRS
-  float ye() { return mErrY; }   // cluster charge in QDC channels
-  float chi2() { return mChi2; } // chi2 of the fit
   // Setters
+
   void doCorrSin(bool doCorrSin) { fgDoCorrSin = doCorrSin; } // Set sinoidal correction
   void setX(float x) { mXX = x; }
   void setY(float y) { mYY = y; }
@@ -84,6 +100,7 @@ class Cluster
       mQ = 4095;
     }
   }
+
   void setQRaw(float qRaw)
   {
     mQRaw = qRaw;
@@ -91,46 +108,91 @@ class Cluster
       mQRaw = 4095;
     }
   }
+
+  void setRawSize(int size) { mSiRaw = size; } // ef > added, size of raw cluster
   void setSize(int size) { mSi = size; }
   void setCh(int chamber) { mCh = chamber; }
   void setChi2(float chi2) { mChi2 = chi2; }
   void setStatus(int status) { mSt = status; }
   void findClusterSize(int i, float* pSigmaCut); // Find the clusterSize of deconvoluted clusters
 
-  // public:
  protected:
-  int mCh;                                    // chamber number
-  int mSi;                                    // size of the formed cluster from which this cluster deduced
-  int mSt;                                    // flag to mark the quality of the cluster
-  int mBox;                                   // box contaning this cluster
-  int mNlocMax;                               // number of local maxima in formed cluster
-  int mMaxQpad;                               // abs pad number of a pad with the highest charge
-  double mMaxQ;                               // that max charge value
-  double mQRaw;                               // QDC value of the raw cluster
-  double mQ;                                  // QDC value of the actual cluster
-  double mErrQ;                               // error on Q
-  double mXX;                                 // local x postion, [cm]
-  double mErrX;                               // error on x postion, [cm]
-  double mYY;                                 // local y postion, [cm]
-  double mErrY;                               // error on y postion, [cm]
-  double mChi2;                               // some estimator of the fit quality
+  // int  digsXArr[9], digsYArr[9], digsQArr[9], digsPDGArr[9];//, digsTIDArr[9], digsMIDArr[9];//.push_back(dig
+
+  // std::vector<int>  digsX, digsY, digsQ, digsPDG;//, digsTID, digsMID;//.push_back(dig->getX()); // pos of digit
+
+  // ef : why do we not use uint8 for some of these?
+  int mCh;      // chamber number
+  int mSiRaw;   // ef > added, size of raw cluster
+  int mSi;      // size of the formed cluster from which this cluster deduced
+  int mSt;      // flag to mark the quality of the cluster
+  int mBox;     // box contaning this cluster
+  int mNlocMax; // number of local maxima in formed cluster
+  int mMaxQpad; // abs pad number of a pad with the highest charge
+  double mMaxQ; // that max charge value
+  double mQRaw; // QDC value of the raw cluster
+  double mQ;    // QDC value of the actual cluster
+  double mErrQ; // error on Q
+  double mXX;   // local x postion, [cm]
+  double mErrX; // error on x postion, [cm]
+  double mYY;   // local y postion, [cm]
+  double mErrY; // error on y postion, [cm]
+  double mChi2; // some estimator of the fit quality
+
   std::vector<const o2::hmpid::Digit*>* mDigs = nullptr; //! list of digits forming this cluster
 
+ public:
+  // ef : added const methods
+  int box() const { return mBox; }           // Dimension of the cluster
+  int ch() const { return mCh; }             // chamber number
+  int size() const { return mSi; }           // returns number of pads in formed cluster
+  int sizeRaw() const { return mSiRaw; }     // ef > added : returns number of pads in raw cluster
+  int numLocMax() const { return mNlocMax; } // ef > added : returns number of local maxima
+  int status() const { return mSt; }         // Status of cluster
+  float qRaw() const { return mQRaw; }       // raw cluster charge in QDC channels
+  float q() const { return mQ; }             // given cluster charge in QDC channels
+  float qe() const { return mErrQ; }         // Error in cluster charge in QDC channels
+  float x() const { return mXX; }            // cluster x position in LRS
+  float xe() const { return mErrX; }         // cluster charge in QDC channels
+  float y() const { return mYY; }            // cluster y position in LRS
+  float ye() const { return mErrY; }         // cluster charge in QDC channels
+  float chi2() const { return mChi2; }       // chi2 of the fit
+
+  int box() { return mBox; } // Dimension of the cluster
+  // ef : why do we not use uint8 for some of these?
+  int ch() { return mCh; }       // chamber number
+  int size() { return mSi; }     // returns number of pads in formed cluster
+  int status() { return mSt; }   // Status of cluster
+  float qRaw() { return mQRaw; } // raw cluster charge in QDC channels
+  float q() { return mQ; }       // given cluster charge in QDC channels
+  float qe() { return mErrQ; }   // Error in cluster charge in QDC channels
+  float x() { return mXX; }      // cluster x position in LRS
+  float xe() { return mErrX; }   // cluster charge in QDC channels
+  float y() { return mYY; }      // cluster y position in LRS
+  float ye() { return mErrY; }   // cluster charge in QDC channels
+  float chi2() { return mChi2; } // chi2 of the fit
+
  public:
   static bool fgDoCorrSin; // flag to switch on/off correction for Sinusoidal to cluster reco
 
-  ClassDefNV(Cluster, 3);
+  ClassDefNV(Cluster, 5);
 };
 
 } // namespace hmpid
 
 namespace framework
+
 {
+
 template <typename T>
+
 struct is_messageable;
+
 template <>
+
 struct is_messageable<o2::hmpid::Cluster> : std::true_type {
 };
+
 } // namespace framework
 
 } // namespace o2
diff --git a/DataFormats/Detectors/HMPID/include/DataFormatsHMP/Digit.h b/DataFormats/Detectors/HMPID/include/DataFormatsHMP/Digit.h
index 63b04d454e..90a6b6961e 100644
--- a/DataFormats/Detectors/HMPID/include/DataFormatsHMP/Digit.h
+++ b/DataFormats/Detectors/HMPID/include/DataFormatsHMP/Digit.h
@@ -34,6 +34,16 @@ namespace hmpid
 /// \brief HMPID Digit declaration
 class Digit
 {
+
+  // ef > moved digit member vars to protected
+ protected:
+  uint16_t mQ = 0;
+  uint8_t mCh = 0; // 0xFF indicates invalid digit
+  uint8_t mPh = 0;
+  uint8_t mX = 0;
+  uint8_t mY = 0;
+  // ef : member variables above was public, moved to protected
+
  public:
   // Coordinates Conversion Functions
   static inline uint32_t abs(int ch, int pc, int x, int y) { return ch << 24 | pc << 16 | x << 8 | y; }
@@ -70,9 +80,10 @@ class Digit
 
   friend std::ostream& operator<<(std::ostream& os, const Digit& d);
 
- public:
   Digit() = default;
+
   Digit(int pad, uint16_t charge);
+
   Digit(int chamber, int photo, int x, int y, uint16_t charge);
   Digit(uint16_t charge, int equipment, int column, int dilogic, int channel);
   Digit(uint16_t charge, int module, int x, int y);
@@ -121,13 +132,7 @@ class Digit
   uint8_t getX() const { return mX; }
   uint8_t getY() const { return mY; }
 
- public:
   // Members
-  uint16_t mQ = 0;
-  uint8_t mCh = 0; // 0xFF indicates invalid digit
-  uint8_t mPh = 0;
-  uint8_t mX = 0;
-  uint8_t mY = 0;
 
   // The Pad Unique Id, code a pad inside one HMPID chamber.
   // Bit Map : 0000.0000.cccc.pppp.xxxx.xxxx.yyyy.yyyy
diff --git a/DataFormats/Detectors/HMPID/src/Cluster.cxx b/DataFormats/Detectors/HMPID/src/Cluster.cxx
index e14075c16c..51f23c1f04 100644
--- a/DataFormats/Detectors/HMPID/src/Cluster.cxx
+++ b/DataFormats/Detectors/HMPID/src/Cluster.cxx
@@ -64,7 +64,7 @@ void Cluster::coG()
       minPadY = y;
     } // MinY
 
-    float q = (*mDigs)[iDig]->mQ; // get QDC
+    float q = (*mDigs)[iDig]->getCharge(); // get QDC
     mXX += o2::hmpid::Digit::lorsX(padId) * q;
     mYY += o2::hmpid::Digit::lorsY(padId) * q; // add digit center weighted by QDC
     mQRaw += q;                                // increment total charge
@@ -142,8 +142,8 @@ void Cluster::fitFunc(int& iNpars, double* deriv, double& chi2, double* par, int
       double fracMathi = o2::hmpid::Digit::intMathieson(par[baseOff], par[baseOff1], pClu->dig(i)->getPadID());
       dQpadMath += par[baseOff2] * fracMathi; // par[3*j+2] is charge par[3*j] is x par[3*j+1] is y of current Mathieson
     }
-    if (dQpadMath > 0 && pClu->dig(i)->mQ > 0) {
-      chi2 += std::pow((pClu->dig(i)->mQ - dQpadMath), 2.0) / pClu->dig(i)->mQ; // chi2 function to be minimized
+    if (dQpadMath > 0 && pClu->dig(i)->getCharge() > 0) {
+      chi2 += std::pow((pClu->dig(i)->getCharge() - dQpadMath), 2.0) / pClu->dig(i)->getCharge(); // chi2 function to be minimized
     }
   }
   //---calculate gradients...
@@ -171,7 +171,7 @@ void Cluster::fitFunc(int& iNpars, double* deriv, double& chi2, double* par, int
     // loop on all pads of the cluster
     for (int i = 0; i < nPads; i++) { // loop on all pads of the cluster
       int iPadId = pClu->dig(i)->getPadID();
-      double dPadmQ = pClu->dig(i)->mQ;
+      double dPadmQ = pClu->dig(i)->getCharge();
       double dQpadMath = 0.0; // pad charge collector
       double twoOverMq = 2.0 / dPadmQ;
       for (int j = 0; j < iNshape; j++) { // Mathiesons loop as all of them may contribute to this pad
@@ -264,10 +264,12 @@ int Cluster::solve(std::vector<o2::hmpid::Cluster>* pCluLst, float* pSigmaCut, b
   // Arguments: pCluLst     - cluster list pointer where to add new cluster(s)
   //            isTryUnfold - flag to switch on/off unfolding
   //   Returns: number of local maxima of original cluster
-  const auto param = o2::hmpid::Param::instanceNoGeo();
+
+  const auto param = o2::hmpid::Param::instanceNoGeo(); // ef : why not in initialization?
   if (!mDigs) {
     LOGP(fatal, "digits are missing in the cluster");
   }
+
   const int kMaxLocMax = 6;      // max allowed number of loc max for fitting
   coG();                         // First calculate CoG for the given cluster
   int iCluCnt = pCluLst->size(); // get current number of clusters already stored in the list by previous operations
@@ -279,29 +281,35 @@ int Cluster::solve(std::vector<o2::hmpid::Cluster>* pCluLst, float* pSigmaCut, b
   } else if (rawSize == 1) {
     mSt = kSi1;
   }
+
   if (rawSize > 100 || isTryUnfold == false || rawSize == 1) { // No deconv if: 1 - big cluster (also avoid no zero suppression!)
     // setClusterParams(mXX, mYY, mCh); //                               2 - flag is set to FALSE
     // new ((*pCluLst)[iCluCnt++]) Cluster(*this); //                      3 - size = 1
     pCluLst->push_back(o2::hmpid::Cluster(*this));
     pCluLst->back().cleanPointers();
-    return 1; // add this raw cluster
+    pCluLst->back().setRawSize(rawSize); // ef added this field
+    return 1;                            // add this raw cluster
   }
 
   //  Phase 0. Initialise Fitter
   double arglist[10]{0., 0., 0., 0., 0., 0., 0., 0., 0., 0.};
   float ierflg = 0.;
   TVirtualFitter* fitter = TVirtualFitter::Fitter((TObject*)this, 3 * 6); // initialize Fitter
+
   if (fitter == nullptr) {
     LOG(fatal) << "TVirtualFitter could not be created";
     return 1;
   }
+
   arglist[0] = -1;
   ierflg = fitter->ExecuteCommand("SET PRI", arglist, 1); // no printout
   ierflg = fitter->ExecuteCommand("SET NOW", arglist, 0); // no warning messages
   arglist[0] = 1;
   ierflg = fitter->ExecuteCommand("SET GRA", arglist, 1); // force Fitter to use my gradient
   fitter->SetFCN(Cluster::fitFunc);
+
   // Phase 1. Find number of local maxima. Strategy is to check if the current pad has QDC more then all neigbours. Also find the box contaning the cluster
+
   mNlocMax = 0;
   for (int iDig1 = 0; iDig1 < rawSize; iDig1++) {   // first digits loop
     auto pDig1 = (*mDigs)[iDig1];                   // take next digit
@@ -309,15 +317,23 @@ int Cluster::solve(std::vector<o2::hmpid::Cluster>* pCluLst, float* pSigmaCut, b
     for (int iDig2 = 0; iDig2 < rawSize; iDig2++) { // loop on all digits again
       if (iDig1 == iDig2) {
         continue;
-      }                                                                                                   // the same digit, no need to compare
-      auto pDig2 = (*mDigs)[iDig2];                                                                       // take second digit to compare with the first one
-      int dist = TMath::Sign(int(pDig1->mX - pDig2->mX), 1) + TMath::Sign(int(pDig1->mY - pDig2->mY), 1); // distance between pads
-      if (dist == 1) {                                                                                    // means dig2 is a neighbour of dig1
-        if (pDig2->mQ >= pDig1->mQ) {
+      } // the same digit, no need to compare
+
+      const auto pDig2 =
+        (*mDigs)[iDig2]; // take second digit to compare with the first one
+
+      int dist = TMath::Sign(int(pDig1->getX() - pDig2->getX()), 1) +
+                 TMath::Sign(int(pDig1->getY() - pDig2->getY()),
+                             1); // distance between pads
+
+      if (dist == 1) { // means dig2 is a neighbour of dig1
+        if (pDig2->getCharge() >= pDig1->getCharge()) {
           iCnt++; // count number of pads with Q more then Q of current pad
         }
       }
-    }                                         // second digits loop
+
+    } // second digits loop
+
     if (iCnt == 0 && mNlocMax < kMaxLocMax) { // this pad has Q more then any neighbour so it's local maximum
       float xStart = o2::hmpid::Digit::lorsX(pDig1->getPadID());
       float yStart = o2::hmpid::Digit::lorsY(pDig1->getPadID());
@@ -325,21 +341,27 @@ int Cluster::solve(std::vector<o2::hmpid::Cluster>* pCluLst, float* pSigmaCut, b
       float xMax = xStart + param->sizePadX();
       float yMin = yStart - param->sizePadY();
       float yMax = yStart + param->sizePadY();
-      ierflg = fitter->SetParameter(3 * mNlocMax, Form("x%i", mNlocMax), xStart, 0.1, xMin, xMax);      // X,Y,Q initial values of the loc max pad
-      ierflg = fitter->SetParameter(3 * mNlocMax + 1, Form("y%i", mNlocMax), yStart, 0.1, yMin, yMax);  // X, Y constrained to be near the loc max
-      ierflg = fitter->SetParameter(3 * mNlocMax + 2, Form("q%i", mNlocMax), pDig1->mQ, 0.1, 0, 10000); // Q constrained to be positive
+      ierflg = fitter->SetParameter(3 * mNlocMax, Form("x%i", mNlocMax), xStart, 0.1, xMin, xMax);     // X,Y,Q initial values of the loc max pad
+      ierflg = fitter->SetParameter(3 * mNlocMax + 1, Form("y%i", mNlocMax), yStart, 0.1, yMin, yMax); // X, Y constrained to be near the loc max
+      ierflg = fitter->SetParameter(3 * mNlocMax + 2, Form("q%i", mNlocMax),
+                                    pDig1->getCharge(), 0.1, 0,
+                                    10000); // Q constrained to be positive
       mNlocMax++;
+
     } // if this pad is local maximum
-  }   // first digits loop
+  } // first digits loop
 
   // Phase 2. Fit loc max number of Mathiesons or add this current cluster to the list
+
   // case 1 -> no loc max found
+
   if (mNlocMax == 0) { // case of no local maxima found: pads with same charge...
     mNlocMax = 1;
     mSt = kNoLoc;
     // setClusterParams(mXX, mYY, mCh); //need to fill the AliCluster3D part
     pCluLst->push_back(o2::hmpid::Cluster(*this)); // add new unfolded cluster pCluLst->push_back(o2::hmpid::Cluster(*this));
     pCluLst->back().cleanPointers();
+    pCluLst->back().setRawSize(mDigs->size()); // ef added this field
     return mNlocMax;
   }
 
@@ -349,10 +371,12 @@ int Cluster::solve(std::vector<o2::hmpid::Cluster>* pCluLst, float* pSigmaCut, b
     mSt = kMax;
     pCluLst->push_back(o2::hmpid::Cluster(*this)); //...add this raw cluster
     pCluLst->back().cleanPointers();
-  } else { // or resonable number of local maxima to fit and user requested it
+    pCluLst->back().setRawSize(rawSize); // ef added this field
+  } else {                               // or resonable number of local maxima to fit and user requested it
     // Now ready for minimization step
     arglist[0] = 500; // number of steps and sigma on pads charges
     arglist[1] = 1.;  //
+
     /*
     ierflg = fitter->ExecuteCommand("SIMPLEX", arglist, 2); // start fitting with Simplex
     if (!ierflg) {
@@ -379,23 +403,28 @@ int Cluster::solve(std::vector<o2::hmpid::Cluster>* pCluLst, float* pSigmaCut, b
     if (ierflg) {
       mSt = kAbn; // no convergence of the fit...
     }
+
     double dummy;
     char sName[80]; // vars to get results from Minuit
     double edm;
     double errdef;
     int nvpar;
     int nparx;
+
     for (int i = 0; i < mNlocMax; i++) {                                // store the local maxima parameters
       fitter->GetParameter(3 * i, sName, mXX, mErrX, dummy, dummy);     // X
       fitter->GetParameter(3 * i + 1, sName, mYY, mErrY, dummy, dummy); // Y
       fitter->GetParameter(3 * i + 2, sName, mQ, mErrQ, dummy, dummy);  // Q
       fitter->GetStats(mChi2, edm, errdef, nvpar, nparx);               // get fit infos
-                                                                        // Printf("********************loc. max. = %i, X= %f, Y = %f, Q = %f**************************",i,mXX,mYY,mQ);
+
+      // Printf("********************loc. max. = %i, X= %f, Y = %f, Q = %f**************************",i,mXX,mYY,mQ);
+
       if (mNlocMax > 1) {
         findClusterSize(i, pSigmaCut); // find clustersize for deconvoluted clusters
-                                       // after this call, fSi temporarly is the calculated size. Later is set again
-                                       // to its original value
+        // after this call, fSi temporarly is the calculated size. Later is set again
+        // to its original value
       }
+
       if (mSt != kAbn) {
         if (mNlocMax != 1) {
           mSt = kUnf; // if unfolded
@@ -410,58 +439,326 @@ int Cluster::solve(std::vector<o2::hmpid::Cluster>* pCluLst, float* pSigmaCut, b
           mNlocMax = 0; // if with no loc max (pads with same charge..)
         }
       }
+
       // setClusterParams(mXX, mYY, mCh); //need to fill the AliCluster3D part
       // Printf("********************loc. max. = %i, X= %f, Y = %f, Q = %f**************************",i,mXX,mYY,mQ);
+
       pCluLst->push_back(o2::hmpid::Cluster(*this)); // add new unfolded cluster
       pCluLst->back().cleanPointers();
+      pCluLst->back().setRawSize(rawSize); // ef added this field
       if (mNlocMax > 1) {
         setSize(rawSize); // Original raw size is set again to its proper value
       }
     }
   }
+
   return mNlocMax;
+
+} // Solve()
+
+//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+// ef : added method : stores the indices of the resolved digits per resolved cluster (resolvedIndicesMap)
+//      to propagate MC information
+int Cluster::solveMC(std::vector<o2::hmpid::Cluster>* pCluLst, float* pSigmaCut, bool isTryUnfold, std::map<int, std::vector<int>>& resolvedIndicesMap)
+
+{
+
+  // This methode is invoked when the cluster is formed to solve it. Solve the cluster means to try to unfold the cluster
+  // into the local maxima number of clusters. This methode is invoked by AliHMPIDRconstructor::Dig2Clu() on cluster by cluster basis.
+  // At this point, cluster contains a list of digits, cluster charge and size is precalculated in AddDigit(), position is preset to (-1,-1) in ctor,
+  // status is preset to kFormed in AddDigit(), chamber-sector info is preseted to actual values in AddDigit()
+  // Method first finds number of local maxima and if it's more then one tries to unfold this cluster into local maxima number of clusters
+  // Arguments: pCluLst     - cluster list pointer where to add new cluster(s)
+  //            isTryUnfold - flag to switch on/off unfolding
+  //   Returns: number of local maxima of original cluster
+
+  const auto param = o2::hmpid::Param::instanceNoGeo(); // ef: why do we not do this in initialization?
+  if (!mDigs) {
+    LOGP(fatal, "digits are missing in the cluster");
+  }
+
+  const int kMaxLocMax = 6; // max allowed number of loc max for fitting
+  coG(); // First calculate CoG for the given cluster
+
+  int iCluCnt = pCluLst->size(); // get current number of clusters already stored in the list by previous operations
+  int rawSize = mSi; // get current raw cluster size
+
+  if (rawSize > 100) {
+    mSt = kBig;
+  } else if (isTryUnfold == false) {
+    mSt = kNot;
+  } else if (rawSize == 1) {
+    mSt = kSi1;
+  }
+
+  if (rawSize > 100 || isTryUnfold == false || rawSize == 1) { // No deconv if: 1 - big cluster (also avoid no zero suppression!)
+    // setClusterParams(mXX, mYY, mCh); //                               2 - flag is set to FALSE
+    // new ((*pCluLst)[iCluCnt++]) Cluster(*this); //                      3 - size = 1
+
+    pCluLst->push_back(o2::hmpid::Cluster(*this));
+    pCluLst->back().cleanPointers();
+    pCluLst->back().setRawSize(rawSize); // ef added this field
+    return 1;                            // add this raw cluster
+  }
+
+  //  Phase 0. Initialise Fitter
+  double arglist[10]{0., 0., 0., 0., 0., 0., 0., 0., 0., 0.};
+  float ierflg = 0.;
+  TVirtualFitter* fitter = TVirtualFitter::Fitter((TObject*)this, 3 * 6); // initialize Fitter
+  if (fitter == nullptr) {
+    LOG(fatal) << "TVirtualFitter could not be created";
+    return 1;
+  }
+
+  arglist[0] = -1;
+  ierflg = fitter->ExecuteCommand("SET PRI", arglist, 1); // no printout
+  ierflg = fitter->ExecuteCommand("SET NOW", arglist, 0); // no warning messages
+  arglist[0] = 1;
+  ierflg = fitter->ExecuteCommand("SET GRA", arglist, 1); // force Fitter to use my gradient
+  fitter->SetFCN(Cluster::fitFunc);
+
+  // Phase 1. Find number of local maxima. Strategy is to check if the current pad has QDC more then all neigbours. Also find the box contaning the cluster
+
+  mNlocMax = 0;
+  for (int iDig1 = 0; iDig1 < rawSize; iDig1++) {   // first digits loop
+    const auto pDig1 = (*mDigs)[iDig1];             // take next digit
+    int iCnt = 0;                                   // counts how many neighbouring pads has QDC more then current one
+    for (int iDig2 = 0; iDig2 < rawSize; iDig2++) { // loop on all digits again
+      if (iDig1 == iDig2) {
+        continue;
+      } // the same digit, no need to compare
+
+      const auto pDig2 =
+        (*mDigs)[iDig2]; // take second digit to compare with the first one
+
+      int dist = TMath::Sign(int(pDig1->getX() - pDig2->getX()), 1) +
+                 TMath::Sign(int(pDig1->getY() - pDig2->getY()),
+                             1); // distance between pads
+
+      if (dist == 1) { // means dig2 is a neighbour of dig1
+        if (pDig2->getCharge() >= pDig1->getCharge()) {
+          iCnt++; // count number of pads with Q more then Q of current pad
+        }
+      }
+    } // second digits loop
+
+    if (iCnt == 0 && mNlocMax < kMaxLocMax) { // this pad has Q more then any neighbour so it's local maximum
+      float xStart = o2::hmpid::Digit::lorsX(pDig1->getPadID());
+      float yStart = o2::hmpid::Digit::lorsY(pDig1->getPadID());
+      float xMin = xStart - param->sizePadX();
+      float xMax = xStart + param->sizePadX();
+      float yMin = yStart - param->sizePadY();
+      float yMax = yStart + param->sizePadY();
+      ierflg = fitter->SetParameter(3 * mNlocMax, Form("x%i", mNlocMax), xStart, 0.1, xMin, xMax);     // X,Y,Q initial values of the loc max pad
+      ierflg = fitter->SetParameter(3 * mNlocMax + 1, Form("y%i", mNlocMax), yStart, 0.1, yMin, yMax); // X, Y constrained to be near the loc max
+      ierflg = fitter->SetParameter(3 * mNlocMax + 2, Form("q%i", mNlocMax),
+                                    pDig1->getCharge(), 0.1, 0,
+                                    10000); // Q constrained to be positive
+      mNlocMax++;
+    } // if this pad is local maximum
+  }   // first digits loop
+
+  // Phase 2. Fit loc max number of Mathiesons or add this current cluster to the list
+
+  // case 1 -> no loc max found
+  if (mNlocMax == 0) { // case of no local maxima found: pads with same charge...
+    LOGP(info, "mNlocMax {} number of digits for cluster {}", mNlocMax, mDigs->size());
+    mNlocMax = 1;
+    mSt = kNoLoc;
+    // setClusterParams(mXX, mYY, mCh); //need to fill the AliCluster3D part
+    pCluLst->push_back(o2::hmpid::Cluster(*this)); // add new unfolded cluster pCluLst->push_back(o2::hmpid::Cluster(*this));
+    pCluLst->back().cleanPointers();
+    pCluLst->back().setRawSize(mDigs->size()); // ef added this field
+    return mNlocMax;
+  }
+
+  // case 2 -> loc max found. Check # of loc maxima
+  if (mNlocMax >= kMaxLocMax) {
+    LOGP(info, "mNlocMax {} number of digits for cluster {}", mNlocMax, mDigs->size());
+    LOGP(info, "mNlocMax {} >= kMaxLocMax {}", mNlocMax, kMaxLocMax);
+    // setClusterParams(mXX, mYY, mCh); // if # of local maxima exceeds kMaxLocMax...
+
+    mSt = kMax;
+    pCluLst->push_back(o2::hmpid::Cluster(*this)); //...add this raw cluster
+    pCluLst->back().cleanPointers();
+    pCluLst->back().setRawSize(mDigs->size()); // ef added this field
+  } else {                                     // or resonable number of local maxima to fit and user requested it
+    // Now ready for minimization step
+    arglist[0] = 500; // number of steps and sigma on pads charges
+    arglist[1] = 1.;  //
+    /*
+    ierflg = fitter->ExecuteCommand("SIMPLEX", arglist, 2); // start fitting with Simplex
+    if (!ierflg) {
+      fitter->ExecuteCommand("MIGRAD", arglist, 2); // fitting improved by Migrad
+    }
+    if (ierflg) {
+      double strategy = 2.;
+      ierflg = fitter->ExecuteCommand("SET STR", &strategy, 1); // change level of strategy
+      if (!ierflg) {
+        ierflg = fitter->ExecuteCommand("SIMPLEX", arglist, 2); // start fitting with Simplex
+        if (!ierflg) {
+          fitter->ExecuteCommand("MIGRAD", arglist, 2); // fitting improved by Migrad
+        }
+      }
+    }
+    */
+    double strategy = 2.;
+    ierflg = fitter->ExecuteCommand("SET STR", &strategy, 1); // change level of strategy
+    if (!ierflg) {
+      fitter->ExecuteCommand("MIGRAD", arglist, 2); // fitting improved by Migrad
+    }
+
+    if (ierflg) {
+      mSt = kAbn; // no convergence of the fit...
+    }
+
+    double dummy;
+    char sName[80]; // vars to get results from Minuit
+    double edm;
+    double errdef;
+    int nvpar;
+    int nparx;
+
+    for (int i = 0; i < mNlocMax; i++) {                                // store the local maxima parameters
+      fitter->GetParameter(3 * i, sName, mXX, mErrX, dummy, dummy);     // X
+      fitter->GetParameter(3 * i + 1, sName, mYY, mErrY, dummy, dummy); // Y
+      fitter->GetParameter(3 * i + 2, sName, mQ, mErrQ, dummy, dummy);  // Q
+      fitter->GetStats(mChi2, edm, errdef, nvpar, nparx);               // get fit infos
+      // Printf("********************loc. max. = %i, X= %f, Y = %f, Q = %f**************************",i,mXX,mYY,mQ);
+      if (mNlocMax > 1) {
+        std::vector<int> indicesResolved;
+        findClusterSizeMC(i, pSigmaCut, indicesResolved); // find clustersize for deconvoluted clusters
+        // after this call, fSi temporarly is the calculated size. Later is set again
+        // to its original value
+
+        // add "local" indices to map of clusterNumer i
+        resolvedIndicesMap[i] = indicesResolved;
+        LOGP(info, "size resolvedIndicesMap[i] {}", resolvedIndicesMap[i].size());
+        
+        // after this call, fSi temporarly is the calculated size. Later is set again
+        // to its original value
+      }
+
+      if (mSt != kAbn) {
+        if (mNlocMax != 1) {
+          mSt = kUnf; // if unfolded
+        }
+        if (mNlocMax == 1 && mSt != kNoLoc) {
+          mSt = kLo1; // if only 1 loc max
+        }
+        if (!isInPc()) {
+          mSt = kEdg; // if Out of Pc
+        }
+        if (mSt == kNoLoc) {
+          mNlocMax = 0; // if with no loc max (pads with same charge..)
+        }
+      }
+
+      // setClusterParams(mXX, mYY, mCh); //need to fill the AliCluster3D part
+      // Printf("********************loc. max. = %i, X= %f, Y = %f, Q = %f**************************",i,mXX,mYY,mQ);
+      LOGP(info, "cluNumber {} mNlocMax {} number of digits for cluster {} | unresolved, {}", i, mNlocMax, this->size(), mDigs->size());
+      pCluLst->push_back(o2::hmpid::Cluster(*this)); // add new unfolded cluster
+      // pass indices to MC labeling : resolvedIndicesMap[i]
+      // pCluLst->back().setMC();
+      pCluLst->back().cleanPointers();
+      pCluLst->back().setRawSize(rawSize); // ef added this field
+      if (mNlocMax > 1) {
+        setSize(rawSize); // Original raw size is set again to its proper value
+      }
+    }
+  }
+
+  return mNlocMax;
+
 } // Solve()
 
 //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
 // Estimate of the clustersize for a deconvoluted cluster
+// ef > for MC add indices of resolved digits
+void Cluster::findClusterSizeMC(int i, float* pSigmaCut, std::vector<int>& indicesResolved)
+
+{
+  // std::vector<int> indexResolved;
+  // auto indexUnresolved = getUnresolvedIndexes();
+  int size = 0;
+  LOGP(info, " findClusterSizeMC : total digits for unresolved {}", mSi);
+  for (int iDig = 0; iDig < mSi; iDig++) { // digits loop
+    const auto pDig = dig(iDig);           // take digit
+    int iCh = pDig->getCh();
+    double qPad = mQ * o2::hmpid::Digit::intMathieson(x(), y(), pDig->getPadID()); // pad charge  pDig->
+    //  AliDebug(1,Form("Chamber %i X %i Y %i SigmaCut %i pad %i qpadMath %8.2f qPadRaw %8.2f Qtotal %8.2f cluster n.%i",
+    //                 iCh, o2::hmpid::Digit::a2X(pDig->getPadID()), o2::hmpid::Digit::a2Y(pDig->getPadID()),
+    //                 pSigmaCut[iCh],iDig,qPad,pDig->getCharge(),mQRaw,i));
+
+    if (qPad > pSigmaCut[iCh]) {
+      indicesResolved.push_back(iDig); // ef : added to track indexes of resolved clusters
+      LOGP(info, "findClusterSizeMC :: added local iDig {} ", iDig);
+      size++;
+    }
+  }
+
+  LOGP(info, "findClusterSizeMC {}", size);
+  //  AliDebug(1,Form(" Calculated size %i",size));
+
+  if (size > 0) {
+    setSize(size); // in case of size == 0, original raw clustersize used
+  } else if (size == 0) {
+
+    LOGP(info, "size==0: using raw size {}", mSi);
+    // we use raw-size; and we set for all the labels
+    for (int iDig = 0; iDig < mSi; iDig++) {
+      indicesResolved.push_back(iDig); // ef : added to track indexes of resolved clusters
+      LOGP(info, "findClusterSizeMC :: added raw local iDig {} ", iDig);
+    }
+  }
+}
+
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+// Estimate of the clustersize for a deconvoluted cluster
+
 void Cluster::findClusterSize(int i, float* pSigmaCut)
 {
+
   int size = 0;
   for (int iDig = 0; iDig < mSi; iDig++) { // digits loop
-    auto pDig = dig(iDig);                 // take digit
-    int iCh = pDig->mCh;
+    const auto pDig = dig(iDig);           // take digit
+    int iCh = pDig->getCh();
     double qPad = mQ * o2::hmpid::Digit::intMathieson(x(), y(), pDig->getPadID()); // pad charge  pDig->
     //  AliDebug(1,Form("Chamber %i X %i Y %i SigmaCut %i pad %i qpadMath %8.2f qPadRaw %8.2f Qtotal %8.2f cluster n.%i",
     //                 iCh, o2::hmpid::Digit::a2X(pDig->getPadID()), o2::hmpid::Digit::a2Y(pDig->getPadID()),
-    //                 pSigmaCut[iCh],iDig,qPad,pDig->mQ,mQRaw,i));
+    //                 pSigmaCut[iCh],iDig,qPad,pDig->getCharge(),mQRaw,i));
     if (qPad > pSigmaCut[iCh]) {
       size++;
     }
   }
+
   //  AliDebug(1,Form(" Calculated size %i",size));
   if (size > 0) {
     setSize(size); // in case of size == 0, original raw clustersize used
   }
 }
+
 //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 Bool_t Cluster::isInPc()
 {
   // Check if (X,Y) position is inside the PC limits
   // Arguments:
   //   Returns: True or False
-  const auto param = o2::hmpid::Param::instanceNoGeo();
+  const auto param = o2::hmpid::Param::instanceNoGeo(); // ef: why do we not do this in initialization?
   if (!mDigs) {
     LOGP(fatal, "digits are missing in the cluster");
   }
   int pc = (*mDigs)[0]->getPh(); // (o2::hmpid::Digit*)&mDigs.at(iDig)
-
   if (mXX < param->minPcX(pc) || mXX > param->maxPcX(pc) || mYY < param->minPcY(pc) || mYY > param->maxPcY(pc)) {
     return false;
   }
 
   return true;
 }
+
 //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
 void Cluster::digAdd(const Digit* pDig)
 {
   // Adds a given digit to the list of digits belonging to this cluster, cluster is not owner of digits
@@ -470,16 +767,20 @@ void Cluster::digAdd(const Digit* pDig)
   if (!mDigs) {
     LOGP(fatal, "digits are not set to the cluster");
   }
+
   if (mDigs->size() == 0) { // create list of digits in the first invocation
     mSi = 0;
   }
+
   // fDigs->Add(pDig);
   mDigs->push_back(pDig);
   mSt = kFrm;
   mSi++;
   return;
 }
+
 //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
 void Cluster::reset()
 {
   //
diff --git a/DataFormats/Detectors/ITSMFT/common/include/DataFormatsITSMFT/TimeDeadMap.h b/DataFormats/Detectors/ITSMFT/common/include/DataFormatsITSMFT/TimeDeadMap.h
index aaf7a1a95a..6afcb258e7 100644
--- a/DataFormats/Detectors/ITSMFT/common/include/DataFormatsITSMFT/TimeDeadMap.h
+++ b/DataFormats/Detectors/ITSMFT/common/include/DataFormatsITSMFT/TimeDeadMap.h
@@ -73,8 +73,8 @@ class TimeDeadMap
     }
   }
 
-  void decodeMap(unsigned long orbit, o2::itsmft::NoiseMap& noisemap, bool includeStaticMap = true)
-  { // for time-dependent and (optionally) static part
+  void decodeMap(unsigned long orbit, o2::itsmft::NoiseMap& noisemap, bool includeStaticMap = true, long orbitGapAllowed = 330000)
+  { // for time-dependent and (optionally) static part. Use orbitGapAllowed = -1 to ignore check on orbit difference
 
     if (mMAP_VERSION != "3" && mMAP_VERSION != "4") {
       LOG(error) << "Trying to decode time-dependent deadmap version " << mMAP_VERSION << ". Not implemented, doing nothing.";
@@ -84,14 +84,16 @@ class TimeDeadMap
     if (mEvolvingDeadMap.empty()) {
       LOG(warning) << "Time-dependent dead map is empty. Doing nothing.";
       return;
-    } else if (orbit > mEvolvingDeadMap.rbegin()->first + 11000 * 300 || orbit < mEvolvingDeadMap.begin()->first - 11000 * 300) {
-      // the map should not leave several minutes uncovered.
-      LOG(warning) << "Time-dependent dead map: the requested orbit " << orbit << " seems to be out of the range stored in the map.";
     }
 
     std::vector<uint16_t> closestVec;
     long dT = getMapAtOrbit(orbit, closestVec);
 
+    if (orbitGapAllowed >= 0 && std::abs(dT) > orbitGapAllowed) {
+      LOG(warning) << "Requested orbit " << orbit << ", found " << orbit - dT << ". Orbit gap is too high, skipping time-dependent map.";
+      closestVec.clear();
+    }
+
     // add static part if requested. something may be masked twice
     if (includeStaticMap && mMAP_VERSION != "3") {
       closestVec.insert(closestVec.end(), mStaticDeadMap.begin(), mStaticDeadMap.end());
@@ -125,18 +127,19 @@ class TimeDeadMap
   void getStaticMap(std::vector<uint16_t>& mmap) { mmap = mStaticDeadMap; };
 
   long getMapAtOrbit(unsigned long orbit, std::vector<uint16_t>& mmap)
-  { // fills mmap and returns orbit - lower_bound
+  { // fills mmap and returns requested_orbit - found_orbit. Found orbit is the highest key lower or equal to the requested one
     if (mEvolvingDeadMap.empty()) {
       LOG(warning) << "Requested orbit " << orbit << "from an empty time-dependent map. Doing nothing";
       return (long)orbit;
     }
     auto closest = mEvolvingDeadMap.lower_bound(orbit);
-    if (closest != mEvolvingDeadMap.end()) {
+    if (closest != mEvolvingDeadMap.begin()) {
+      --closest;
       mmap = closest->second;
       return (long)orbit - closest->first;
     } else {
-      mmap = mEvolvingDeadMap.rbegin()->second;
-      return (long)(orbit)-mEvolvingDeadMap.rbegin()->first;
+      mmap = mEvolvingDeadMap.begin()->second;
+      return (long)(orbit)-mEvolvingDeadMap.begin()->first;
     }
   }
 
diff --git a/DataFormats/Reconstruction/include/ReconstructionDataFormats/PrimaryVertexExt.h b/DataFormats/Reconstruction/include/ReconstructionDataFormats/PrimaryVertexExt.h
index df807e5a99..bf47ed03f3 100644
--- a/DataFormats/Reconstruction/include/ReconstructionDataFormats/PrimaryVertexExt.h
+++ b/DataFormats/Reconstruction/include/ReconstructionDataFormats/PrimaryVertexExt.h
@@ -27,18 +27,11 @@ struct PrimaryVertexExt : public PrimaryVertex {
   std::array<uint16_t, o2::dataformats::GlobalTrackID::Source::NSources> nSrc{};   // N contributors for each source type
   std::array<uint16_t, o2::dataformats::GlobalTrackID::Source::NSources> nSrcA{};  // N associated and passing cuts for each source type
   std::array<uint16_t, o2::dataformats::GlobalTrackID::Source::NSources> nSrcAU{}; // N ambgous associated and passing cuts for each source type
-  int VtxID = -1;                                                                // original vtx ID
+  double FT0Time = -1.;                                                            // time of closest FT0 trigger
   float FT0A = -1;                                                               // amplitude of closest FT0 A side
   float FT0C = -1;                                                               // amplitude of closest FT0 C side
-  float FT0Time = -1.;                                                           // time of closest FT0 trigger
-  float rmsT = 0;
-  float rmsZ = 0;
-  float rmsTW = 0;
-  float rmsZW = 0;
-  float rmsT0 = 0;  // w/o ITS
-  float rmsTW0 = 0; // w/o ITS
-  float tMAD = 0;
-  float zMAD = 0;
+  int VtxID = -1;                                                                // original vtx ID
+
   int getNSrc(int i) const { return nSrc[i]; }
   int getNSrcA(int i) const { return nSrcA[i]; }
   int getNSrcAU(int i) const { return nSrcAU[i]; }
@@ -48,7 +41,7 @@ struct PrimaryVertexExt : public PrimaryVertex {
   std::string asString() const;
 #endif
 
-  ClassDefNV(PrimaryVertexExt, 5);
+  ClassDefNV(PrimaryVertexExt, 6);
 };
 
 #ifndef GPUCA_ALIGPUCODE
diff --git a/DataFormats/simulation/include/SimulationDataFormat/MCEventHeader.h b/DataFormats/simulation/include/SimulationDataFormat/MCEventHeader.h
index 6b4c192cd6..efaf46806a 100644
--- a/DataFormats/simulation/include/SimulationDataFormat/MCEventHeader.h
+++ b/DataFormats/simulation/include/SimulationDataFormat/MCEventHeader.h
@@ -142,6 +142,8 @@ class MCEventHeader : public FairMCEventHeader
     return ref;
   };
 
+  void print() const;
+
   /// prints a summary of info keys/types attached to this header
   void printInfo() const
   {
diff --git a/DataFormats/simulation/src/MCEventHeader.cxx b/DataFormats/simulation/src/MCEventHeader.cxx
index 41597f889f..8a46d84805 100644
--- a/DataFormats/simulation/src/MCEventHeader.cxx
+++ b/DataFormats/simulation/src/MCEventHeader.cxx
@@ -15,6 +15,7 @@
 #include "FairRootManager.h"
 #include <TFile.h>
 #include <TTree.h>
+#include <iostream>
 
 namespace o2
 {
@@ -61,6 +62,21 @@ void MCEventHeader::extractFileFromKinematics(std::string_view kinefilename, std
   }
 }
 
+void MCEventHeader::print() const
+{
+  // print some used parts from FairMCEventHeader
+  std::cout << "RunID " << fRunId << "\n";
+  std::cout << "EventID " << fEventId << "\n";
+  std::cout << "Vertex-X " << fX << "\n";
+  std::cout << "Vertex-Y " << fY << "\n";
+  std::cout << "Vertex-Z " << fZ << "\n";
+  std::cout << "Vertex-T " << fT << "\n";
+  std::cout << "Impact-B " << fB << "\n";
+  std::cout << "NPrim " << fNPrim << "\n";
+  // print meta-fields
+  printInfo();
+}
+
 /** alternative implementations below
 
 void MCEventHeader::extractFileFromKinematics(std::string_view kinefilename, std::string_view targetfilename) {
diff --git a/Detectors/Align/Workflow/src/BarrelAlignmentSpec.cxx b/Detectors/Align/Workflow/src/BarrelAlignmentSpec.cxx
index 5c64b23315..38ebed8fac 100644
--- a/Detectors/Align/Workflow/src/BarrelAlignmentSpec.cxx
+++ b/Detectors/Align/Workflow/src/BarrelAlignmentSpec.cxx
@@ -38,6 +38,7 @@
 #include "TPCCalibration/VDriftHelper.h"
 #include "TPCCalibration/CorrectionMapsLoader.h"
 #include "GPUO2Interface.h"
+#include "GPUO2InterfaceUtils.h"
 #include "GPUParam.h"
 #include "Headers/DataHeader.h"
 #include "Framework/ConfigParamRegistry.h"
diff --git a/Detectors/Base/include/DetectorsBase/Detector.h b/Detectors/Base/include/DetectorsBase/Detector.h
index 6acfa4f5cc..1432d93c53 100644
--- a/Detectors/Base/include/DetectorsBase/Detector.h
+++ b/Detectors/Base/include/DetectorsBase/Detector.h
@@ -29,7 +29,6 @@
 #include <typeinfo>
 #include <type_traits>
 #include <string>
-#include <TMessage.h>
 #include "CommonUtils/ShmManager.h"
 #include "CommonUtils/ShmAllocator.h"
 #include <sys/shm.h>
@@ -42,9 +41,7 @@
 
 #include <fairmq/FwdDecls.h>
 
-namespace o2
-{
-namespace base
+namespace o2::base
 {
 
 /// This is the basic class for any AliceO2 detector module, whether it is
@@ -260,17 +257,12 @@ T decodeShmMessage(fair::mq::Parts& dataparts, int index, bool*& busy)
 }
 
 // this goes into the source
-void attachMessageBufferToParts(fair::mq::Parts& parts, fair::mq::Channel& channel,
-                                void* data, size_t size, void (*func_ptr)(void* data, void* hint), void* hint);
+void attachMessageBufferToParts(fair::mq::Parts& parts, fair::mq::Channel& channel, void* data, TClass* cl);
 
 template <typename Container>
 void attachTMessage(Container const& hits, fair::mq::Channel& channel, fair::mq::Parts& parts)
 {
-  TMessage* tmsg = new TMessage();
-  tmsg->WriteObjectAny((void*)&hits, TClass::GetClass(typeid(hits)));
-  attachMessageBufferToParts(
-    parts, channel, tmsg->Buffer(), tmsg->BufferSize(),
-    [](void* data, void* hint) { delete static_cast<TMessage*>(hint); }, tmsg);
+  attachMessageBufferToParts(parts, channel, (void*)&hits, TClass::GetClass(typeid(hits)));
 }
 
 void* decodeTMessageCore(fair::mq::Parts& dataparts, int index);
@@ -746,7 +738,6 @@ class DetImpl : public o2::base::Detector
 
   ClassDefOverride(DetImpl, 0);
 };
-} // namespace base
-} // namespace o2
+} // namespace o2::base
 
 #endif
diff --git a/Detectors/Base/src/Detector.cxx b/Detectors/Base/src/Detector.cxx
index 3168e0e84e..f2b790ffcc 100644
--- a/Detectors/Base/src/Detector.cxx
+++ b/Detectors/Base/src/Detector.cxx
@@ -17,6 +17,7 @@
 #include "DetectorsBase/MaterialManager.h"
 #include "DetectorsCommonDataFormats/DetID.h"
 #include "Field/MagneticField.h"
+#include "Framework/TMessageSerializer.h"
 #include "TString.h" // for TString
 #include "TGeoManager.h"
 
@@ -196,16 +197,19 @@ int Detector::registerSensitiveVolumeAndGetVolID(std::string const& name)
 #include <fairmq/Message.h>
 #include <fairmq/Parts.h>
 #include <fairmq/Channel.h>
-namespace o2
-{
-namespace base
+namespace o2::base
 {
 // this goes into the source
-void attachMessageBufferToParts(fair::mq::Parts& parts, fair::mq::Channel& channel, void* data, size_t size,
-                                void (*free_func)(void* data, void* hint), void* hint)
+void attachMessageBufferToParts(fair::mq::Parts& parts, fair::mq::Channel& channel, void* data, TClass* cl)
 {
-  std::unique_ptr<fair::mq::Message> message(channel.NewMessage(data, size, free_func, hint));
-  parts.AddPart(std::move(message));
+  auto msg = channel.Transport()->CreateMessage(4096, fair::mq::Alignment{64});
+  // This will serialize the data directly into the message buffer, without any further
+  // buffer or copying. Notice how the message will have 8 bytes of header and then
+  // the serialized data as TBufferFile. In principle one could construct a serialized TMessage payload
+  // however I did not manage to get it to work for every case.
+  o2::framework::FairOutputTBuffer buffer(*msg);
+  o2::framework::TMessageSerializer::serialize(buffer, data, cl);
+  parts.AddPart(std::move(msg));
 }
 void attachDetIDHeaderMessage(int id, fair::mq::Channel& channel, fair::mq::Parts& parts)
 {
@@ -246,17 +250,14 @@ void* decodeShmCore(fair::mq::Parts& dataparts, int index, bool*& busy)
 
 void* decodeTMessageCore(fair::mq::Parts& dataparts, int index)
 {
-  class TMessageWrapper : public TMessage
-  {
-   public:
-    TMessageWrapper(void* buf, Int_t len) : TMessage(buf, len) { ResetBit(kIsOwner); }
-    ~TMessageWrapper() override = default;
-  };
   auto rawmessage = std::move(dataparts.At(index));
-  auto message = std::make_unique<TMessageWrapper>(rawmessage->GetData(), rawmessage->GetSize());
-  return message.get()->ReadObjectAny(message.get()->GetClass());
+  o2::framework::FairInputTBuffer buffer((char*)rawmessage->GetData(), rawmessage->GetSize());
+  buffer.InitMap();
+  auto* cl = buffer.ReadClass();
+  buffer.SetBufferOffset(0);
+  buffer.ResetMap();
+  return buffer.ReadObjectAny(cl);
 }
 
-} // namespace base
-} // namespace o2
+} // namespace o2::base
 ClassImp(o2::base::Detector);
diff --git a/Detectors/EMCAL/calib/include/EMCALCalib/CalibDB.h b/Detectors/EMCAL/calib/include/EMCALCalib/CalibDB.h
index a021b74ebc..d4fc0329c0 100644
--- a/Detectors/EMCAL/calib/include/EMCALCalib/CalibDB.h
+++ b/Detectors/EMCAL/calib/include/EMCALCalib/CalibDB.h
@@ -8,6 +8,10 @@
 // In applying this license CERN does not waive the privileges and immunities
 // granted to it by virtue of its status as an Intergovernmental Organization
 // or submit itself to any jurisdiction.
+
+#ifndef ALICEO2_EMCAL_CALIBDB
+#define ALICEO2_EMCAL_CALIBDB
+
 #include <exception>
 #include <map>
 #include <string>
@@ -379,3 +383,5 @@ class CalibDB
 } // namespace emcal
 
 } // namespace o2
+
+#endif
\ No newline at end of file
diff --git a/Detectors/EMCAL/calib/include/EMCALCalib/Pedestal.h b/Detectors/EMCAL/calib/include/EMCALCalib/Pedestal.h
index 8b6e9ffbb0..7a8983409d 100644
--- a/Detectors/EMCAL/calib/include/EMCALCalib/Pedestal.h
+++ b/Detectors/EMCAL/calib/include/EMCALCalib/Pedestal.h
@@ -82,10 +82,10 @@ class Pedestal
   TH2* getHistogramRepresentation2D(bool isLowGain, bool isLEDMON) const;
 
  private:
-  std::array<short, 17664> mPedestalValuesHG;       ///< Container for the pedestal values (high gain)
-  std::array<short, 17664> mPedestalValuesLG;       ///< Container for the pedestal values (low gain)
-  std::array<short, 17664> mPedestalValuesLEDMONHG; ///< Container for the LEDMON pedestal values (high gain)
-  std::array<short, 17664> mPedestalValuesLEDMONLG; ///< Container for the LEDMON pedestal values (low gain)
+  std::array<short, 17664> mPedestalValuesHG;     ///< Container for the pedestal values (high gain)
+  std::array<short, 17664> mPedestalValuesLG;     ///< Container for the pedestal values (low gain)
+  std::array<short, 480> mPedestalValuesLEDMONHG; ///< Container for the LEDMON pedestal values (high gain)
+  std::array<short, 480> mPedestalValuesLEDMONLG; ///< Container for the LEDMON pedestal values (low gain)
 
   ClassDefNV(Pedestal, 1);
 };
diff --git a/Detectors/EMCAL/calib/src/Pedestal.cxx b/Detectors/EMCAL/calib/src/Pedestal.cxx
index 1d628d3d0f..7d67205fc7 100644
--- a/Detectors/EMCAL/calib/src/Pedestal.cxx
+++ b/Detectors/EMCAL/calib/src/Pedestal.cxx
@@ -124,15 +124,22 @@ TH2* Pedestal::getHistogramRepresentation2D(bool isLowGain, bool isLEDMON) const
     }
   }
 
-  const int MAXROWS = 208,
-            MAXCOLS = 96;
+  const int MAXROWS = isLEDMON ? 10 : 208,
+            MAXCOLS = isLEDMON ? 48 : 96;
+
   auto hist = new TH2S(histname.data(), histtitle.data(), MAXCOLS, -0.5, double(MAXCOLS) - 0.5, MAXROWS, -0.5, double(MAXROWS) - 0.5);
   hist->SetDirectory(nullptr);
   try {
     auto geo = Geometry::GetInstance();
-    for (size_t cellID = 0; cellID < data.size(); cellID++) {
-      auto position = geo->GlobalRowColFromIndex(cellID);
-      hist->Fill(std::get<1>(position), std::get<0>(position), data[cellID]);
+    for (size_t ichan = 0; ichan < data.size(); ichan++) {
+      if (isLEDMON) {
+        int col = ichan % 48,
+            row = ichan / 48;
+        hist->Fill(col, row, data[ichan]);
+      } else {
+        auto position = geo->GlobalRowColFromIndex(ichan);
+        hist->Fill(std::get<1>(position), std::get<0>(position), data[ichan]);
+      }
     }
   } catch (o2::emcal::GeometryNotInitializedException& e) {
     LOG(error) << "Geometry needs to be initialized";
diff --git a/Detectors/EMCAL/calib/test/testPedestal.cxx b/Detectors/EMCAL/calib/test/testPedestal.cxx
index c22579c6db..1adcfd8b9e 100644
--- a/Detectors/EMCAL/calib/test/testPedestal.cxx
+++ b/Detectors/EMCAL/calib/test/testPedestal.cxx
@@ -26,14 +26,14 @@ namespace o2
 namespace emcal
 {
 
-using pedestalarray = std::array<short, 17664>;
+using pedestalarray = std::vector<short>;
 
-pedestalarray createRandomPedestals()
+pedestalarray createRandomPedestals(bool isLEDMON)
 {
   std::random_device rd{};
   std::mt19937 gen{rd()};
   std::normal_distribution gaussrand{40., 5.};
-  pedestalarray pedestalcontainer;
+  pedestalarray pedestalcontainer(isLEDMON ? 480 : 17664);
   for (std::size_t ichan{0}; ichan < pedestalcontainer.size(); ++ichan) {
     pedestalcontainer[ichan] = std::round(gaussrand(gen));
   }
@@ -52,15 +52,17 @@ pedestalarray shiftPedestalValue(const pedestalarray& input, short shift = 1)
 
 BOOST_AUTO_TEST_CASE(testPedestal)
 {
-  auto pedestalsHG = createRandomPedestals(),
-       pedestalsLG = createRandomPedestals(),
-       pedestalsLEDMONHG = createRandomPedestals(),
-       pedestalsLEDMONLG = createRandomPedestals();
+  auto pedestalsHG = createRandomPedestals(false),
+       pedestalsLG = createRandomPedestals(false),
+       pedestalsLEDMONHG = createRandomPedestals(true),
+       pedestalsLEDMONLG = createRandomPedestals(true);
 
   o2::emcal::Pedestal pedestalObject;
   for (std::size_t ichan{0}; ichan < pedestalsHG.size(); ++ichan) {
     pedestalObject.addPedestalValue(ichan, pedestalsHG[ichan], false, false);
     pedestalObject.addPedestalValue(ichan, pedestalsLG[ichan], true, false);
+  }
+  for (std::size_t ichan{0}; ichan < pedestalsLEDMONHG.size(); ++ichan) {
     pedestalObject.addPedestalValue(ichan, pedestalsLEDMONHG[ichan], false, true);
     pedestalObject.addPedestalValue(ichan, pedestalsLEDMONLG[ichan], true, true);
   }
@@ -75,6 +77,8 @@ BOOST_AUTO_TEST_CASE(testPedestal)
   for (std::size_t ichan{0}; ichan < pedestalsHG.size(); ++ichan) {
     BOOST_CHECK_EQUAL(pedestalObject.getPedestalValue(ichan, false, false), pedestalsHG[ichan]);
     BOOST_CHECK_EQUAL(pedestalObject.getPedestalValue(ichan, true, false), pedestalsLG[ichan]);
+  }
+  for (std::size_t ichan{0}; ichan < pedestalsLEDMONHG.size(); ++ichan) {
     BOOST_CHECK_EQUAL(pedestalObject.getPedestalValue(ichan, false, true), pedestalsLEDMONHG[ichan]);
     BOOST_CHECK_EQUAL(pedestalObject.getPedestalValue(ichan, true, true), pedestalsLEDMONLG[ichan]);
   }
diff --git a/Detectors/EMCAL/calibration/CMakeLists.txt b/Detectors/EMCAL/calibration/CMakeLists.txt
index ce50192f5a..68c8fd1eb6 100644
--- a/Detectors/EMCAL/calibration/CMakeLists.txt
+++ b/Detectors/EMCAL/calibration/CMakeLists.txt
@@ -16,6 +16,7 @@ o2_add_library(EMCALCalibration
                         src/EMCALCalibExtractor.cxx
                         src/EMCALCalibParams.cxx
                         src/EMCDCSProcessor.cxx
+                        src/EMCALPedestalHelper.cxx
                         src/PedestalCalibDevice.cxx
                         src/PedestalProcessorDevice.cxx
                         src/PedestalProcessorData.cxx
@@ -43,6 +44,7 @@ o2_target_root_dictionary(EMCALCalibration
                                   include/EMCALCalibration/EMCALTimeCalibData.h
                                   include/EMCALCalibration/EMCALCalibParams.h
                                   include/EMCALCalibration/EMCDCSProcessor.h
+                                  include/EMCALCalibration/EMCALPedestalHelper.h
                                   include/EMCALCalibration/PedestalProcessorData.h
                           LINKDEF src/EMCALCalibrationLinkDef.h)
 
diff --git a/Detectors/EMCAL/calibration/include/EMCALCalibration/EMCALCalibExtractor.h b/Detectors/EMCAL/calibration/include/EMCALCalibration/EMCALCalibExtractor.h
index e9b59e8afa..6ba8479534 100644
--- a/Detectors/EMCAL/calibration/include/EMCALCalibration/EMCALCalibExtractor.h
+++ b/Detectors/EMCAL/calibration/include/EMCALCalibration/EMCALCalibExtractor.h
@@ -431,6 +431,9 @@ class EMCALCalibExtractor
       for (const auto& isLG : {false, true}) {
         for (unsigned short iCell = 0; iCell < maxChannels; ++iCell) {
           auto [mean, rms] = obj.getValue(iCell, isLG, isLEDMON); // get mean and rms for pedestals
+          if (rms > EMCALCalibParams::Instance().maxPedestalRMS) {
+            mean = mMaxPedestalVal;
+          }
           pedestalData.addPedestalValue(iCell, mean, isLG, isLEDMON);
         }
       }
@@ -455,6 +458,10 @@ class EMCALCalibExtractor
         continue;
       for (unsigned short iCell = 0; iCell < maxChannels; ++iCell) {
         short mean = static_cast<short>(obj->GetBinContent(iCell + 1));
+        short rms = static_cast<short>(obj->GetBinError(iCell + 1) / obj->GetBinEntries(iCell + 1));
+        if (rms > EMCALCalibParams::Instance().maxPedestalRMS) {
+          mean = mMaxPedestalVal;
+        }
         pedestalData.addPedestalValue(iCell, mean, isLG, isLEDMON);
       }
     }
@@ -481,9 +488,10 @@ class EMCALCalibExtractor
   std::array<float, 20> mBadCellFracSM;                  ///< Fraction of bad+dead channels per SM
   std::array<std::array<float, 36>, 20> mBadCellFracFEC; ///< Fraction of bad+dead channels per FEC
 
-  o2::emcal::Geometry* mGeometry = nullptr; ///< pointer to the emcal geometry class
-  static constexpr int mNcells = 17664;     ///< Number of total cells of EMCal + DCal
-  static constexpr int mLEDMONs = 480;      ///< Number of total LEDMONS of EMCal + DCal
+  o2::emcal::Geometry* mGeometry = nullptr;      ///< pointer to the emcal geometry class
+  static constexpr int mNcells = 17664;          ///< Number of total cells of EMCal + DCal
+  static constexpr int mLEDMONs = 480;           ///< Number of total LEDMONS of EMCal + DCal
+  static constexpr short mMaxPedestalVal = 1023; ///< Maximum value for pedestals
 
   ClassDefNV(EMCALCalibExtractor, 1);
 };
diff --git a/Detectors/EMCAL/calibration/include/EMCALCalibration/EMCALCalibParams.h b/Detectors/EMCAL/calibration/include/EMCALCalibration/EMCALCalibParams.h
index 0e44e886d0..0e9e6a4614 100644
--- a/Detectors/EMCAL/calibration/include/EMCALCalibration/EMCALCalibParams.h
+++ b/Detectors/EMCAL/calibration/include/EMCALCalibration/EMCALCalibParams.h
@@ -86,6 +86,9 @@ struct EMCALCalibParams : public o2::conf::ConfigurableParamHelper<EMCALCalibPar
   bool requireSameRunType = true;                      ///< if loading calib objects from previous run, require it to be the same run type
   int tsDiffMax = 48;                                  ///< if loading calib objects from previous run, limit time between the object being stored and loaded again (in hours)
 
+  // Parameters for pedestal calibration
+  short maxPedestalRMS = 10; ///< Maximum value for RMS for pedestals (has to be tuned)
+
   // old parameters. Keep them for a bit (can be deleted after september 5th) as otherwise ccdb and o2 version might not be in synch
   unsigned int minNEvents = 1e7;              ///< minimum number of events to trigger the calibration
   unsigned int minNEntries = 1e6;             ///< minimum number of entries to trigger the calibration
diff --git a/Detectors/EMCAL/calibration/include/EMCALCalibration/EMCALPedestalHelper.h b/Detectors/EMCAL/calibration/include/EMCALCalibration/EMCALPedestalHelper.h
new file mode 100644
index 0000000000..109fa795fd
--- /dev/null
+++ b/Detectors/EMCAL/calibration/include/EMCALCalibration/EMCALPedestalHelper.h
@@ -0,0 +1,68 @@
+// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
+// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
+// All rights not expressly granted are reserved.
+//
+// This software is distributed under the terms of the GNU General Public
+// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
+//
+// In applying this license CERN does not waive the privileges and immunities
+// granted to it by virtue of its status as an Intergovernmental Organization
+// or submit itself to any jurisdiction.
+
+#ifndef EMCAL_PEDESTAL_HELPER_H_
+#define EMCAL_PEDESTAL_HELPER_H_
+
+#include "CCDB/CcdbApi.h"
+#include "CCDB/BasicCCDBManager.h"
+#include "CCDB/CCDBTimeStampUtils.h"
+#include "EMCALReconstruction/Channel.h"
+#include "EMCALBase/Geometry.h"
+#include "EMCALBase/Mapper.h"
+#include "EMCALCalib/CalibDB.h"
+#include "EMCALCalib/Pedestal.h"
+
+#include <algorithm>
+#include <fstream>
+#include <iostream>
+#include <sstream>
+#include <bitset>
+
+namespace o2::emcal
+{
+
+class EMCALPedestalHelper
+{
+
+ public:
+  EMCALPedestalHelper() = default;
+  ~EMCALPedestalHelper() = default;
+
+  /// \brief Encodes the pedestal object into a string. This function fills fMeanPed which is then converted to a string in createInstructionString
+  /// \param obj pedestal object as stored in production ccdb
+  /// \param runNum current runnumber. If -1, will not be added to string that goes in the ccdb, otherwise runNum is the first entrey in the string
+  std::vector<char> createPedestalInstruction(const Pedestal& obj, const int runNum = -1);
+
+  /// \brief print the vector produced by createInstructionString in a textfile
+  void dumpInstructions(const std::string_view filename, const gsl::span<char>& data);
+
+ private:
+  /// \brief initialize fMeanPed with zeros
+  void setZero();
+
+  /// \brief converts fMeanPed to a vector of char
+  /// \param runNum current runnumber. If -1, will not be added to string that goes in the ccdb, otherwise runNum is the first entrey in the string
+  std::vector<char> createInstructionString(const int runNum = -1);
+
+  static constexpr short kNSM = 20;    ///< number of SuperModules
+  static constexpr short kNRCU = 2;    ///< number of readout crates (and DDLs) per SM
+  static constexpr short kNDTC = 40;   ///< links for full SRU
+  static constexpr short kNBranch = 2; ///< low gain/high gain
+  static constexpr short kNFEC = 10;   ///< 0..9, when including LED Ref
+  static constexpr short kNChip = 5;   ///< really 0,2..4, i.e. skip #1
+  static constexpr short kNChan = 16;
+  short fMeanPed[kNSM][kNRCU][kNBranch][kNFEC][kNChip][kNChan];
+};
+
+} // namespace o2::emcal
+
+#endif
\ No newline at end of file
diff --git a/Detectors/EMCAL/calibration/include/EMCALCalibration/PedestalCalibDevice.h b/Detectors/EMCAL/calibration/include/EMCALCalibration/PedestalCalibDevice.h
index 7cf819aa25..6d4cfa8ff2 100644
--- a/Detectors/EMCAL/calibration/include/EMCALCalibration/PedestalCalibDevice.h
+++ b/Detectors/EMCAL/calibration/include/EMCALCalibration/PedestalCalibDevice.h
@@ -21,6 +21,7 @@
 #include "EMCALBase/Geometry.h"
 #include "EMCALCalibration/PedestalProcessorData.h"
 #include "EMCALCalibration/EMCALCalibExtractor.h"
+#include "EMCALCalibration/EMCALPedestalHelper.h"
 
 namespace o2::emcal
 {
@@ -28,7 +29,7 @@ namespace o2::emcal
 class PedestalCalibDevice : o2::framework::Task
 {
  public:
-  PedestalCalibDevice() = default;
+  PedestalCalibDevice(bool dumpToFile, bool addRunNum) : mDumpToFile(dumpToFile), mAddRunNumber(addRunNum){};
   ~PedestalCalibDevice() final = default;
 
   void init(framework::InitContext& ctx) final;
@@ -45,12 +46,15 @@ class PedestalCalibDevice : o2::framework::Task
 
  private:
   Geometry* mGeometry = nullptr;                  ///< pointer to the emcal geometry class
-  o2::emcal::EMCALCalibExtractor mCalibExtractor; // instance of the calibration extraction class                                                                ///< Calibration postprocessing
-  PedestalProcessorData mPedestalData;            /// pedestal data to accumulate data
-  long int mStartTS = 0;
+  o2::emcal::EMCALCalibExtractor mCalibExtractor; ///< instance of the calibration extraction class                                                                ///< Calibration postprocessing
+  PedestalProcessorData mPedestalData;            ///< pedestal data to accumulate data
+  long int mStartTS = 0;                          ///< timestamp at the start of run used for the object in the ccdb
+  bool mDumpToFile;                               ///< if output of pedestal calib (DCS ccdb) should be written to text file
+  int mRun = 0;                                   ///< current run number
+  bool mAddRunNumber = false;                     ///< if true, runNumber will be added to ccdb string
 };
 
-o2::framework::DataProcessorSpec getPedestalCalibDevice();
+o2::framework::DataProcessorSpec getPedestalCalibDevice(bool dumpToFile, bool addRunNum);
 
 } // end namespace o2::emcal
 
diff --git a/Detectors/EMCAL/calibration/src/EMCALPedestalHelper.cxx b/Detectors/EMCAL/calibration/src/EMCALPedestalHelper.cxx
new file mode 100644
index 0000000000..38a6e386c9
--- /dev/null
+++ b/Detectors/EMCAL/calibration/src/EMCALPedestalHelper.cxx
@@ -0,0 +1,199 @@
+// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
+// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
+// All rights not expressly granted are reserved.
+//
+// This software is distributed under the terms of the GNU General Public
+// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
+//
+// In applying this license CERN does not waive the privileges and immunities
+// granted to it by virtue of its status as an Intergovernmental Organization
+// or submit itself to any jurisdiction.
+
+#include "EMCALCalibration/EMCALPedestalHelper.h"
+using namespace o2::emcal;
+
+std::vector<char> EMCALPedestalHelper::createPedestalInstruction(const Pedestal& obj, const int runNum)
+{
+
+  setZero();
+
+  o2::emcal::Geometry* geo = o2::emcal::Geometry::GetInstanceFromRunNumber(300000);
+  o2::emcal::MappingHandler mapper;
+
+  for (int itower = 0; itower < 17664; itower++) {
+    auto [ddl, row, col] = geo->getOnlineID(itower);
+    auto [sm, mod, iphi, ieta] = geo->GetCellIndex(itower);
+    const auto& mapping = mapper.getMappingForDDL(ddl);
+    int ircu = ddl % 2;
+    auto addressLG = mapping.getHardwareAddress(row, col, o2::emcal::ChannelType_t::LOW_GAIN),
+         addressHG = mapping.getHardwareAddress(row, col, o2::emcal::ChannelType_t::HIGH_GAIN);
+    auto fecLG = o2::emcal::Channel::getFecIndexFromHwAddress(addressLG),
+         fecHG = o2::emcal::Channel::getFecIndexFromHwAddress(addressHG),
+         branchLG = o2::emcal::Channel::getBranchIndexFromHwAddress(addressLG),
+         branchHG = o2::emcal::Channel::getBranchIndexFromHwAddress(addressHG),
+         chipLG = o2::emcal::Channel::getAltroIndexFromHwAddress(addressLG),
+         chipHG = o2::emcal::Channel::getAltroIndexFromHwAddress(addressHG),
+         channelLG = o2::emcal::Channel::getChannelIndexFromHwAddress(addressLG),
+         channelHG = o2::emcal::Channel::getChannelIndexFromHwAddress(addressHG);
+    fMeanPed[sm][ircu][branchHG][fecHG][chipHG][channelHG] = obj.getPedestalValue(itower, false, false);
+    fMeanPed[sm][ircu][branchLG][fecLG][chipLG][channelLG] = obj.getPedestalValue(itower, true, false);
+  }
+
+  for (int iledmon = 0; iledmon < 480; iledmon++) {
+    int sm = iledmon / 24,
+        col = iledmon % 24,
+        ircu = 0, // LEDMONS always on RCU 0
+      iddl = 2 * sm + ircu;
+    const auto& mapping = mapper.getMappingForDDL(iddl);
+    auto addressLG = mapping.getHardwareAddress(0, col, o2::emcal::ChannelType_t::LEDMON),
+         addressHG = mapping.getHardwareAddress(1, col, o2::emcal::ChannelType_t::LEDMON);
+    auto fecLG = o2::emcal::Channel::getFecIndexFromHwAddress(addressLG),
+         fecHG = o2::emcal::Channel::getFecIndexFromHwAddress(addressHG),
+         branchLG = o2::emcal::Channel::getBranchIndexFromHwAddress(addressLG),
+         branchHG = o2::emcal::Channel::getBranchIndexFromHwAddress(addressHG),
+         chipLG = o2::emcal::Channel::getAltroIndexFromHwAddress(addressLG),
+         chipHG = o2::emcal::Channel::getAltroIndexFromHwAddress(addressHG),
+         channelLG = o2::emcal::Channel::getChannelIndexFromHwAddress(addressLG),
+         channelHG = o2::emcal::Channel::getChannelIndexFromHwAddress(addressHG);
+    fMeanPed[sm][ircu][branchHG][fecHG][chipHG][channelHG] = obj.getPedestalValue(iledmon, false, true);
+    fMeanPed[sm][ircu][branchLG][fecLG][chipLG][channelLG] = obj.getPedestalValue(iledmon, true, true);
+  }
+
+  return createInstructionString(runNum);
+}
+
+void EMCALPedestalHelper::setZero()
+{
+  for (int ism = 0; ism < kNSM; ism++) {
+    for (int ircu = 0; ircu < kNRCU; ircu++) {
+      for (int ibranch = 0; ibranch < kNBranch; ibranch++) {
+        for (int ifec = 0; ifec < kNFEC; ifec++) {
+          for (int ichip = 0; ichip < kNChip; ichip++) {
+            for (int ichan = 0; ichan < kNChan; ichan++) {
+              fMeanPed[ism][ircu][ibranch][ifec][ichip][ichan] = 0;
+            }
+          }
+        }
+      }
+    }
+  }
+}
+
+std::vector<char> EMCALPedestalHelper::createInstructionString(const int runNum)
+{
+  std::stringstream fout;
+
+  if (runNum > 0) {
+    fout << runNum << std::endl;
+  }
+
+  unsigned int lineValue = 0;
+
+  const unsigned int FECheaderCode = 0xC0000000;
+  //  const unsigned int FECwordCode   = 0x80000000;
+  const unsigned int FEClineCode = 0x40000000;
+
+  const unsigned int TrailerLineCode = 0xFFFFFFFF;
+
+  short iSM = 0;
+  short iRCU = 0;
+  short ibranch = 0;
+  short iFEC = 0;
+  short ichip = 0;
+  short ichan = 0;
+  short Ped = 0;
+  short iDTC = 0;
+
+  for (iSM = 0; iSM < kNSM; iSM++) {
+    int iside = iSM % 2;
+    int isect = iSM / 2;
+    if (iSM > 11) {
+      isect += 3; // skip non-installed sectors
+    }
+
+    std::bitset<kNDTC> activeDTC;
+    for (iDTC = 0; iDTC < kNDTC; iDTC++) {
+      if (iDTC == 10 || iDTC == 20 || iDTC == 30) { // skip TRU
+        activeDTC[iDTC] = 0;
+      } else {
+        if (iSM < 10) { // not special third SMs or DCal SMs
+          activeDTC[iDTC] = 1;
+        } else {
+          if (iSM == 10 || iSM == 19) { // SMA5 or SMC12
+            if (iDTC < 14) {
+              activeDTC[iDTC] = 1;
+            } else {
+              activeDTC[iDTC] = 0;
+            }
+          } else if (iSM == 11 || iSM == 18) { // SMC5 or SMA12
+            if (iDTC == 0 || iDTC >= 27) {
+              activeDTC[iDTC] = 1;
+            } else {
+              activeDTC[iDTC] = 0;
+            }
+          } else {
+            // DCal... no FECs in  9,11-13, 23-26, 36-39
+            if ((iDTC >= 9 && iDTC <= 13) || (iDTC >= 23 && iDTC <= 26) ||
+                (iDTC >= 36 && iDTC <= 39)) {
+              activeDTC[iDTC] = 0;
+            } else {
+              activeDTC[iDTC] = 1;
+            }
+          } // DCal
+        }   // non-EMCal
+      }     // non-TRU
+    }
+
+    // OK, let's generate the files for all active FECs/DTCs
+    for (iDTC = 0; iDTC < kNDTC; iDTC++) {
+      if (activeDTC[iDTC] == 0) {
+        continue;
+      }
+
+      lineValue = FECheaderCode | isect << 9 | iside << 8 | iDTC;
+      fout << lineValue << std::endl;
+
+      iRCU = iDTC / 20;
+      ibranch = (iDTC % 20) / 10;
+      iFEC = iDTC % 10;
+      int ipos = iFEC + 10 * ibranch;
+
+      int dtcselUpper = 0;
+      int dtcselLower = 0;
+      if (iRCU == 0) {
+        dtcselLower = (1 << ipos);
+      } else { // crate == 1
+        dtcselUpper = (1 << ipos);
+      }
+
+      for (ichip = 0; ichip < kNChip; ichip++) { // ALTRO 0,2,3,4
+        if (ichip != 1) {
+          for (ichan = 0; ichan < kNChan; ichan++) {
+            if (iFEC != 0 || (ichan < 8 || ichan > 11)) {
+              Ped = fMeanPed[iSM][iRCU][ibranch][iFEC][ichip][ichan];
+              int writeAddr = (ichip << 4) | ichan;
+              lineValue = FEClineCode | (writeAddr << 12) | Ped;
+              fout << lineValue << std::endl;
+            }
+          }
+        }
+      } // chip
+
+    } // iDTC
+  }   // iSM
+
+  if (runNum > 0) {
+    fout << TrailerLineCode << std::endl;
+  }
+
+  const std::string instructionString(fout.str());
+  std::vector<char> output(instructionString.begin(), instructionString.end());
+  return output;
+}
+
+void EMCALPedestalHelper::dumpInstructions(const std::string_view filename, const gsl::span<char>& data)
+{
+  std::ofstream fout(filename.data());
+  fout << data.data();
+  fout.close();
+}
\ No newline at end of file
diff --git a/Detectors/EMCAL/calibration/src/PedestalCalibDevice.cxx b/Detectors/EMCAL/calibration/src/PedestalCalibDevice.cxx
index a852dc8a79..2f4c6ee204 100644
--- a/Detectors/EMCAL/calibration/src/PedestalCalibDevice.cxx
+++ b/Detectors/EMCAL/calibration/src/PedestalCalibDevice.cxx
@@ -12,6 +12,7 @@
 #include "CommonUtils/VerbosityConfig.h"
 #include "DetectorsRaw/RDHUtils.h"
 #include "EMCALBase/Geometry.h"
+#include "Framework/TimingInfo.h"
 #include "EMCALCalibration/PedestalCalibDevice.h"
 #include "EMCALReconstruction/AltroDecoder.h"
 #include "EMCALReconstruction/RawReaderMemory.h"
@@ -39,6 +40,13 @@ void PedestalCalibDevice::init(o2::framework::InitContext& ctx)
 
 void PedestalCalibDevice::run(o2::framework::ProcessingContext& ctx)
 {
+  if (!mRun) {
+    const auto& tinfo = ctx.services().get<o2::framework::TimingInfo>();
+    if (tinfo.runNumber != 0) {
+      mRun = tinfo.runNumber;
+    }
+  }
+
   constexpr auto originEMC = o2::header::gDataOriginEMC;
   auto data = ctx.inputs().get<o2::emcal::PedestalProcessorData>(getPedDataBinding());
   LOG(debug) << "adding pedestal data";
@@ -60,6 +68,21 @@ void PedestalCalibDevice::sendData(o2::framework::EndOfStreamContext& ec, const
 
   ec.outputs().snapshot(o2::framework::Output{o2::calibration::Utils::gDataOriginCDBPayload, "EMC_PEDCALIB", 0}, *image.get());
   ec.outputs().snapshot(o2::framework::Output{o2::calibration::Utils::gDataOriginCDBWrapper, "EMC_PEDCALIB", 0}, objInfo);
+
+  // the following goes to the DCS ccdb
+  EMCALPedestalHelper helper;
+  std::vector<char> vecPedData = helper.createPedestalInstruction(data, mAddRunNumber ? mRun : -1);
+  if (mDumpToFile) {
+    helper.dumpInstructions("EMCAL-Pedestals.txt", vecPedData);
+  }
+
+  auto clNameDCS = o2::utils::MemFileHelper::getClassName(vecPedData);
+  auto flNameDCS = o2::ccdb::CcdbApi::generateFileName(clNameDCS);
+  o2::ccdb::CcdbObjectInfo objInfoDCS("EMC/Calib/PDData", clNameDCS, flNameDCS, md, mStartTS, o2::ccdb::CcdbObjectInfo::INFINITE_TIMESTAMP, true);
+  auto imageDCS = o2::ccdb::CcdbApi::createObjectImage(&vecPedData, &objInfoDCS);
+
+  ec.outputs().snapshot(o2::framework::Output{o2::calibration::Utils::gDataOriginCDBPayload, "EMC_PEDCALIBSTR", 1}, *imageDCS.get());
+  ec.outputs().snapshot(o2::framework::Output{o2::calibration::Utils::gDataOriginCDBWrapper, "EMC_PEDCALIBSTR", 1}, objInfoDCS);
 }
 
 //________________________________________________________________
@@ -72,7 +95,7 @@ void PedestalCalibDevice::endOfStream(o2::framework::EndOfStreamContext& ec)
   resetStartTS();
 }
 
-o2::framework::DataProcessorSpec o2::emcal::getPedestalCalibDevice()
+o2::framework::DataProcessorSpec o2::emcal::getPedestalCalibDevice(bool dumpToFile, bool addRunNum)
 {
 
   std::vector<o2::framework::InputSpec> inputs;
@@ -81,10 +104,13 @@ o2::framework::DataProcessorSpec o2::emcal::getPedestalCalibDevice()
   outputs.emplace_back(o2::framework::ConcreteDataTypeMatcher{o2::calibration::Utils::gDataOriginCDBPayload, "EMC_PEDCALIB"}, o2::framework::Lifetime::Sporadic);
   outputs.emplace_back(o2::framework::ConcreteDataTypeMatcher{o2::calibration::Utils::gDataOriginCDBWrapper, "EMC_PEDCALIB"}, o2::framework::Lifetime::Sporadic);
 
+  outputs.emplace_back(o2::framework::ConcreteDataTypeMatcher{o2::calibration::Utils::gDataOriginCDBPayload, "EMC_PEDCALIBSTR"}, o2::framework::Lifetime::Sporadic);
+  outputs.emplace_back(o2::framework::ConcreteDataTypeMatcher{o2::calibration::Utils::gDataOriginCDBWrapper, "EMC_PEDCALIBSTR"}, o2::framework::Lifetime::Sporadic);
+
   return o2::framework::DataProcessorSpec{
     "PedestalCalibrator",
     inputs,
     outputs,
-    o2::framework::AlgorithmSpec{o2::framework::adaptFromTask<o2::emcal::PedestalCalibDevice>()},
+    o2::framework::AlgorithmSpec{o2::framework::adaptFromTask<o2::emcal::PedestalCalibDevice>(dumpToFile, addRunNum)},
     o2::framework::Options{}};
 }
\ No newline at end of file
diff --git a/Detectors/EMCAL/calibration/testWorkflow/emc-pedestal-calib-workflow.cxx b/Detectors/EMCAL/calibration/testWorkflow/emc-pedestal-calib-workflow.cxx
index 92817d2326..c624dbaa89 100644
--- a/Detectors/EMCAL/calibration/testWorkflow/emc-pedestal-calib-workflow.cxx
+++ b/Detectors/EMCAL/calibration/testWorkflow/emc-pedestal-calib-workflow.cxx
@@ -31,7 +31,9 @@ using namespace o2::emcal;
 void customize(std::vector<ConfigParamSpec>& workflowOptions)
 {
   std::vector<ConfigParamSpec> options{
-    {"configKeyValues", VariantType::String, "", {"Semicolon separated key=value strings"}}};
+    {"configKeyValues", VariantType::String, "", {"Semicolon separated key=value strings"}},
+    {"dumpToFile", VariantType::Bool, false, {"if output (that goes to DCS ccdb) should be stored in txt file for local debugging"}},
+    {"addRunNumber", VariantType::Bool, false, {"if true, run number will be added to ccdb file as first element of the string"}}};
   std::swap(workflowOptions, options);
 }
 
@@ -41,9 +43,11 @@ WorkflowSpec defineDataProcessing(ConfigContext const& cfgc)
 {
 
   o2::conf::ConfigurableParam::updateFromString(cfgc.options().get<std::string>("configKeyValues"));
+  bool dumpToFile = cfgc.options().get<bool>("dumpToFile");
+  bool addRunNumber = cfgc.options().get<bool>("addRunNumber");
 
   WorkflowSpec specs;
-  specs.emplace_back(o2::emcal::getPedestalCalibDevice());
+  specs.emplace_back(o2::emcal::getPedestalCalibDevice(dumpToFile, addRunNumber));
 
   return specs;
 }
diff --git a/Detectors/ForwardAlign/CMakeLists.txt b/Detectors/ForwardAlign/CMakeLists.txt
index 48acb71e2c..bb7d35444e 100644
--- a/Detectors/ForwardAlign/CMakeLists.txt
+++ b/Detectors/ForwardAlign/CMakeLists.txt
@@ -21,6 +21,7 @@ o2_add_library(ForwardAlign
                 src/SymBDMatrix.cxx
                 src/SymMatrix.cxx
                 src/VectorSparse.cxx
+                src/MilleRecordWriterSpec.cxx
         PUBLIC_LINK_LIBRARIES O2::CCDB
                 O2::Steer
                 ROOT::TreePlayer)
@@ -37,4 +38,13 @@ o2_target_root_dictionary(ForwardAlign
                 include/ForwardAlign/SymBDMatrix.h
                 include/ForwardAlign/SymMatrix.h
                 include/ForwardAlign/VectorSparse.h
+                include/ForwardAlign/MilleRecordWriterSpec.h
         LINKDEF src/ForwardAlignLinkDef.h)
+
+
+
+o2_add_executable(
+        millerecord-writer-workflow
+        SOURCES src/MilleRecordWriterSpec.cxx src/millerecord-writer-workflow.cxx
+        COMPONENT_NAME fwdalign
+        PUBLIC_LINK_LIBRARIES O2::Framework O2::DPLUtils O2::ReconstructionDataFormats O2::SimulationDataFormat O2::ForwardAlign)
diff --git a/Detectors/ForwardAlign/include/ForwardAlign/MillePede2.h b/Detectors/ForwardAlign/include/ForwardAlign/MillePede2.h
index f3707aa64d..2c5bb8ef6d 100644
--- a/Detectors/ForwardAlign/include/ForwardAlign/MillePede2.h
+++ b/Detectors/ForwardAlign/include/ForwardAlign/MillePede2.h
@@ -156,6 +156,7 @@ class MillePede2
       fNGroupsSet = grID;
     }
   }
+  void ResetRecord() { fRecord->Reset(); }
   void SetNGloPar(const int n) { fNGloPar = n; }
   void SetNLocPar(const int n) { fNLocPar = n; }
   void SetNMaxIterations(const int n = 10) { fMaxIter = n; }
@@ -285,6 +286,9 @@ class MillePede2
     fIsLinear[id] = !v;
   }
 
+  /// \brief Disable record writer for DPL process
+  void DisableRecordWriter() { fDisableRecordWriter = true; }
+
  protected:
   /// \brief read data record (if any) at entry recID
   void ReadRecordData(const long recID, const bool doPrint = false);
@@ -360,6 +364,7 @@ class MillePede2
   long fCurrRecConstrID;      ///< ID of the current constraint record
   bool fLocFitAdd;            ///< Add contribution of carrent track (and not eliminate it)
   bool fUseRecordWeight;      ///< force or ignore the record weight
+  bool fDisableRecordWriter;  ///< disable record writer for DPL process
   int fMinRecordLength;       ///< ignore shorter records
   int fSelFirst;              ///< event selection start
   int fSelLast;               ///< event selection end
diff --git a/Detectors/ForwardAlign/include/ForwardAlign/MilleRecordWriterSpec.h b/Detectors/ForwardAlign/include/ForwardAlign/MilleRecordWriterSpec.h
new file mode 100644
index 0000000000..b10ab502da
--- /dev/null
+++ b/Detectors/ForwardAlign/include/ForwardAlign/MilleRecordWriterSpec.h
@@ -0,0 +1,33 @@
+// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
+// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
+// All rights not expressly granted are reserved.
+//
+// This software is distributed under the terms of the GNU General Public
+// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
+//
+// In applying this license CERN does not waive the privileges and immunities
+// granted to it by virtue of its status as an Intergovernmental Organization
+// or submit itself to any jurisdiction.
+
+/// \file MilleRecordWriterSpec.h
+/// \brief Implementation of a data processor to write MillePede record in a root file
+///
+/// \author Chi Zhang, CEA-Saclay, chi.zhang@cern.ch
+
+#ifndef ALICEO2_FWDALIGN_MILLERECORDWRITERSPEC_H
+#define ALICEO2_FWDALIGN_MILLERECORDWRITERSPEC_H
+
+#include "Framework/DataProcessorSpec.h"
+
+namespace o2
+{
+namespace fwdalign
+{
+
+framework::DataProcessorSpec getMilleRecordWriterSpec(bool useMC, const char* specName = "fwdalign-millerecord-writer",
+                                                      const char* fileName = "millerecords.root");
+
+} // namespace fwdalign
+} // namespace o2
+
+#endif // ALICEO2_FWDALIGN_MILLERECORDWRITERSPEC_H
\ No newline at end of file
diff --git a/Detectors/ForwardAlign/src/ForwardAlignLinkDef.h b/Detectors/ForwardAlign/src/ForwardAlignLinkDef.h
index cfc895a101..eb447d28e7 100644
--- a/Detectors/ForwardAlign/src/ForwardAlignLinkDef.h
+++ b/Detectors/ForwardAlign/src/ForwardAlignLinkDef.h
@@ -19,6 +19,7 @@
 #pragma link C++ class o2::fwdalign::MatrixSq + ;
 #pragma link C++ class o2::fwdalign::MillePede2 + ;
 #pragma link C++ class o2::fwdalign::MillePedeRecord + ;
+#pragma link C++ class std::vector < o2::fwdalign::MillePedeRecord> + ;
 #pragma link C++ class o2::fwdalign::MilleRecordReader + ;
 #pragma link C++ class o2::fwdalign::MilleRecordWriter + ;
 #pragma link C++ class o2::fwdalign::MinResSolve + ;
diff --git a/Detectors/ForwardAlign/src/MillePede2.cxx b/Detectors/ForwardAlign/src/MillePede2.cxx
index d66786d658..5ad475d893 100644
--- a/Detectors/ForwardAlign/src/MillePede2.cxx
+++ b/Detectors/ForwardAlign/src/MillePede2.cxx
@@ -10,7 +10,7 @@
 // or submit itself to any jurisdiction.
 
 /// @file MillePede2.cxx
-
+#include <iostream>
 #include "ForwardAlign/MillePede2.h"
 #include "Framework/Logger.h"
 #include <TStopwatch.h>
@@ -147,7 +147,8 @@ MillePede2::MillePede2(const MillePede2& src)
     fRecordWriter(nullptr),
     fConstraintsRecWriter(nullptr),
     fRecordReader(nullptr),
-    fConstraintsRecReader(nullptr)
+    fConstraintsRecReader(nullptr),
+    fDisableRecordWriter(false)
 {
   fWghScl[0] = src.fWghScl[0];
   fWghScl[1] = src.fWghScl[1];
@@ -314,16 +315,17 @@ void MillePede2::EndChi2Storage()
 void MillePede2::SetLocalEquation(std::vector<double>& dergb, std::vector<double>& derlc,
                                   const double lMeas, const double lSigma)
 {
-  if (!fRecordWriter) {
-    LOG(fatal) << "MillePede2::SetLocalEquation() - aborted: null pointer to record writer";
-    return;
-  }
-  if (!fRecordWriter->isInitOk()) {
-    LOG(fatal) << "MillePede2::SetLocalEquation() - aborted: unintialised record writer";
-    return;
+  if (!fDisableRecordWriter) {
+    if (!fRecordWriter) {
+      LOG(fatal) << "MillePede2::SetLocalEquation() - aborted: null pointer to record writer";
+      return;
+    }
+    if (!fRecordWriter->isInitOk()) {
+      LOG(fatal) << "MillePede2::SetLocalEquation() - aborted: unintialised record writer";
+      return;
+    }
+    SetRecord(fRecordWriter->getRecord());
   }
-  SetRecord(fRecordWriter->getRecord());
-
   // write data of single measurement
   if (lSigma <= 0.0) { // If parameter is fixed, then no equation
     for (int i = fNLocPar; i--;) {
@@ -336,7 +338,6 @@ void MillePede2::SetLocalEquation(std::vector<double>& dergb, std::vector<double
   }
 
   fRecord->AddResidual(lMeas);
-
   // Retrieve local param interesting indices
   for (int i = 0; i < fNLocPar; i++) {
     if (!IsZero(derlc[i])) {
@@ -364,16 +365,17 @@ void MillePede2::SetLocalEquation(std::vector<int>& indgb, std::vector<double>&
                                   std::vector<double>& derlc, const int nlc,
                                   const double lMeas, const double lSigma)
 {
-  if (!fRecordWriter) {
-    LOG(fatal) << "MillePede2::SetLocalEquation() - aborted: null pointer to record writer";
-    return;
-  }
-  if (!fRecordWriter->isInitOk()) {
-    LOG(fatal) << "MillePede2::SetLocalEquation() - aborted: unintialised record writer";
-    return;
+  if (!fDisableRecordWriter) {
+    if (!fRecordWriter) {
+      LOG(fatal) << "MillePede2::SetLocalEquation() - aborted: null pointer to record writer";
+      return;
+    }
+    if (!fRecordWriter->isInitOk()) {
+      LOG(fatal) << "MillePede2::SetLocalEquation() - aborted: unintialised record writer";
+      return;
+    }
+    SetRecord(fRecordWriter->getRecord());
   }
-  SetRecord(fRecordWriter->getRecord());
-
   if (lSigma <= 0.0) { // If parameter is fixed, then no equation
     for (int i = nlc; i--;) {
       derlc[i] = 0.0;
diff --git a/Detectors/ForwardAlign/src/MilleRecordReader.cxx b/Detectors/ForwardAlign/src/MilleRecordReader.cxx
index a169ba77b6..927e7972c2 100644
--- a/Detectors/ForwardAlign/src/MilleRecordReader.cxx
+++ b/Detectors/ForwardAlign/src/MilleRecordReader.cxx
@@ -25,7 +25,7 @@ MilleRecordReader::MilleRecordReader()
     mIsSuccessfulInit(false),
     mIsConstraintsRec(false),
     mIsReadEntryOk(false),
-    mDataTreeName("milleRecords"),
+    mDataTreeName("o2sim"),
     mDataBranchName("data"),
     mRecord(nullptr),
     mCurrentDataID(-1),
diff --git a/Detectors/ForwardAlign/src/MilleRecordWriter.cxx b/Detectors/ForwardAlign/src/MilleRecordWriter.cxx
index 8dbe31e917..e36c47562c 100644
--- a/Detectors/ForwardAlign/src/MilleRecordWriter.cxx
+++ b/Detectors/ForwardAlign/src/MilleRecordWriter.cxx
@@ -29,8 +29,8 @@ MilleRecordWriter::MilleRecordWriter()
     mIsSuccessfulInit(false),
     mIsConstraintsRec(false),
     mNEntriesAutoSave(10000),
-    mDataFileName("mft_mille_records.root"),
-    mDataTreeName("milleRecords"),
+    mDataFileName("millerecords.root"),
+    mDataTreeName("o2sim"),
     mDataBranchName("data"),
     mRecord(nullptr),
     mCurrentDataID(-1)
@@ -135,6 +135,7 @@ void MilleRecordWriter::terminate()
     mDataTree->Write();
     LOG(info) << "MilleRecordWriter::terminate() - wrote tree "
               << mDataTreeName.Data();
+    mDataFile->Close();
   }
 }
 
diff --git a/Detectors/ForwardAlign/src/MilleRecordWriterSpec.cxx b/Detectors/ForwardAlign/src/MilleRecordWriterSpec.cxx
new file mode 100644
index 0000000000..e3fe8c12a9
--- /dev/null
+++ b/Detectors/ForwardAlign/src/MilleRecordWriterSpec.cxx
@@ -0,0 +1,42 @@
+// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
+// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
+// All rights not expressly granted are reserved.
+//
+// This software is distributed under the terms of the GNU General Public
+// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
+//
+// In applying this license CERN does not waive the privileges and immunities
+// granted to it by virtue of its status as an Intergovernmental Organization
+// or submit itself to any jurisdiction.
+
+/// \file MilleRecordWriterSpec.cxx
+/// \brief Implementation of a data processor to write MillePede record in a root file
+///
+/// \author Chi Zhang, CEA-Saclay, chi.zhang@cern.ch
+
+#include "ForwardAlign/MilleRecordWriterSpec.h"
+
+#include <vector>
+#include "DPLUtils/MakeRootTreeWriterSpec.h"
+#include "ForwardAlign/MillePedeRecord.h"
+
+namespace o2
+{
+namespace fwdalign
+{
+
+using namespace o2::framework;
+
+template <typename T>
+using BranchDefinition = MakeRootTreeWriterSpec::BranchDefinition<T>;
+
+DataProcessorSpec getMilleRecordWriterSpec(bool useMC, const char* specName, const char* fileName)
+{
+  return MakeRootTreeWriterSpec(specName,
+                                fileName,
+                                MakeRootTreeWriterSpec::TreeAttributes{"o2sim", "Tree MillePede records for MCH-MID tracks"},
+                                BranchDefinition<fwdalign::MillePedeRecord>{InputSpec{"data", "MUON", "RECORD_MCHMID", Lifetime::Sporadic}, "data"})();
+}
+
+} // namespace fwdalign
+} // namespace o2
\ No newline at end of file
diff --git a/Detectors/ForwardAlign/src/millerecord-writer-workflow.cxx b/Detectors/ForwardAlign/src/millerecord-writer-workflow.cxx
new file mode 100644
index 0000000000..9144ef1cb1
--- /dev/null
+++ b/Detectors/ForwardAlign/src/millerecord-writer-workflow.cxx
@@ -0,0 +1,41 @@
+// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
+// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
+// All rights not expressly granted are reserved.
+//
+// This software is distributed under the terms of the GNU General Public
+// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
+//
+// In applying this license CERN does not waive the privileges and immunities
+// granted to it by virtue of its status as an Intergovernmental Organization
+// or submit itself to any jurisdiction.
+
+/// \file millerecord-writer-workflow.cxx
+/// \brief Implementation of a DPL device to run the MillePede record writer
+///
+/// \author Chi Zhang, CEA-Saclay, chi.zhang@cern.ch
+
+#include "ForwardAlign/MilleRecordWriterSpec.h"
+#include "Framework/CompletionPolicyHelpers.h"
+
+using namespace o2::framework;
+
+void customize(std::vector<CompletionPolicy>& policies)
+{
+  // ordered policies for the writers
+  policies.push_back(CompletionPolicyHelpers::consumeWhenAllOrdered(".*(?:FWDALIGN|fwdalign).*[W,w]riter.*"));
+}
+
+void customize(std::vector<ConfigParamSpec>& workflowOptions)
+{
+  // option allowing to set parameters
+  workflowOptions.emplace_back("disable-mc", VariantType::Bool, false,
+                               ConfigParamSpec::HelpString{"disable MC propagation even if available"});
+}
+
+#include "Framework/runDataProcessing.h"
+
+WorkflowSpec defineDataProcessing(const ConfigContext& configcontext)
+{
+  auto useMC = !configcontext.options().get<bool>("disable-mc");
+  return WorkflowSpec{o2::fwdalign::getMilleRecordWriterSpec(useMC)};
+}
\ No newline at end of file
diff --git a/Detectors/GRP/workflows/CMakeLists.txt b/Detectors/GRP/workflows/CMakeLists.txt
index 5de19f9061..ea56cf8270 100644
--- a/Detectors/GRP/workflows/CMakeLists.txt
+++ b/Detectors/GRP/workflows/CMakeLists.txt
@@ -37,6 +37,7 @@ o2_add_executable(workflow
                   PUBLIC_LINK_LIBRARIES O2::Framework
                                         O2::CCDB
                                         O2::DetectorsBase
+                                        O2::DetectorsCalibration
                                         O2::DataFormatsParameters)
 
 o2_add_executable(grp-create
diff --git a/Detectors/GRP/workflows/src/create-grp-ecs.cxx b/Detectors/GRP/workflows/src/create-grp-ecs.cxx
index 9b93bbf00a..95bfb878ce 100644
--- a/Detectors/GRP/workflows/src/create-grp-ecs.cxx
+++ b/Detectors/GRP/workflows/src/create-grp-ecs.cxx
@@ -134,7 +134,7 @@ int createGRPECSObject(const std::string& dataPeriod,
     } else {
       LOGP(alarm, "Upload to {}/{} with validity {}:{} for SOR:{}/EOR:{} FAILED, returned with code {}", ccdbServer, objPath, tstart, tendVal, tstart, tend, retValGLO);
     }
-    if (runType == GRPECSObject::RunType::PHYSICS || runType == GRPECSObject::RunType::COSMICS) { // also create the RCT/Info/RunInformation entry in case the run type is PHYSICS, to be finalized at EOR
+    if ((runType == GRPECSObject::RunType::PHYSICS || runType == GRPECSObject::RunType::COSMICS) && tstart >= tend) { // also create the RCT/Info/RunInformation entry in case the run type is PHYSICS, to be finalized at EOR
       char tempChar{};
       std::map<std::string, std::string> mdRCT;
       mdRCT["SOR"] = std::to_string(tstart);
diff --git a/Detectors/GRP/workflows/src/rct-updater-workflow.cxx b/Detectors/GRP/workflows/src/rct-updater-workflow.cxx
index 1e82db670e..3020f236af 100644
--- a/Detectors/GRP/workflows/src/rct-updater-workflow.cxx
+++ b/Detectors/GRP/workflows/src/rct-updater-workflow.cxx
@@ -15,6 +15,7 @@
 #include "Framework/InputSpec.h"
 #include "Framework/Task.h"
 #include "CommonUtils/ConfigurableParam.h"
+#include "DetectorsCalibration/Utils.h"
 
 using namespace o2::framework;
 
@@ -131,7 +132,7 @@ class RCTUpdaterSpec : public o2::framework::Task
     if (mCCDBApi) {
       int retValRCT = mCCDBApi->updateMetadata("RCT/Info/RunInformation", mdRCT, startValRCT);
       if (retValRCT == 0) {
-        LOGP(info, "Updated RCT object for run {} with TF start:{} end:{}", mRunNumber, mdRCT["STF"], mdRCT["ETF"]);
+        LOGP(info, "Updated {}/RCT/Info/RunInformation object for run {} with TF start:{} end:{}", mCCDBApi->getURL(), mRunNumber, mdRCT["STF"], mdRCT["ETF"]);
       } else {
         LOGP(alarm, "Update of RCT object for run {} with TF start:{} end:{} FAILED, returned with code {}", mRunNumber, mdRCT["STF"], mdRCT["ETF"], retValRCT);
       }
@@ -164,6 +165,9 @@ WorkflowSpec defineDataProcessing(ConfigContext const& configcontext)
   WorkflowSpec specs;
   o2::conf::ConfigurableParam::updateFromString(configcontext.options().get<std::string>("configKeyValues"));
   std::vector<InputSpec> inputs{{"ctfdone", "CTF", "DONE", 0, Lifetime::Timeframe}};
+  std::vector<OutputSpec> outputs;
+  outputs.emplace_back(ConcreteDataTypeMatcher{o2::calibration::Utils::gDataOriginCDBPayload, "RCTUPD_DUMMY"}, Lifetime::Sporadic);
+  outputs.emplace_back(ConcreteDataTypeMatcher{o2::calibration::Utils::gDataOriginCDBWrapper, "RCTUPD_DUMMY"}, Lifetime::Sporadic);
   auto ggRequest = std::make_shared<o2::base::GRPGeomRequest>(true,                           // orbitResetTime
                                                               true,                           // GRPECS=true
                                                               false,                          // GRPLHCIF
@@ -175,7 +179,7 @@ WorkflowSpec defineDataProcessing(ConfigContext const& configcontext)
   specs.push_back(DataProcessorSpec{
     "rct-updater",
     inputs,
-    {},
+    outputs,
     AlgorithmSpec{adaptFromTask<o2::rct::RCTUpdaterSpec>(ggRequest)},
     Options{
       {"update-interval", VariantType::Float, 1.f, {"update every ... seconds"}},
diff --git a/Detectors/GlobalTracking/include/GlobalTracking/MatchTOF.h b/Detectors/GlobalTracking/include/GlobalTracking/MatchTOF.h
index 879fb7f804..0d0e2f40f5 100644
--- a/Detectors/GlobalTracking/include/GlobalTracking/MatchTOF.h
+++ b/Detectors/GlobalTracking/include/GlobalTracking/MatchTOF.h
@@ -287,6 +287,7 @@ class MatchTOF
   /// data needed for refit of time-constrained TPC tracks
   gsl::span<const o2::tpc::TPCClRefElem> mTPCTrackClusIdx;            ///< input TPC track cluster indices span
   gsl::span<const unsigned char> mTPCRefitterShMap;                   ///< externally set TPC clusters sharing map
+  gsl::span<const unsigned int> mTPCRefitterOccMap;                   ///< externally set TPC clusters occupancy map
   const o2::tpc::ClusterNativeAccess* mTPCClusterIdxStruct = nullptr; ///< struct holding the TPC cluster indices
 
   o2::gpu::CorrectionMapsHelper* mTPCCorrMapsHelper = nullptr;        ///< TPC cluster transformation
diff --git a/Detectors/GlobalTracking/include/GlobalTracking/MatchTPCITS.h b/Detectors/GlobalTracking/include/GlobalTracking/MatchTPCITS.h
index 190a00ce4f..a2cb21bdaf 100644
--- a/Detectors/GlobalTracking/include/GlobalTracking/MatchTPCITS.h
+++ b/Detectors/GlobalTracking/include/GlobalTracking/MatchTPCITS.h
@@ -636,6 +636,7 @@ class MatchTPCITS
   gsl::span<const o2::ft0::RecPoints> mFITInfo;             ///< optional input FIT info span
 
   gsl::span<const unsigned char> mTPCRefitterShMap; ///< externally set TPC clusters sharing map
+  gsl::span<const unsigned int> mTPCRefitterOccMap; ///< externally set TPC clusters occupancy map
 
   const o2::itsmft::TopologyDictionary* mITSDict{nullptr}; // cluster patterns dictionary
 
diff --git a/Detectors/GlobalTracking/src/MatchCosmics.cxx b/Detectors/GlobalTracking/src/MatchCosmics.cxx
index 3d9453bca3..3c20ecad2f 100644
--- a/Detectors/GlobalTracking/src/MatchCosmics.cxx
+++ b/Detectors/GlobalTracking/src/MatchCosmics.cxx
@@ -89,12 +89,13 @@ void MatchCosmics::refitWinners(const o2::globaltracking::RecoContainer& data)
   auto tpcTBinMUSInv = 1. / mTPCTBinMUS;
   const auto& tpcClusRefs = data.getTPCTracksClusterRefs();
   const auto& tpcClusShMap = data.clusterShMapTPC;
+  const auto& tpcClusOccMap = data.occupancyMapTPC;
   std::unique_ptr<o2::gpu::GPUO2InterfaceRefit> tpcRefitter;
   if (data.inputsTPCclusters) {
     tpcRefitter = std::make_unique<o2::gpu::GPUO2InterfaceRefit>(&data.inputsTPCclusters->clusterIndex,
                                                                  mTPCCorrMapsHelper, mBz,
-                                                                 tpcClusRefs.data(), tpcClusShMap.data(),
-                                                                 nullptr, o2::base::Propagator::Instance());
+                                                                 tpcClusRefs.data(), 0, tpcClusShMap.data(),
+                                                                 tpcClusOccMap.data(), tpcClusOccMap.size(), nullptr, o2::base::Propagator::Instance());
   }
 
   const auto& itsClusters = prepareITSClusters(data);
diff --git a/Detectors/GlobalTracking/src/MatchHMP.cxx b/Detectors/GlobalTracking/src/MatchHMP.cxx
index a3c261506d..207bbdb9bf 100644
--- a/Detectors/GlobalTracking/src/MatchHMP.cxx
+++ b/Detectors/GlobalTracking/src/MatchHMP.cxx
@@ -404,191 +404,6 @@ void MatchHMP::doMatching()
 
       // if (evtTime < (maxTrkTime + timeFromTF) && evtTime > (minTrkTime + timeFromTF)) {
       if (evtTime < maxTrkTime && evtTime > minTrkTime) {
-        LOGP(info, "matched in time : not shifted");
-
-        evtTracks++;
-
-        MatchInfo matching(999999, mTrackGid[type][cacheTrk[itrk]]);
-
-        matching.setHMPIDtrk(0, 0, 0, 0);            // no intersection found
-        matching.setHMPIDmip(0, 0, 0, 0);            // store mip info in any case
-        matching.setIdxHMPClus(99, 99999);           // chamber not found, mip not yet considered
-        matching.setHMPsignal(Recon::kNotPerformed); // ring reconstruction not yet performed
-        matching.setIdxTrack(trackGid);
-        TrackHMP hmpTrk(trefTrk); // create a hmpid track to be used for propagation and matching
-
-        hmpTrk.set(trefTrk.getX(), trefTrk.getAlpha(), trefTrk.getParams(), trefTrk.getCharge(), trefTrk.getPID());
-
-        double xPc, yPc, xRa, yRa, theta, phi;
-
-        Int_t iCh = intTrkCha(&trefTrk, xPc, yPc, xRa, yRa, theta, phi, bz); // find the intersected chamber for this track
-        if (iCh < 0) {
-          goto if2;
-        } // no intersection at all, go next track
-
-        matching.setHMPIDtrk(xPc, yPc, theta, phi); // store initial infos
-        matching.setIdxHMPClus(iCh, 9999);          // set chamber, index of cluster + cluster size
-
-        int index = -1;
-
-        double dmin = 999999; //, distCut = 1.;
-
-        bool isOkDcut = kFALSE;
-        bool isOkQcut = kFALSE;
-        bool isMatched = kFALSE;
-
-        Cluster* bestHmpCluster = nullptr; // the best matching cluster
-        std::vector<Cluster> oneEventClusters;
-
-        for (int j = event.getFirstEntry(); j <= event.getLastEntry(); j++) { // event clusters loop
-          auto& cluster = (o2::hmpid::Cluster&)mHMPClustersArray[j];
-
-          if (cluster.ch() != iCh) {
-            goto if2;
-          }
-          oneEventClusters.push_back(cluster);
-          double qthre = pParam->qCut();
-
-          if (cluster.q() < 150. || cluster.size() > 10) {
-            goto if2;
-          }
-
-          isOkQcut = kTRUE;
-
-          cluLORS[0] = cluster.x();
-          cluLORS[1] = cluster.y(); // get the LORS coordinates of the cluster
-
-          double dist = 0.;
-
-          if (TMath::Abs((xPc - cluLORS[0]) * (xPc - cluLORS[0]) + (yPc - cluLORS[1]) * (yPc - cluLORS[1])) > 0.0001) {
-
-            dist = TMath::Sqrt((xPc - cluLORS[0]) * (xPc - cluLORS[0]) + (yPc - cluLORS[1]) * (yPc - cluLORS[1]));
-          }
-
-          if (dist < dmin) {
-            dmin = dist;
-            index = oneEventClusters.size() - 1;
-            bestHmpCluster = &cluster;
-          }
-
-        } // event clusters loop
-
-        // 2. Propagate track to the MIP cluster using the central method
-
-        if (!bestHmpCluster) {
-          oneEventClusters.clear();
-          goto if2;
-        }
-
-        TVector3 vG = pParam->lors2Mars(iCh, bestHmpCluster->x(), bestHmpCluster->y());
-        float gx = vG.X();
-        float gy = vG.Y();
-        float gz = vG.Z();
-        float alpha = TMath::ATan2(gy, gx);
-        float radiusH = TMath::Sqrt(gy * gy + gx * gx);
-        if (!(hmpTrk.rotate(alpha))) {
-          goto if2;
-        }
-        if (!prop->PropagateToXBxByBz(hmpTrk, radiusH, o2::base::Propagator::MAX_SIN_PHI, o2::base::Propagator::MAX_STEP, matCorr)) {
-          oneEventClusters.clear();
-          goto if2;
-        }
-
-        // 3. Update the track with MIP cluster (Improved angular and position resolution - to be used for Cherenkov angle calculation)
-
-        o2::track::TrackParCov trackC(hmpTrk);
-
-        std::array<float, 2> trkPos{0, gz};
-        std::array<float, 3> trkCov{0.1 * 0.1, 0., 0.1 * 0.1};
-
-        // auto chi2 = trackC.getPredictedChi2(trkPos, trkCov);
-        trackC.update(trkPos, trkCov);
-
-        // 4. Propagate back the constrained track to the radiator radius
-
-        TrackHMP hmpTrkConstrained(trackC);
-        hmpTrkConstrained.set(trackC.getX(), trackC.getAlpha(), trackC.getParams(), trackC.getCharge(), trackC.getPID());
-        if (!prop->PropagateToXBxByBz(hmpTrkConstrained, radiusH - kdRadiator, o2::base::Propagator::MAX_SIN_PHI, o2::base::Propagator::MAX_STEP, matCorr)) {
-          oneEventClusters.clear();
-          goto if2;
-        }
-
-        float hmpMom = hmpTrkConstrained.getP() * hmpTrkConstrained.getSign();
-
-        matching.setHmpMom(hmpMom);
-
-        // 5. Propagation in the last 10 cm with the fast method
-
-        double xPc0 = 0., yPc0 = 0.;
-        intTrkCha(iCh, &hmpTrkConstrained, xPc0, yPc0, xRa, yRa, theta, phi, bz);
-
-        // 6. Set match information
-
-        int cluSize = bestHmpCluster->size();
-        matching.setHMPIDmip(bestHmpCluster->x(), bestHmpCluster->y(), (int)bestHmpCluster->q(), 0); // store mip info in any case
-        matching.setMipClusSize(bestHmpCluster->size());
-        matching.setIdxHMPClus(iCh, index + 1000 * cluSize); // set chamber, index of cluster + cluster size
-        matching.setHMPIDtrk(xPc, yPc, theta, phi);
-
-        if (!isOkQcut) {
-          matching.setHMPsignal(pParam->kMipQdcCut);
-        }
-
-        // dmin recalculated
-
-        dmin = TMath::Sqrt((xPc - bestHmpCluster->x()) * (xPc - bestHmpCluster->x()) + (yPc - bestHmpCluster->y()) * (yPc - bestHmpCluster->y()));
-
-        if (dmin < 6.) {
-          isOkDcut = kTRUE;
-        }
-        // isOkDcut = kTRUE; // switch OFF cut
-
-        if (!isOkDcut) {
-          matching.setHMPsignal(pParam->kMipDistCut); // closest cluster with enough charge is still too far from intersection
-        }
-
-        if (isOkQcut * isOkDcut) {
-          isMatched = kTRUE;
-        } // MIP-Track matched !!
-
-        if (!isMatched) {
-          mMatchedTracks[type].push_back(matching);
-          oneEventClusters.clear();
-          //continue;
-        } // If matched continue...
-
-        double nmean = pParam->meanIdxRad();
-
-        // 7. Calculate the Cherenkov angle
-
-        recon->setImpPC(xPc, yPc);                                             // store track impact to PC
-        recon->ckovAngle(&matching, oneEventClusters, index, nmean, xRa, yRa); // search for Cerenkov angle of this track
-
-        LOGP(info, "matched in time : not shifted ckov {}", matching.getHMPsignal());
-
-        mMatchedTracks[type].push_back(matching);
-
-        oneEventClusters.clear();
-
-       // if matching in time
-      }
-       LOGP(info, "  end track times not shifting\n\n");
-      //}
-      
-      if2:
-      LOGP(info, "  start track times shifting");
-      if (evtTime < maxTrkTime && evtTime > minTrkTime) {
-
-
-        if(ievt + 1 < cacheTriggerHMP.size()) {
-          event = mHMPTriggersWork[cacheTriggerHMP[ievt+1]];
-          LOGP(info, "shifted track.. ");
-        } else {
-          event = mHMPTriggersWork[cacheTriggerHMP[ievt]];
-          LOGP(info, "not shifted track because out of index ");
-
-        }
-
 
         evtTracks++;
 
@@ -747,13 +562,12 @@ void MatchHMP::doMatching()
 
         recon->setImpPC(xPc, yPc);                                             // store track impact to PC
         recon->ckovAngle(&matching, oneEventClusters, index, nmean, xRa, yRa); // search for Cerenkov angle of this track
-        LOGP(info, "matched in time || shifted event,  ckov {}", matching.getHMPsignal());
+
         mMatchedTracks[type].push_back(matching);
 
         oneEventClusters.clear();
 
       } // if matching in time
-      LOGP(info, "end if matching in time >> shifted");
     }   // tracks loop
   }     // events loop
 
diff --git a/Detectors/GlobalTracking/src/MatchTOF.cxx b/Detectors/GlobalTracking/src/MatchTOF.cxx
index fa1b0c3a3d..3a0ee70570 100644
--- a/Detectors/GlobalTracking/src/MatchTOF.cxx
+++ b/Detectors/GlobalTracking/src/MatchTOF.cxx
@@ -490,6 +490,7 @@ bool MatchTOF::prepareTPCData()
     mTPCTracksArray = mRecoCont->getTPCTracks();
     mTPCTrackClusIdx = mRecoCont->getTPCTracksClusterRefs();
     mTPCRefitterShMap = mRecoCont->clusterShMapTPC;
+    mTPCRefitterOccMap = mRecoCont->occupancyMapTPC;
   }
 
   return true;
@@ -1797,7 +1798,7 @@ void MatchTOF::checkRefitter()
 {
   if (mTPCClusterIdxStruct) {
     mTPCRefitter = std::make_unique<o2::gpu::GPUO2InterfaceRefit>(mTPCClusterIdxStruct, mTPCCorrMapsHelper, mBz,
-                                                                  mTPCTrackClusIdx.data(), mTPCRefitterShMap.data(),
-                                                                  nullptr, o2::base::Propagator::Instance());
+                                                                  mTPCTrackClusIdx.data(), 0, mTPCRefitterShMap.data(),
+                                                                  mTPCRefitterOccMap.data(), mTPCRefitterOccMap.size(), nullptr, o2::base::Propagator::Instance());
   }
 }
diff --git a/Detectors/GlobalTracking/src/MatchTPCITS.cxx b/Detectors/GlobalTracking/src/MatchTPCITS.cxx
index 5bfc9df563..2a6e8efd9e 100644
--- a/Detectors/GlobalTracking/src/MatchTPCITS.cxx
+++ b/Detectors/GlobalTracking/src/MatchTPCITS.cxx
@@ -467,6 +467,8 @@ bool MatchTPCITS::prepareTPCData()
   mTPCTrackClusIdx = inp.getTPCTracksClusterRefs();
   mTPCClusterIdxStruct = &inp.inputsTPCclusters->clusterIndex;
   mTPCRefitterShMap = inp.clusterShMapTPC;
+  mTPCRefitterOccMap = inp.occupancyMapTPC;
+
   if (mMCTruthON) {
     mTPCTrkLabels = inp.getTPCTracksMCLabels();
   }
@@ -572,7 +574,7 @@ bool MatchTPCITS::prepareTPCData()
     mITSROFofTPCBin[ib] = itsROF;
   }
 */
-  mTPCRefitter = std::make_unique<o2::gpu::GPUO2InterfaceRefit>(mTPCClusterIdxStruct, mTPCCorrMapsHelper, mBz, mTPCTrackClusIdx.data(), mTPCRefitterShMap.data(), nullptr, o2::base::Propagator::Instance());
+  mTPCRefitter = std::make_unique<o2::gpu::GPUO2InterfaceRefit>(mTPCClusterIdxStruct, mTPCCorrMapsHelper, mBz, mTPCTrackClusIdx.data(), 0, mTPCRefitterShMap.data(), mTPCRefitterOccMap.data(), mTPCRefitterOccMap.size(), nullptr, o2::base::Propagator::Instance());
   mInteractionMUSLUT.clear();
   mInteractionMUSLUT.resize(maxTime + 3 * o2::constants::lhc::LHCOrbitMUS, -1);
   mTimer[SWPrepTPC].Stop();
diff --git a/Detectors/GlobalTrackingWorkflow/helpers/src/InputHelper.cxx b/Detectors/GlobalTrackingWorkflow/helpers/src/InputHelper.cxx
index c6c163f4b8..b4e187b67a 100644
--- a/Detectors/GlobalTrackingWorkflow/helpers/src/InputHelper.cxx
+++ b/Detectors/GlobalTrackingWorkflow/helpers/src/InputHelper.cxx
@@ -129,7 +129,7 @@ int InputHelper::addInputSpecs(const ConfigContext& configcontext, WorkflowSpec&
     specs.emplace_back(o2::tof::getClusterReaderSpec(maskClustersMC[GID::TOF]));
   }
   if (maskClusters[GID::HMP]) {
-    specs.emplace_back(o2::hmpid::getClusterReaderSpec());
+    specs.emplace_back(o2::hmpid::getClusterReaderSpec(maskClustersMC[GID::HMP]));
   }
   if (maskMatches[GID::TPCTOF] || maskTracks[GID::TPCTOF]) {
     specs.emplace_back(o2::tof::getTOFMatchedReaderSpec(maskTracksMC[GID::TPCTOF], 0, maskTracks[GID::TPCTOF], subSpecStrict));
diff --git a/Detectors/GlobalTrackingWorkflow/study/CMakeLists.txt b/Detectors/GlobalTrackingWorkflow/study/CMakeLists.txt
index c632b7ae72..17bad37b3c 100644
--- a/Detectors/GlobalTrackingWorkflow/study/CMakeLists.txt
+++ b/Detectors/GlobalTrackingWorkflow/study/CMakeLists.txt
@@ -19,6 +19,8 @@ o2_add_library(GlobalTrackingStudy
                        src/TPCDataFilter.cxx
                        src/ITSOffsStudy.cxx
                        src/DumpTracks.cxx
+                       src/V0Ext.cxx
+                       src/TrackInfoExt.cxx
                PUBLIC_LINK_LIBRARIES O2::GlobalTracking
                                      O2::GlobalTrackingWorkflowReaders
                                      O2::GlobalTrackingWorkflowHelpers
@@ -27,6 +29,12 @@ o2_add_library(GlobalTrackingStudy
                                      O2::TPCWorkflow
                                      O2::SimulationDataFormat)
 
+o2_target_root_dictionary(
+  GlobalTrackingStudy
+  HEADERS include/GlobalTrackingStudy/V0Ext.h
+          include/GlobalTrackingStudy/TrackInfoExt.h
+)
+
 o2_add_executable(study-workflow
                   COMPONENT_NAME sv
                   SOURCES src/sv-study-workflow.cxx
diff --git a/Detectors/GlobalTrackingWorkflow/study/include/GlobalTrackingStudy/TrackInfoExt.h b/Detectors/GlobalTrackingWorkflow/study/include/GlobalTrackingStudy/TrackInfoExt.h
new file mode 100644
index 0000000000..90db0ca4ee
--- /dev/null
+++ b/Detectors/GlobalTrackingWorkflow/study/include/GlobalTrackingStudy/TrackInfoExt.h
@@ -0,0 +1,49 @@
+// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
+// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
+// All rights not expressly granted are reserved.
+//
+// This software is distributed under the terms of the GNU General Public
+// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
+//
+// In applying this license CERN does not waive the privileges and immunities
+// granted to it by virtue of its status as an Intergovernmental Organization
+// or submit itself to any jurisdiction.
+
+// class for extended Track info (for debugging)
+
+#ifndef ALICEO2_TRINFOEXT_H
+#define ALICEO2_TRINFOEXT_H
+
+#include "ReconstructionDataFormats/MatchInfoTOF.h"
+#include "ReconstructionDataFormats/DCA.h"
+#include "ReconstructionDataFormats/VtxTrackIndex.h"
+#include "ReconstructionDataFormats/Track.h"
+
+namespace o2
+{
+namespace dataformats
+{
+
+struct TrackInfoExt {
+  o2::track::TrackParCov track;
+  DCA dca{};
+  VtxTrackIndex gid;
+  MatchInfoTOF infoTOF;
+  float ttime = 0;
+  float ttimeE = 0;
+  float xmin = 0;
+  float chi2ITSTPC = 0.f;
+  float q2ptITS = 0.f;
+  float q2ptTPC = 0.f;
+  float q2ptITSTPC = 0.f;
+  float q2ptITSTPCTRD = 0.f;
+  int nClTPC = 0;
+  int nClITS = 0;
+  int pattITS = 0;
+  ClassDefNV(TrackInfoExt, 1);
+};
+
+} // namespace dataformats
+} // namespace o2
+
+#endif
diff --git a/Detectors/GlobalTrackingWorkflow/study/include/GlobalTrackingStudy/V0Ext.h b/Detectors/GlobalTrackingWorkflow/study/include/GlobalTrackingStudy/V0Ext.h
new file mode 100644
index 0000000000..1beddf693c
--- /dev/null
+++ b/Detectors/GlobalTrackingWorkflow/study/include/GlobalTrackingStudy/V0Ext.h
@@ -0,0 +1,44 @@
+// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
+// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
+// All rights not expressly granted are reserved.
+//
+// This software is distributed under the terms of the GNU General Public
+// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
+//
+// In applying this license CERN does not waive the privileges and immunities
+// granted to it by virtue of its status as an Intergovernmental Organization
+// or submit itself to any jurisdiction.
+
+// class for extended V0 info (for debugging)
+
+#ifndef ALICEO2_V0EXT_H
+#define ALICEO2_V0EXT_H
+
+#include "ReconstructionDataFormats/V0.h"
+
+namespace o2
+{
+namespace dataformats
+{
+
+struct ProngInfoExt {
+  o2::track::TrackParCov trackTPC;
+  int nClTPC = 0;
+  int nClITS = 0;
+  int pattITS = 0;
+  float chi2ITSTPC = 0.f;
+  ClassDefNV(ProngInfoExt, 1);
+};
+
+struct V0Ext {
+  V0 v0;
+  V0Index v0ID;
+  std::array<ProngInfoExt, 2> prInfo{};
+  const ProngInfoExt& getPrInfo(int i) const { return prInfo[i]; }
+  ClassDefNV(V0Ext, 1);
+};
+
+} // namespace dataformats
+} // namespace o2
+
+#endif
diff --git a/Detectors/GlobalTrackingWorkflow/study/src/GlobalTrackingStudyLinkDef.h b/Detectors/GlobalTrackingWorkflow/study/src/GlobalTrackingStudyLinkDef.h
index c85dd2d378..9b14e24d03 100644
--- a/Detectors/GlobalTrackingWorkflow/study/src/GlobalTrackingStudyLinkDef.h
+++ b/Detectors/GlobalTrackingWorkflow/study/src/GlobalTrackingStudyLinkDef.h
@@ -15,4 +15,11 @@
 #pragma link off all classes;
 #pragma link off all functions;
 
+#pragma link C++ class o2::dataformats::ProngInfoExt + ;
+#pragma link C++ class o2::dataformats::V0Ext + ;
+#pragma link C++ class o2::dataformats::TrackInfoExt + ;
+#pragma link C++ class std::vector < o2::dataformats::TrackInfoExt> + ;
+#pragma link C++ class std::vector < o2::dataformats::ProngInfoExt> + ;
+#pragma link C++ class std::vector < o2::dataformats::V0Ext> + ;
+
 #endif
diff --git a/Detectors/GlobalTrackingWorkflow/study/src/SVStudy.cxx b/Detectors/GlobalTrackingWorkflow/study/src/SVStudy.cxx
index 813efc3ed2..9ea30577dc 100644
--- a/Detectors/GlobalTrackingWorkflow/study/src/SVStudy.cxx
+++ b/Detectors/GlobalTrackingWorkflow/study/src/SVStudy.cxx
@@ -42,6 +42,7 @@
 #include "Steer/MCKinematicsReader.h"
 #include "DCAFitter/DCAFitterN.h"
 #include "MathUtils/fit.h"
+#include "GlobalTrackingStudy/V0Ext.h"
 
 namespace o2::svstudy
 {
@@ -70,6 +71,7 @@ class SVStudySpec : public Task
   void endOfStream(EndOfStreamContext& ec) final;
   void finaliseCCDB(ConcreteDataMatcher& matcher, void* obj) final;
   void process(o2::globaltracking::RecoContainer& recoData);
+  o2::dataformats::V0Ext processV0(int iv, o2::globaltracking::RecoContainer& recoData);
 
  private:
   void updateTimeDependentParams(ProcessingContext& pc);
@@ -78,7 +80,7 @@ class SVStudySpec : public Task
   std::shared_ptr<o2::base::GRPGeomRequest> mGGCCDBRequest;
   bool mUseMC{false}; ///< MC flag
   std::unique_ptr<o2::utils::TreeStreamRedirector> mDBGOut;
-  bool mSelK0 = false;
+  float mSelK0 = -1;
   bool mRefit = false;
   float mMaxEta = 0.8;
   float mBz = 0;
@@ -92,7 +94,7 @@ void SVStudySpec::init(InitContext& ic)
   o2::base::GRPGeomHelper::instance().setRequest(mGGCCDBRequest);
   mDBGOut = std::make_unique<o2::utils::TreeStreamRedirector>("svStudy.root", "recreate");
   mRefit = ic.options().get<bool>("refit");
-  mSelK0 = ic.options().get<bool>("sel-k0");
+  mSelK0 = ic.options().get<float>("sel-k0");
   mMaxEta = ic.options().get<float>("max-eta");
 }
 
@@ -132,71 +134,108 @@ void SVStudySpec::updateTimeDependentParams(ProcessingContext& pc)
   mFitterV0.setBz(mBz);
 }
 
-void SVStudySpec::process(o2::globaltracking::RecoContainer& recoData)
+o2::dataformats::V0Ext SVStudySpec::processV0(int iv, o2::globaltracking::RecoContainer& recoData)
 {
+  o2::dataformats::V0Ext v0ext;
+  auto invalidate = [&v0ext]() { v0ext.v0ID.setVertexID(-1); };
+
   auto v0s = recoData.getV0s();
   auto v0IDs = recoData.getV0sIdx();
-  bool refit = mRefit || (v0s.size() < v0IDs.size());
-  int nv0 = v0IDs.size();
-  o2::dataformats::V0 v0ref;
-  o2::track::TrackParCov dummyTr{};
-  const o2::track::TrackParCov* tpcTracks[2] = {&dummyTr, &dummyTr};
-  int nclTPC[2] = {0, 0}, nclITS[2] = {0, 0}, itsPatt[2] = {0, 0};
   static int tfID = 0;
 
-  for (int iv = 0; iv < nv0; iv++) {
-    const auto& v0id = v0IDs[iv];
-    if (mRefit && !refitV0(v0id, v0ref, recoData)) {
-      continue;
-    }
-    const auto& v0 = mRefit ? v0ref : v0s[iv];
-    if (mMaxEta > std::abs(v0.getEta())) {
-      continue;
-    }
-    if (mSelK0 && std::abs(std::sqrt(v0.calcMass2AsK0()) - 0.497) > 0.1) {
-      continue;
+  const auto& v0id = v0IDs[iv];
+  if (mRefit && !refitV0(v0id, v0ext.v0, recoData)) {
+    invalidate();
+    return v0ext;
+  }
+  const auto& v0sel = mRefit ? v0ext.v0 : v0s[iv];
+  if (mMaxEta < std::abs(v0sel.getEta())) {
+    invalidate();
+    return v0ext;
+  }
+  if (mSelK0 > 0 && std::abs(std::sqrt(v0sel.calcMass2AsK0()) - 0.497) > mSelK0) {
+    invalidate();
+    return v0ext;
+  }
+  v0ext.v0ID = v0id;
+  for (int ip = 0; ip < 2; ip++) {
+    auto& prInfo = v0ext.prInfo[ip];
+    auto gid = v0ext.v0ID.getProngID(ip);
+    auto gidset = recoData.getSingleDetectorRefs(gid);
+    // get TPC tracks, if any
+    if (gidset[GTrackID::TPC].isSourceSet()) {
+      const auto& tpcTr = recoData.getTPCTrack(gidset[GTrackID::TPC]);
+      prInfo.trackTPC = tpcTr;
+      prInfo.nClTPC = tpcTr.getNClusters();
     }
-    for (int ip = 0; ip < 2; ip++) {
-      auto gid = v0id.getProngID(ip);
-
-      // get TPC tracks, if any
-      tpcTracks[ip] = &dummyTr;
-      nclTPC[ip] = 0;
-      if (gid.includesDet(DetID::TPC)) {
-        const auto& tpcTr = recoData.getTPCTrack(recoData.getTPCContributorGID(gid));
-        tpcTracks[ip] = &tpcTr;
-        nclTPC[ip] = tpcTr.getNClusters();
-      }
-      // get ITS tracks, if any
-      nclITS[ip] = itsPatt[ip] = 0;
-      if (gid.includesDet(DetID::ITS)) {
-        auto gidITS = recoData.getITSContributorGID(gid);
-        if (gidITS.getSource() == GTrackID::ITS) {
-          const auto& itsTr = recoData.getITSTrack(recoData.getITSContributorGID(gid));
-          nclITS[ip] = itsTr.getNClusters();
-          for (int il = 0; il < 7; il++) {
-            if (itsTr.hasHitOnLayer(il)) {
-              itsPatt[ip] |= 0x1 << il;
-            }
+    // get ITS tracks, if any
+    if (gid.includesDet(DetID::ITS)) {
+      auto gidITS = recoData.getITSContributorGID(gid);
+      if (gidset[GTrackID::ITS].isSourceSet()) {
+        const auto& itsTr = recoData.getITSTrack(recoData.getITSContributorGID(gid));
+        prInfo.nClITS = itsTr.getNClusters();
+        for (int il = 0; il < 7; il++) {
+          if (itsTr.hasHitOnLayer(il)) {
+            prInfo.pattITS |= 0x1 << il;
           }
-        } else {
-          const auto& itsTrf = recoData.getITSABRefs()[gidITS];
-          nclITS[ip] = itsTrf.getNClusters();
-          for (int il = 0; il < 7; il++) {
-            if (itsTrf.hasHitOnLayer(il)) {
-              itsPatt[ip] |= 0x1 << il;
-            }
+        }
+      } else {
+        const auto& itsTrf = recoData.getITSABRefs()[gidset[GTrackID::ITSAB]];
+        prInfo.nClITS = itsTrf.getNClusters();
+        for (int il = 0; il < 7; il++) {
+          if (itsTrf.hasHitOnLayer(il)) {
+            prInfo.pattITS |= 0x1 << il;
           }
         }
+        prInfo.pattITS |= 0x1 << 31; // flag AB
+      }
+      if (gidset[GTrackID::ITSTPC].isSourceSet()) {
+        auto mtc = recoData.getTPCITSTrack(gidset[GTrackID::ITSTPC]);
+        prInfo.chi2ITSTPC = mtc.getChi2Match();
       }
     }
-    (*mDBGOut) << "tfinfo"
-               << "orbit=" << recoData.startIR.orbit << "tfID=" << tfID << "\n";
-    (*mDBGOut) << "v0s"
-               << "v0=" << v0 << "v0ID=" << v0id << "tpc0=" << *tpcTracks[0] << "tpc1=" << *tpcTracks[1]
-               << "nclTPC0=" << nclTPC[0] << "nclTPC1=" << nclTPC[1] << "nclITS0=" << nclITS[0] << "nclITS1=" << nclITS[1] << "itsPatt0=" << itsPatt[0] << "itsPatt1=" << itsPatt[1] << "\n";
   }
-  tfID++;
+  return v0ext;
+}
+
+void SVStudySpec::process(o2::globaltracking::RecoContainer& recoData)
+{
+  auto v0IDs = recoData.getV0sIdx();
+  auto nv0 = v0IDs.size();
+  if (nv0 > recoData.getV0s().size()) {
+    mRefit = true;
+  }
+  std::map<int, std::vector<int>> pv2sv;
+  static int tfID = 0;
+  for (int iv = 0; iv < nv0; iv++) {
+    const auto v0id = v0IDs[iv];
+    pv2sv[v0id.getVertexID()].push_back(iv);
+  }
+  std::vector<o2::dataformats::V0Ext> v0extVec;
+  for (auto it : pv2sv) {
+    int pvID = it.first;
+    auto& vv = it.second;
+    if (pvID < 0 || vv.size() == 0) {
+      continue;
+    }
+    v0extVec.clear();
+    for (int iv0 : vv) {
+      auto v0ext = processV0(iv0, recoData);
+      if (v0ext.v0ID.getVertexID() < 0) {
+        continue;
+      }
+      v0extVec.push_back(v0ext);
+    }
+    if (v0extVec.size()) {
+      const auto& pv = recoData.getPrimaryVertex(pvID);
+      (*mDBGOut) << "v0"
+                 << "orbit=" << recoData.startIR.orbit << "tfID=" << tfID
+                 << "v0Ext=" << v0extVec
+                 << "pv=" << pv
+                 << "\n";
+    }
+    tfID++;
+  }
 }
 
 bool SVStudySpec::refitV0(const V0ID& id, o2::dataformats::V0& v0, o2::globaltracking::RecoContainer& recoData)
@@ -280,7 +319,7 @@ DataProcessorSpec getSVStudySpec(GTrackID::mask_t srcTracks, bool useMC)
     AlgorithmSpec{adaptFromTask<SVStudySpec>(dataRequest, ggRequest, srcTracks, useMC)},
     Options{
       {"refit", VariantType::Bool, false, {"refit SVertices"}},
-      {"sel-k0", VariantType::Bool, false, {"select K0s only"}},
+      {"sel-k0", VariantType::Float, -1.f, {"If positive, select K0s with this mass margin"}},
       {"max-eta", VariantType::Float, 1.2f, {"Cut on track eta"}},
     }};
 }
diff --git a/Detectors/GlobalTrackingWorkflow/study/src/TPCTrackStudy.cxx b/Detectors/GlobalTrackingWorkflow/study/src/TPCTrackStudy.cxx
index 3abcfe583f..8ab2696b7e 100644
--- a/Detectors/GlobalTrackingWorkflow/study/src/TPCTrackStudy.cxx
+++ b/Detectors/GlobalTrackingWorkflow/study/src/TPCTrackStudy.cxx
@@ -77,6 +77,7 @@ class TPCTrackStudySpec : public Task
   int mTFEnd = 999999999;
   int mTFCount = -1;
   bool mUseR = false;
+  bool mRepRef = false;
   std::unique_ptr<o2::utils::TreeStreamRedirector> mDBGOut;
   std::unique_ptr<o2::utils::TreeStreamRedirector> mDBGOutCl;
   float mITSROFrameLengthMUS = 0.;
@@ -87,6 +88,7 @@ class TPCTrackStudySpec : public Task
   gsl::span<const o2::tpc::TPCClRefElem> mTPCTrackClusIdx;            ///< input TPC track cluster indices span
   gsl::span<const o2::tpc::TrackTPC> mTPCTracksArray;                 ///< input TPC tracks span
   gsl::span<const unsigned char> mTPCRefitterShMap;                   ///< externally set TPC clusters sharing map
+  gsl::span<const unsigned int> mTPCRefitterOccMap;                   ///< externally set TPC clusters occupancy map
   const o2::tpc::ClusterNativeAccess* mTPCClusterIdxStruct = nullptr; ///< struct holding the TPC cluster indices
   gsl::span<const o2::MCCompLabel> mTPCTrkLabels;                     ///< input TPC Track MC labels
   std::unique_ptr<o2::gpu::GPUO2InterfaceRefit> mTPCRefitter;         ///< TPC refitter used for TPC tracks refit during the reconstruction
@@ -98,6 +100,7 @@ void TPCTrackStudySpec::init(InitContext& ic)
   mXRef = ic.options().get<float>("target-x");
   mNMoves = std::max(2, ic.options().get<int>("n-moves"));
   mUseR = ic.options().get<bool>("use-r-as-x");
+  mRepRef = ic.options().get<bool>("repeat-ini-ref");
   mUseGPUModel = ic.options().get<bool>("use-gpu-fitter");
   mTFStart = ic.options().get<int>("tf-start");
   mTFEnd = ic.options().get<int>("tf-end");
@@ -169,6 +172,7 @@ void TPCTrackStudySpec::process(o2::globaltracking::RecoContainer& recoData)
   mTPCTrackClusIdx = recoData.getTPCTracksClusterRefs();
   mTPCClusterIdxStruct = &recoData.inputsTPCclusters->clusterIndex;
   mTPCRefitterShMap = recoData.clusterShMapTPC;
+  mTPCRefitterOccMap = recoData.occupancyMapTPC;
 
   std::vector<o2::InteractionTimeRecord> intRecs;
   if (mUseMC) { // extract MC tracks
@@ -181,7 +185,7 @@ void TPCTrackStudySpec::process(o2::globaltracking::RecoContainer& recoData)
     mTPCTrkLabels = recoData.getTPCTracksMCLabels();
   }
 
-  mTPCRefitter = std::make_unique<o2::gpu::GPUO2InterfaceRefit>(mTPCClusterIdxStruct, &mTPCCorrMapsLoader, prop->getNominalBz(), mTPCTrackClusIdx.data(), mTPCRefitterShMap.data(), nullptr, o2::base::Propagator::Instance());
+  mTPCRefitter = std::make_unique<o2::gpu::GPUO2InterfaceRefit>(mTPCClusterIdxStruct, &mTPCCorrMapsLoader, prop->getNominalBz(), mTPCTrackClusIdx.data(), 0, mTPCRefitterShMap.data(), mTPCRefitterOccMap.data(), mTPCRefitterOccMap.size(), nullptr, o2::base::Propagator::Instance());
 
   float vdriftTB = mTPCVDriftHelper.getVDriftObject().getVDrift() * o2::tpc::ParameterElectronics::Instance().ZbinWidth; // VDrift expressed in cm/TimeBin
   float tpcTBBias = mTPCVDriftHelper.getVDriftObject().getTimeOffset() / (8 * o2::constants::lhc::LHCBunchSpacingMUS);
@@ -376,7 +380,12 @@ void TPCTrackStudySpec::process(o2::globaltracking::RecoContainer& recoData)
                  << "counter=" << counter
                  << "copy=" << it
                  << "maxCopy=" << mnm
-                 << "movTrackRef=" << trfm
+                 << "movTrackRef=" << trfm;
+      if (mRepRef) {
+        (*mDBGOut) << "tpcMov"
+                   << "iniTrackRef=" << trf << "time=" << tr.getTime0();
+      }
+      (*mDBGOut) << "tpcMov"
                  << "imposedTB=" << tb
                  << "dz=" << dz
                  << "clX=" << clX
@@ -416,6 +425,7 @@ DataProcessorSpec getTPCTrackStudySpec(GTrackID::mask_t srcTracks, GTrackID::mas
     {"tf-start", VariantType::Int, 0, {"1st TF to process"}},
     {"tf-end", VariantType::Int, 999999999, {"last TF to process"}},
     {"use-gpu-fitter", VariantType::Bool, false, {"use GPU track model for refit instead of TrackParCov"}},
+    {"repeat-ini-ref", VariantType::Bool, false, {"store ini-refit param with every moved track"}},
     {"use-r-as-x", VariantType::Bool, false, {"Use radius instead of target sector X"}}};
   auto dataRequest = std::make_shared<DataRequest>();
 
diff --git a/objs/version/O2Version.cxx b/Detectors/GlobalTrackingWorkflow/study/src/TrackInfoExt.cxx
similarity index 60%
rename from objs/version/O2Version.cxx
rename to Detectors/GlobalTrackingWorkflow/study/src/TrackInfoExt.cxx
index ce8e303c0c..f1415e73c1 100644
--- a/objs/version/O2Version.cxx
+++ b/Detectors/GlobalTrackingWorkflow/study/src/TrackInfoExt.cxx
@@ -9,25 +9,6 @@
 // granted to it by virtue of its status as an Intergovernmental Organization
 // or submit itself to any jurisdiction.
 
-#include "O2Version.h"
+// class for extended track info (for debugging)
 
-namespace o2
-{
-
-std::string fullVersion()
-{
-  return "1.2.0";
-}
-
-std::string gitRevision()
-{
-  return "ae9ad5d22";
-}
-
-/// get information about build environment (for example OS and alibuild/alidist release when used)
-std::string getBuildInfo()
-{
-  return "Built by --unavailable-- on OS:Linux-5.15.0-92-generic";
-}
-
-} // namespace o2
+#include "GlobalTrackingStudy/TrackInfoExt.h"
diff --git a/Detectors/GlobalTrackingWorkflow/study/src/TrackingStudy.cxx b/Detectors/GlobalTrackingWorkflow/study/src/TrackingStudy.cxx
index 09e44fe8b3..9a0957c103 100644
--- a/Detectors/GlobalTrackingWorkflow/study/src/TrackingStudy.cxx
+++ b/Detectors/GlobalTrackingWorkflow/study/src/TrackingStudy.cxx
@@ -12,6 +12,7 @@
 #include <vector>
 #include <TStopwatch.h>
 #include "DataFormatsGlobalTracking/RecoContainer.h"
+#include "DataFormatsITSMFT/TrkClusRef.h"
 #include "DataFormatsGlobalTracking/RecoContainerCreateTracksVariadic.h"
 #include "ReconstructionDataFormats/TrackTPCITS.h"
 #include "ReconstructionDataFormats/GlobalTrackID.h"
@@ -30,6 +31,7 @@
 #include "DetectorsCommonDataFormats/DetID.h"
 #include "DetectorsBase/GRPGeomHelper.h"
 #include "GlobalTrackingStudy/TrackingStudy.h"
+#include "GlobalTrackingStudy/TrackInfoExt.h"
 #include "TPCBase/ParameterElectronics.h"
 #include "ReconstructionDataFormats/PrimaryVertex.h"
 #include "ReconstructionDataFormats/PrimaryVertexExt.h"
@@ -80,7 +82,7 @@ class TrackingStudySpec : public Task
   float mMaxVTTimeDiff = 80.; // \mus
   float mTPCDCAYCut = 2.;
   float mTPCDCAZCut = 2.;
-  float mMinX = 6.;
+  float mMinX = 46.;
   float mMaxEta = 0.8;
   float mMinPt = 0.1;
   int mMinTPCClusters = 60;
@@ -144,23 +146,19 @@ void TrackingStudySpec::process(o2::globaltracking::RecoContainer& recoData)
   static int TFCount = 0;
   int nv = vtxRefs.size();
   o2::dataformats::PrimaryVertexExt pveDummy;
-  o2::dataformats::PrimaryVertex vtxDummy(mMeanVtx.getPos(), {}, {}, 0);
-  std::vector<o2::dataformats::PrimaryVertexExt> pveVec(nv - 1);
+  o2::dataformats::PrimaryVertexExt vtxDummy(mMeanVtx.getPos(), {}, {}, 0);
+  std::vector<o2::dataformats::PrimaryVertexExt> pveVec(nv);
+  pveVec.back() = vtxDummy;
   const auto& alpParams = o2::itsmft::DPLAlpideParam<o2::detectors::DetID::ITS>::Instance();
   float tBiasITS = alpParams.roFrameBiasInBC * o2::constants::lhc::LHCBunchSpacingMUS;
-  std::vector<float> dtvec, dzvec;
   const o2::ft0::InteractionTag& ft0Params = o2::ft0::InteractionTag::Instance();
-
+  std::vector<o2::dataformats::TrackInfoExt> trcExtVec;
   for (int iv = 0; iv < nv; iv++) {
     LOGP(debug, "processing PV {} of {}", iv, nv);
     const auto& vtref = vtxRefs[iv];
     if (iv != nv - 1) {
       auto& pve = pveVec[iv];
       static_cast<o2::dataformats::PrimaryVertex&>(pve) = pvvec[iv];
-      dtvec.clear();
-      dzvec.clear();
-      dtvec.reserve(pve.getNContributors());
-      dzvec.reserve(pve.getNContributors());
       float bestTimeDiff = 1000, bestTime = -999;
       int bestFTID = -1;
       if (mTracksSrc[GTrackID::FT0]) {
@@ -180,16 +178,11 @@ void TrackingStudySpec::process(o2::globaltracking::RecoContainer& recoData)
       if (bestFTID >= 0) {
         pve.FT0A = FITInfo[bestFTID].getTrigger().getAmplA();
         pve.FT0C = FITInfo[bestFTID].getTrigger().getAmplC();
-        pve.FT0Time = FITInfo[bestFTID].getInteractionRecord().differenceInBCMUS(recoData.startIR);
+        pve.FT0Time = double(FITInfo[bestFTID].getInteractionRecord().differenceInBCMUS(recoData.startIR)) + FITInfo[bestFTID].getCollisionTimeMean() * 1e-6; // time in \mus
       }
       pve.VtxID = iv;
     }
-    float meanT = 0, meanZ = 0, rmsT = 0, rmsZ = 0;
-    float meanTW = 0, meanZW = 0, rmsTW = 0, rmsZW = 0, WT = 0, WZ = 0;
-    float meanT0 = 0, rmsT0 = 0;
-    float meanTW0 = 0, rmsTW0 = 0, WT0 = 0;
-    int nContAdd = 0, nContAdd0 = 0, ntITS = 0;
-    int nAdjusted = 0;
+    trcExtVec.clear();
     float q2ptITS, q2ptTPC, q2ptITSTPC, q2ptITSTPCTRD;
     for (int is = 0; is < GTrackID::NSources; is++) {
       DetID::mask_t dm = GTrackID::getSourceDetectorsMask(is);
@@ -213,6 +206,7 @@ void TrackingStudySpec::process(o2::globaltracking::RecoContainer& recoData)
         }
         bool hasITS = GTrackID::getSourceDetectorsMask(is)[GTrackID::ITS];
         bool acceptGlo = true;
+        int nclTPC = 0, nclITS = 0, pattITS = 0;
         while (1) {
           // do we cound this track for global multiplicity?
           if (!(acceptGlo = abs(trc.getEta()) < mMaxEta && trc.getPt() > mMinPt)) {
@@ -224,7 +218,7 @@ void TrackingStudySpec::process(o2::globaltracking::RecoContainer& recoData)
           GTrackID tpcTrID;
           if (GTrackID::getSourceDetectorsMask(is)[GTrackID::TPC] && recoData.isTrackSourceLoaded(GTrackID::TPC) && (tpcTrID = recoData.getTPCContributorGID(vid))) {
             auto& tpcTr = recoData.getTPCTrack(tpcTrID);
-            if (!(acceptGlo = tpcTr.getNClusters() >= mMinTPCClusters)) {
+            if (!(acceptGlo = (nclTPC = tpcTr.getNClusters()) >= mMinTPCClusters)) {
               break;
             }
           }
@@ -236,124 +230,58 @@ void TrackingStudySpec::process(o2::globaltracking::RecoContainer& recoData)
           }
           break;
         }
-
         if (!hasITS) {
           continue;
         }
-        float ttime = 0, ttimeE = 0;
-        recoData.getTrackTime(vid, ttime, ttimeE);
-        bool acceptForPV0 = pvCont;
-        if (vid.getSource() == GTrackID::ITS) {
-          ttimeE *= mITSROFrameLengthMUS;
-          ttime += ttimeE + tBiasITS;
-          ttimeE *= 1. / sqrt(3);
-          if (++ntITS > 0) { // do not allow ITS in the MAD
-            acceptForPV0 = false;
-          }
-        } else if (vid.getSource() == GTrackID::ITSTPC) {
-          float bcf = ttime / o2::constants::lhc::LHCBunchSpacingMUS + o2::constants::lhc::LHCMaxBunches;
-          int bcWrtROF = int(bcf - alpParams.roFrameBiasInBC) % alpParams.roFrameLengthInBC;
-          if (bcWrtROF == 0) {
-            float dbc = bcf - (int(bcf / alpParams.roFrameBiasInBC)) * alpParams.roFrameBiasInBC;
-            if (std::abs(dbc) < 1e-6 && (++nAdjusted) > 1) {
-              acceptForPV0 = false; // do not allow more than 1 adjusted track MAD
-            }
-          }
-        } else if (vid.getSource() == GTrackID::TPC) {
-          ttimeE *= o2::constants::lhc::LHCBunchSpacingMUS * 8;
-        }
-        if (pvCont) {
-          float dt = ttime - pveVec[iv].getTimeStamp().getTimeStamp();
-          float tW = 1. / (ttimeE * ttimeE), zW = 1. / trc.getSigmaZ2();
-          dzvec.push_back(dca.getZ());
-          WT += tW;
-          WZ += zW;
-          meanT += dt;
-          meanTW += dt * tW;
-          meanZ += dca.getZ();
-          meanZW += dca.getZ() * zW;
-
-          rmsT += dt * dt;
-          rmsTW += dt * dt * tW;
-          rmsZ += dca.getZ() * dca.getZ();
-          rmsZW += dca.getZ() * dca.getZ() * zW;
-          nContAdd++;
-          if (acceptForPV0) {
-            dtvec.push_back(dt);
-            WT0 += tW;
-            meanT0 += dt;
-            meanTW0 += dt * tW;
-            rmsT0 += dt * dt;
-            rmsTW0 += dt * dt * tW;
-            nContAdd0++;
-          }
-          LOGP(debug, "dt={} dz={}, tW={}, zW={} t={} tE={} {}", dt, dca.getZ(), tW, zW, ttime, ttimeE, vid.asString());
-        }
         if (acceptGlo) {
-          q2ptITS = q2ptTPC = q2ptITSTPC = q2ptITSTPCTRD = 0.;
+          auto& trcExt = trcExtVec.emplace_back();
+          recoData.getTrackTime(vid, trcExt.ttime, trcExt.ttimeE);
+          trcExt.track = trc;
+          trcExt.dca = dca;
+          trcExt.gid = vid;
+          trcExt.xmin = xmin;
           auto gidRefs = recoData.getSingleDetectorRefs(vid);
           if (gidRefs[GTrackID::ITS].isIndexSet()) {
-            q2ptITS = recoData.getTrackParam(gidRefs[GTrackID::ITS]).getQ2Pt();
+            const auto& itsTr = recoData.getITSTrack(gidRefs[GTrackID::ITS]);
+            trcExt.q2ptITS = itsTr.getQ2Pt();
+            trcExt.nClITS = itsTr.getNClusters();
+            for (int il = 0; il < 7; il++) {
+              if (itsTr.hasHitOnLayer(il)) {
+                trcExt.pattITS |= 0x1 << il;
+              }
+            }
+          } else if (gidRefs[GTrackID::ITSAB].isIndexSet()) {
+            const auto& itsTrf = recoData.getITSABRefs()[gidRefs[GTrackID::ITSAB]];
+            trcExt.nClITS = itsTrf.getNClusters();
+            for (int il = 0; il < 7; il++) {
+              if (itsTrf.hasHitOnLayer(il)) {
+                trcExt.pattITS |= 0x1 << il;
+              }
+            }
           }
           if (gidRefs[GTrackID::TPC].isIndexSet()) {
-            q2ptTPC = recoData.getTrackParam(gidRefs[GTrackID::TPC]).getQ2Pt();
+            trcExt.q2ptTPC = recoData.getTrackParam(gidRefs[GTrackID::TPC]).getQ2Pt();
+            trcExt.nClTPC = nclTPC;
           }
           if (gidRefs[GTrackID::ITSTPC].isIndexSet()) {
-            q2ptITSTPC = recoData.getTrackParam(gidRefs[GTrackID::ITSTPC]).getQ2Pt();
+            const auto& trTPCITS = recoData.getTPCITSTrack(gidRefs[GTrackID::ITSTPC]);
+            trcExt.q2ptITSTPC = trTPCITS.getQ2Pt();
+            trcExt.chi2ITSTPC = trTPCITS.getChi2Match();
           }
           if (gidRefs[GTrackID::TRD].isIndexSet()) {
-            q2ptITSTPCTRD = recoData.getTrackParam(gidRefs[GTrackID::TRD]).getQ2Pt();
+            trcExt.q2ptITSTPCTRD = recoData.getTrackParam(gidRefs[GTrackID::TRD]).getQ2Pt();
+          }
+          if (gidRefs[GTrackID::TOF].isIndexSet()) {
+            trcExt.infoTOF = recoData.getTOFMatch(vid);
           }
-
-          (*mDBGOut) << "dca"
-                     << "tfID=" << TFCount << "ttime=" << ttime << "ttimeE=" << ttimeE
-                     << "gid=" << vid << "pvid=" << (iv == nv - 1 ? -1 : iv) << "pv=" << (iv == nv - 1 ? vtxDummy : pvvec[iv])
-                     << "trc=" << trc << "pvCont=" << pvCont << "ambig=" << ambig << "dca=" << dca << "xmin=" << xmin
-                     << "q2ptITS=" << q2ptITS << "q2ptTPC=" << q2ptTPC << "q2ptITSTPC=" << q2ptITSTPC << "q2ptITSTPCTRD=" << q2ptITSTPCTRD
-                     << "\n";
         }
       }
     }
-
-    if (iv != nv - 1) {
-      auto& pve = pveVec[iv];
-      if (nContAdd) {
-        rmsT /= nContAdd;
-        rmsZ /= nContAdd;
-        meanT /= nContAdd;
-        meanZ /= nContAdd;
-        pve.rmsT = (rmsT - meanT * meanT);
-        pve.rmsT = pve.rmsT > 0 ? std::sqrt(pve.rmsT) : 0;
-        pve.rmsZ = rmsZ - meanZ * meanZ;
-        pve.rmsZ = pve.rmsZ > 0 ? std::sqrt(pve.rmsZ) : 0;
-      }
-      if (nContAdd0) {
-        rmsT0 /= nContAdd0;
-        meanT0 /= nContAdd0;
-        pve.rmsT0 = (rmsT0 - meanT0 * meanT0);
-        pve.rmsT0 = pve.rmsT0 > 0 ? std::sqrt(pve.rmsT0) : 0;
-      }
-      if (WT0 > 0) {
-        rmsTW0 /= WT0;
-        meanTW0 /= WT0;
-        pve.rmsTW0 = (rmsTW0 - meanTW0 * meanTW0);
-        pve.rmsTW0 = pve.rmsTW0 > 0 ? std::sqrt(pve.rmsTW0) : 0;
-      }
-      //
-      if (WT > 0 && WZ > 0) {
-        rmsTW /= WT;
-        meanTW /= WT;
-        pve.rmsTW = (rmsTW - meanTW * meanTW);
-        pve.rmsTW = pve.rmsTW > 0 ? std::sqrt(pve.rmsTW) : 0;
-        rmsZW /= WZ;
-        meanZW /= WZ;
-        pve.rmsZW = rmsZW - meanZW * meanZW;
-        pve.rmsZW = pve.rmsZ > 0 ? std::sqrt(pve.rmsZ) : 0;
-      }
-      pve.tMAD = o2::math_utils::MAD2Sigma(dtvec.size(), dtvec.data());
-      pve.zMAD = o2::math_utils::MAD2Sigma(dzvec.size(), dzvec.data());
-    }
+    (*mDBGOut) << "trpv"
+               << "orbit=" << recoData.startIR.orbit << "tfID=" << TFCount
+               << "pve=" << pveVec[iv] << "trc=" << trcExtVec << "\n";
   }
+
   int nvtot = mMaxNeighbours < 0 ? -1 : (int)pveVec.size();
 
   auto insSlot = [maxSlots = mMaxNeighbours](std::vector<float>& vc, float v, int slot, std::vector<int>& vid, int id) {
@@ -499,7 +427,7 @@ DataProcessorSpec getTrackingStudySpec(GTrackID::mask_t srcTracks, GTrackID::mas
       {"max-tpc-dcaz", VariantType::Float, 2.f, {"Cut on TPC dcaZ"}},
       {"max-eta", VariantType::Float, 0.8f, {"Cut on track eta"}},
       {"min-pt", VariantType::Float, 0.1f, {"Cut on track pT"}},
-      {"min-x-prop", VariantType::Float, 6.f, {"track should be propagated to this X at least"}},
+      {"min-x-prop", VariantType::Float, 46.f, {"track should be propagated to this X at least"}},
     }};
 }
 
diff --git a/Detectors/GlobalTrackingWorkflow/study/src/V0Ext.cxx b/Detectors/GlobalTrackingWorkflow/study/src/V0Ext.cxx
new file mode 100644
index 0000000000..0ae0fd3bda
--- /dev/null
+++ b/Detectors/GlobalTrackingWorkflow/study/src/V0Ext.cxx
@@ -0,0 +1,14 @@
+// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
+// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
+// All rights not expressly granted are reserved.
+//
+// This software is distributed under the terms of the GNU General Public
+// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
+//
+// In applying this license CERN does not waive the privileges and immunities
+// granted to it by virtue of its status as an Intergovernmental Organization
+// or submit itself to any jurisdiction.
+
+// class for extended V0 info (for debugging)
+
+#include "GlobalTrackingStudy/V0Ext.h"
diff --git a/Detectors/HMPID/reconstruction/include/HMPIDReconstruction/Clusterer.h b/Detectors/HMPID/reconstruction/include/HMPIDReconstruction/Clusterer.h
index fb2fabfd9c..002c54c717 100644
--- a/Detectors/HMPID/reconstruction/include/HMPIDReconstruction/Clusterer.h
+++ b/Detectors/HMPID/reconstruction/include/HMPIDReconstruction/Clusterer.h
@@ -11,6 +11,7 @@
 
 /// \file Clusterer.h
 /// \brief Definition of the HMPID cluster finder
+
 #ifndef ALICEO2_HMPID_CLUSTERER_H
 #define ALICEO2_HMPID_CLUSTERER_H
 
@@ -26,17 +27,22 @@
 
 namespace o2
 {
-
 namespace hmpid
 {
 class Clusterer
 {
-  using MCLabelContainer = o2::dataformats::MCTruthContainer<o2::MCCompLabel>;
+
   using Cluster = o2::hmpid::Cluster;
   using Digit = o2::hmpid::Digit;
 
  public:
-  Clusterer() = default;
+  using MCLabelContainer = o2::dataformats::MCTruthContainer<o2::MCCompLabel>;
+
+  Clusterer(bool useMC)
+  {
+    mUseMC = useMC;
+  }
+
   ~Clusterer() = default;
 
   Clusterer(const Clusterer&) = delete;
@@ -44,19 +50,33 @@ class Clusterer
 
   // void process(std::vector<Digit> const& digits, std::vector<o2::hmpid::Cluster>& clusters, MCLabelContainer const* digitMCTruth);
 
-  // void setMCTruthContainer(o2::dataformats::MCTruthContainer<o2::MCCompLabel>* truth) { mClsLabels = truth; }
+  //
+  void setMCTruthContainer(o2::dataformats::MCTruthContainer<o2::MCCompLabel>* truth) { mClsLabels = truth; }
+
+  // ef : added; set labels in mClsLabels
+  void addCluLabelsFromDig(const Cluster& cluster, const std::vector<int>& globalDigitIndices, MCLabelContainer const* digitMCTruth, MCLabelContainer* mClsLabels, int cluSize);
+
+  void FormCluMC(Cluster& pClu, int pDig, gsl::span<const o2::hmpid::Digit> digs, TMatrixF& pDigMap, std::vector<int>& indicesUnresolved);
 
-  static void Dig2Clu(gsl::span<const o2::hmpid::Digit> digs, std::vector<o2::hmpid::Cluster>& clus, float* pUserCut, bool isUnfold = kTRUE); // digits->clusters
-  static void FormClu(Cluster& pClu, int pDig, gsl::span<const o2::hmpid::Digit> digs, TMatrixF& pDigMap);                                    // cluster formation recursive algorithm
-  static int UseDig(int padX, int padY, TMatrixF& pDigMap);                                                                                   // use this pad's digit to form a cluster
-  inline bool IsDigSurvive(Digit* pDig) const;                                                                                                // check for sigma cut
+  void Dig2Clu(gsl::span<const o2::hmpid::Digit> digs, std::vector<o2::hmpid::Cluster>& clus, float* pUserCut, MCLabelContainer const* digitMCTruth, bool isUnfold = kTRUE); // digits->clusters
+  static void FormClu(Cluster& pClu, int pDig, gsl::span<const o2::hmpid::Digit> digs, TMatrixF& pDigMap);                                                                   // cluster formation recursive algorithm
+  static int UseDig(int padX, int padY, TMatrixF& pDigMap);                                                                                                                  // use this pad's digit to form a cluster
+  inline bool IsDigSurvive(Digit* pDig) const;
 
  private:
+  // ef : taken from  Cluster::solve
+  // > TODO : make it global Hmpid base?
+  static constexpr int kMaxLocMax = 6; // max allowed number of loc max for fitting
+
+  int startIndexDigMC = 0; // ef : TODO find a more elegant way
   // void processChamber(std::vector<Cluster>& clusters, MCLabelContainer const* digitMCTruth);
   // void fetchMCLabels(const Digit* dig, std::array<Label, Cluster::maxLabels>& labels, int& nfilled) const;
 
   o2::dataformats::MCTruthContainer<o2::MCCompLabel>* mClsLabels = nullptr; // Cluster MC labels
 
+  // is set in initialization
+  bool mUseMC = false;
+
   // Digit* mContributingDigit[6];    //! array of digits contributing to the cluster; this will not be stored, it is temporary to build the final cluster
   // int mNumberOfContributingDigits; //! number of digits contributing to the cluster; this will not be stored, it is temporary to build the final cluster
   // std::vector<o2::hmpid::Digit*> mDigs;
diff --git a/Detectors/HMPID/reconstruction/src/Clusterer.cxx b/Detectors/HMPID/reconstruction/src/Clusterer.cxx
index d2cbcf770f..83c0b66459 100644
--- a/Detectors/HMPID/reconstruction/src/Clusterer.cxx
+++ b/Detectors/HMPID/reconstruction/src/Clusterer.cxx
@@ -1,4 +1,4 @@
-// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
+// Copyright 2020-2022 CERN and copyright holders of ALICE O2.
 // See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
 // All rights not expressly granted are reserved.
 //
@@ -10,7 +10,9 @@
 // or submit itself to any jurisdiction.
 
 /// \file Clusterer.cxx
+
 /// \brief Implementation of the HMPID cluster finder
+
 #include <algorithm>
 #include "FairLogger.h" // for LOG
 #include "Framework/Logger.h"
@@ -29,9 +31,17 @@ using namespace o2::hmpid;
   // mDigs = {nullptr};
   // mClus = {nullptr};
 }*/
+
 //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-void Clusterer::Dig2Clu(gsl::span<const o2::hmpid::Digit> digs, std::vector<o2::hmpid::Cluster>& clus, float* pUserCut, bool isUnfold)
+/*  virtual void process(gsl::span<o2::tpc::Digit const> const& digits,
+   o2::dataformats::ConstMCLabelContainerView const& mcDigitTruth) = 0;
+ */
+//,
+// void Clusterer::Dig2Clu(gsl::span<const o2::hmpid::Digit> digs, std::vector<o2::hmpid::Cluster>& clus, float* pUserCut, bool isUnfold, o2::dataformats::ConstMCLabelContainerView const& mcDigitTruth, )
+
+void Clusterer::Dig2Clu(gsl::span<const o2::hmpid::Digit> digs, std::vector<o2::hmpid::Cluster>& clus, float* pUserCut, MCLabelContainer const* digitMCTruth, bool isUnfold)
 {
+
   // Finds all clusters for a given digits list provided not empty. Currently digits list is a list of all digits for a single chamber.
   // Puts all found clusters in separate lists, one per clusters.
   // Arguments: pDigAll     - list of digits for all chambers
@@ -39,88 +49,328 @@ void Clusterer::Dig2Clu(gsl::span<const o2::hmpid::Digit> digs, std::vector<o2::
   //            isTryUnfold - flag to choose between CoG and Mathieson fitting
   //  Returns: none
 
+  const int numCluStart = clus.size();
+  LOGP(info, "\n\n ============================== called Dig2Clu\n looping over digits");
+  LOGP(info, " clus Size {}", clus.size());
+  LOGP(info, " digs Size {}", digs.size());
+  if (digitMCTruth == nullptr) {
+    LOGP(info, "digitMCTruth was nullptr!");
+  }
+
   struct Pad {
     int x, y, m;
   };
 
   TMatrixF padMap(Param::kMinPx, Param::kMaxPcx, Param::kMinPy, Param::kMaxPcy); // pads map for single chamber 0..159 x 0..143
-
   int pUsedDig = -1;
   int padChX = 0, padChY = 0, module = 0;
   std::vector<Pad> vPad;
   std::vector<const Digit*> digVec;
-  for (int iCh = Param::kMinCh; iCh <= Param::kMaxCh; iCh++) { // chambers loop
-    padMap = (Float_t)-1;                                      // reset map to -1 (means no digit for this pad)
+  for (int iCh = Param::kMinCh; iCh <= Param::kMaxCh; iCh++)
+
+  { // chambers loop
+
+    padMap = (Float_t)-1; // reset map to -1 (means no digit for this pad)
+
     for (size_t iDig = 0; iDig < digs.size(); iDig++) {
       o2::hmpid::Digit::pad2Absolute(digs[iDig].getPadID(), &module, &padChX, &padChY);
       vPad.push_back({padChX, padChY, module});
+
       if (module == iCh) {
         padMap(padChX, padChY) = iDig; // fill the map for the given chamber, (padx,pady) cell takes digit index
       }
+
     } // digits loop for current chamber
 
+    LOGP(info, "\n\n ============================== \n looping over digits ============================================================\n ==============================\n");
     for (size_t iDig = 0; iDig < digs.size(); iDig++) { // digits loop for current chamber
       // o2::hmpid::Digit::pad2Absolute(digs[iDig].getPadID(), &module, &padChX, &padChY);
+      // LOGP(info, "\n\n ================================\n New iDig : {} \n================================\n\n", iDig);
+
       if (vPad.at(iDig).m != iCh || (pUsedDig = UseDig(vPad.at(iDig).x, vPad.at(iDig).y, padMap)) == -1) { // this digit is from other module or already taken in FormClu(), go after next digit
         continue;
       }
+
       digVec.clear();
       Cluster clu;
       clu.setDigits(&digVec);
       clu.setCh(iCh);
-      FormClu(clu, pUsedDig, digs, padMap); // form cluster starting from this digit by recursion
-      clu.solve(&clus, pUserCut, isUnfold); // solve this cluster and add all unfolded clusters to provided list
-    }                                       // digits loop for current chamber
+
+      std::vector<int> digitIndicesRawCluster;
+      // ef : added, for MC > digit indices of raw cluster (before solving)
+      if (digitMCTruth != nullptr) {
+        // pass indices by reference, keep track of indices of digits used in cluster
+        FormCluMC(clu, pUsedDig, digs, padMap, digitIndicesRawCluster); // form cluster starting from this digit by recursion
+      } else {
+        FormClu(clu, pUsedDig, digs, padMap); // form cluster starting from this digit by recursion
+      }
+
+      // recursively add all adjacent digits to the cluster
+
+      int formedClusters = -1;
+      const int cluSizeIn = clus.size();
+
+      if (digitMCTruth == nullptr) {
+        LOGP(info, " Cluster formed Check not using MCTruth"); // ef : remov
+        formedClusters = clu.solve(&clus, pUserCut, isUnfold); // solve this cluster and add all unfolded clusters to provided list
+      }
+
+      // for setting cluster MC-labels
+      if (digitMCTruth != nullptr) {
+        LOGP(info, " Cluster formed Check mcTruth"); // ef remove
+        std::map<int, std::vector<int>> resolvedDigIndicesMap;
+
+        // solving convoluted clusters, and getting local indices
+        //  each entry in the resolvedDigIndicesMap is for each resolved cluster a vector
+        // containing the indices of the their resolved digits (the digits forming the resolved cluster)
+
+        formedClusters = clu.solveMC(&clus, pUserCut, isUnfold, resolvedDigIndicesMap); // solve this cluster and add all unfolded clusters to provided list
+
+        const int startIndex = cluSizeIn;
+
+        const int cluSizeOut = clus.size();
+        const int endIndex = cluSizeOut;
+        LOGP(info, "clu solve ok : cluSizeIn {} -> cluSizeOut {} formedClusters {}", cluSizeIn, cluSizeOut, formedClusters); // ef : remov
+        LOGP(info, "Looping over resolved clusters");
+        LOGP(info, "startIndex {} -> endIndex {} formedClusters {}", startIndex, endIndex, formedClusters); // ef : remov
+        // if (formedClusters > 1 && formedClusters < 6) {
+
+        // we loop over the number of formed clusters(formedClusters)
+        // and set the MC labels per resoolved clusteers
+        if (formedClusters > 1 && formedClusters < kMaxLocMax) {
+
+          // use resolvedDigIndicesMap
+          // for(int i = 0; i < resolvedClusters; i++) {
+          //  cosnt auto& cluster = clus[i+cluSizeIn];
+          //  vector<int> resolvedDigIndices = resolvedDigIndicesMap[i];
+          //
+          // map from "local" to global
+
+          LOGP(info, "\n\n\n=======================\n======================="); // ef : remov
+
+          // loop over all the resolved clusters
+          // resolvedDigIndices is the (int, vector) combination
+          //  resolvedDigIndices.first is the index of the resolved cluster
+          // resolvedDigIndices.second is the vector of the indices of their resolved digits
+          for (const auto& resolvedDigIndices : resolvedDigIndicesMap) {
+            // 0.1.2....
+
+            // the integer in the map;
+            // gives the index of the current resolved index out of the formed clusters (formedClusters)
+            int indSolvedClu = resolvedDigIndices.first;
+
+            // get cluster
+            LOGP(info, "\n=======================\n======================="); // ef : remov
+
+            LOGP(info, "Resolved cluster {} of {}", indSolvedClu + 1, formedClusters); // ef : remov
+
+            // current entry is the end of current cluster-vector
+            // and adding the index of the resolved cluster out of the numResolvedClusters
+            int currentEntry = startIndex + indSolvedClu;
+            LOGP(info, "currentEntry {} startIndex {} ", currentEntry, startIndex); // ef : remov
+
+            // ef > todo : check on size ?
+            const auto& cluster = clus[currentEntry];
+
+            std::vector<int> resolvedDigIndsVec = resolvedDigIndices.second;
+            // get all the digits, and all the MC-labels from them
+
+            LOGP(info, "clu {}/{}", resolvedDigIndices.first, clus.size()); // ef : remov
+            // iterate over the local to map to global and fidn selected
+
+            // store the global indicwes of the resolved digits for the current resolved cluster
+            std::vector<int> globalIndResolvedDigits;
+            for (const auto& index : resolvedDigIndsVec) {
+              globalIndResolvedDigits.push_back(digitIndicesRawCluster[index]);
+            }
+
+            // ef: add catch if globalIndResolvedDigits.size == 0 ? and add empty label?
+            if (globalIndResolvedDigits.size() == 0) {
+              LOGP(warn, " globalIndResolvedDigits had no entries!");
+            }
+
+            if (mClsLabels) {
+              const int nEntrisIn = mClsLabels->getIndexedSize();
+              addCluLabelsFromDig(cluster, globalIndResolvedDigits, digitMCTruth, mClsLabels, clus.size());
+              const int nEntriesOut = mClsLabels->getIndexedSize();
+              LOGP(info, "LOOP number of clusters {} | ndigsResolved {}", clus.size(), cluster.size());       // ef > remove
+              LOGP(info, "LOOP IN {} OUT {} ; number of objs in cluster-headArray ", nEntrisIn, nEntriesOut); // ef > remove
+            }
+          }
+          // ef > remove if statment
+          if (mClsLabels) {
+            const int nEntriesOut = static_cast<int>(mClsLabels->getIndexedSize());
+            int diff = nEntriesOut - clus.size();
+
+            if (diff != 0) {
+              Printf("ulik diff %d", diff);
+
+              if (nEntriesOut != clu.size()) {
+                LOGP(info, "formedClusters = {} unequal sizes of labels ({}) and clusters ({}) diff : {}", formedClusters, nEntriesOut, clus.size(), diff);
+                Printf("diff %d", diff);
+              }
+
+              if (nEntriesOut == clu.size()) {
+                LOGP(info, "formedClusters = {} equal sizes of labels ({}) and clusters ({}) diff : {}", formedClusters, nEntriesOut, clus.size(), diff);
+              }
+            }
+
+            else {
+              Printf("diff ok %d", diff);
+            }
+          }
+        } // end if (formedClusters > 1 && formedClusters < 6) {
+
+        // in this case, only 1 cluster is formed
+        // because kMaxLocMax was exceeded
+        // in this case we use the raw cluster
+        else if (formedClusters == 1 || formedClusters >= kMaxLocMax) { // 6 is max allowed value kMaxLocMax
+          LOGP(info, "\n\n\n=======================\n =======================");
+          //  const auto& cluster = clus[i+cluSizeIn];
+          // the "unresolved" are here also the resolved,
+          // since we only had 1 cluster to begin with in raw cluster
+          // we can directly use digitIndicesRawCluster as the global
+          const auto& cluster = clus[startIndex];
+          /*for (const auto& index : digitIndicesRawCluster) {
+              const auto& dig = digs[index];
+              // index is used for mcDigitsTruth->getLabels(index)
+              gsl::span<const o2::MCCompLabel> mcArray = digitMCTruth->getLabels(index);
+          }*/
+          const int nEntrisIn = mClsLabels->getIndexedSize();
+          addCluLabelsFromDig(cluster, digitIndicesRawCluster, digitMCTruth, mClsLabels, clus.size());
+
+          LOGP(info, "number of clusters {} | ndigsResolved {}", clus.size(), cluster.size()); // ef : remove
+
+          // ef : remove  remove if stmt
+          if (mClsLabels) {
+            const int nEntriesOut = static_cast<int>(mClsLabels->getIndexedSize());
+            LOGP(info, "IN {} OUT {} ; number of objs in cluster-headArray ", nEntrisIn, nEntriesOut);
+
+            int diff = nEntriesOut - clus.size();
+
+            // ef : remove
+            if (diff != 0) {
+              Printf("ulik diff %d", diff);
+              if (nEntriesOut != clu.size()) {
+                LOGP(info, "formedClusters = {} unequal sizes of labels ({}) and clusters ({}) diff : {}", formedClusters, nEntriesOut, clus.size(), diff);
+                Printf("diff %d", diff);
+              }
+
+              if (nEntriesOut == clu.size()) {
+                LOGP(info, "formedClusters = {} equal sizes of labels ({}) and clusters ({}) diff : {}", formedClusters, nEntriesOut, clus.size(), diff);
+              }
+            } else {
+              Printf("diff ok %d", diff);
+            } // ef : remove
+          }   // ef : remove if stmt
+
+        } // end else if (formedClusters == 1 || formedClusters >= 6 ) {
+
+      } // if digitsMcTruth
+
+    } // digits loop for current chamber
     vPad.clear();
   } // chambers loop
+
+  // const int numCluStart = clus.size();
+
+  LOGP(info, "\n\n ============================== called Dig2Clu\n looping over digits"); // ef : remove
+
+  LOGP(info, " new Clusters  {}", clus.size() - numCluStart); // ef : remove
+
+  LOGP(info, " digs Size {}", digs.size()); // ef : remove
+  startIndexDigMC += digs.size();
+
+  LOGP(info, " starting next MC digit reading from {}", startIndexDigMC); // ef : remove
+
   return;
+
 } // Dig2Clu()
+
 //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-/*void Clusterer::Dig2Clu(gsl::span<const o2::hmpid::Digit> digs, std::vector<o2::hmpid::Cluster>& clus, float* pUserCut, bool isUnfold)
+void Clusterer::addCluLabelsFromDig(const Cluster& cluster, const std::vector<int>& globalDigitIndices, MCLabelContainer const* digitMCTruth, MCLabelContainer* mClsLabels, int cluSize)
 {
-  // Finds all clusters for a given digits list provided not empty. Currently digits list is a list of all digits for a single chamber.
-  // Puts all found clusters in separate lists, one per clusters.
-  // Arguments: pDigAll     - list of digits for all chambers
-  //            pCluAll     - list of clusters for all chambers
-  //            isTryUnfold - flag to choose between CoG and Mathieson fitting
-  //  Returns: none
 
-  TMatrixF padMap(Param::kMinPx, Param::kMaxPcx, Param::kMinPy, Param::kMaxPcy); // pads map for single chamber 0..159 x 0..143
+  // LOGP(info, "Based on pos : pdg {} mother {} tid {}", cluster.getPDG(),
+  // cluster.getMotherId(), cluster.getTrackId());
 
-  int pUsedDig = -1;
-  int padChX = 0, padChY = 0, module = 0;
+  int lbl = mClsLabels->getIndexedSize(); // this should correspond to the current number of clusters
 
-  for (int iCh = Param::kMinCh; iCh <= Param::kMaxCh; iCh++) { // chambers loop
-    padMap = (Float_t)-1;                                      // reset map to -1 (means no digit for this pad)
-    for (size_t iDig = 0; iDig < digs.size(); iDig++) {
-      o2::hmpid::Digit::pad2Absolute(digs[iDig].getPadID(), &module, &padChX, &padChY);
-      if (module == iCh) {
-        padMap(padChX, padChY) = iDig; // fill the map for the given chamber, (padx,pady) cell takes digit index
-      }
-    } // digits loop for current chamber
+  // LOGP(info, "lbl = {} indices_size {} : cluster.size {}", lbl, indices.size(), cluster.size());
+  // LOGP(info, "number of clusters {}", clus.size());
+  // LOGP(info, "number of objs in cluster-headArray : {}", mClsLabels->getIndexedSize());
+  // LOGP(info, "number of objs in cluster-TruthArray : {}", mClsLabels->getNElements());
 
-    for (size_t iDig = 0; iDig < digs.size(); iDig++) { // digits loop for current chamber
-      o2::hmpid::Digit::pad2Absolute(digs[iDig].getPadID(), &module, &padChX, &padChY);
-      if (module != iCh || (pUsedDig = UseDig(padChX, padChY, padMap)) == -1) { // this digit is from other module or already taken in FormClu(), go after next digit
-        continue;
-      }
-      Cluster clu;
-      clu.setCh(iCh);
-      FormClu(clu, pUsedDig, digs, padMap); // form cluster starting from this digit by recursion
-      clu.solve(&clus, pUserCut, isUnfold); // solve this cluster and add all unfolded clusters to provided list
-    }                                       // digits loop for current chamber
-  }                                         // chambers loop
-  return;
-} // Dig2Clu()
-*/
+  // loop over resolvedIndexes array;
+  int numDigitsCount = 0;
+  for (int i = 0; i < globalDigitIndices.size(); i++) {
+    const int& indexOfDigGlobal = globalDigitIndices[i];
+
+    // LOGP(info, "digit numGlobal+startIndexDigMC {} : x {} y {}", indexOfDigGlobal+startIndexDigMC, digOfClu.getX(), digOfClu.getY());
+    /*if (iDig < 0 || iDig >= digs.size()) {
+      LOGP(info, "iDig out of bounds");
+      break;
+    }*/
+
+    numDigitsCount++;
+    // const auto& digOfClu = &digs[iDig];
+
+    if (digitMCTruth == nullptr) {
+      continue;
+    }
+
+    int digitLabel = startIndexDigMC + indexOfDigGlobal;
+    // all MC-hits from the specific digit
+    gsl::span<const o2::MCCompLabel> mcArray = digitMCTruth->getLabels(digitLabel);
+
+    // ef : remove later
+    // LOGP(info, "contributing digit = ({}/{}), digitLabel  = {} || pdg of digit {}", numDigitsCount, cluster.size(), digitLabel, pdgOfDig);
+
+    // LOGP(info, "mcArray size {}", mcArray.size());
+    // LOGP(info, "======= Looping Labels of dig ===== ");
+    for (int j = 0; j < static_cast<int>(mcArray.size()); j++) {
+
+      const auto& currentIndex = digitMCTruth->getMCTruthHeader(digitLabel).index + j;
+      auto label = digitMCTruth->getElement(currentIndex);
+
+      // LOGP(info, "digitLabel {}, digitMCTruth->getMCTruthHeader(digitLabel).index {}, j {}", digitLabel, digitMCTruth->getMCTruthHeader(digitLabel).index, j);
+      // LOGP(info, "digitMCTruth->getElement({}/{})", currentIndex, digitMCTruth->getIndexedSize());
+
+      // same as digits having multiple hits
+      // clsuters have multiple digits
+      // we fill MC-Complabel label at index lbl for headArray
+      // this is the hit for a digit in the cluster
+
+      mClsLabels->addElement(lbl, label);
+
+    } // end for mcArray
+  }   // end for iDig : resolvedDigIndices
+  /*
+  if (mClsLabels) {
+    LOGP(info, "number of objs in cluster-headArray : {}", mClsLabels->getIndexedSize());
+    LOGP(info, "number of objs in cluster-TruthArray : {}", mClsLabels->getNElements());
+
+  } */
+  // end if mClsLabels
+
+} // end addCluLabelsFromDig
 //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
 void Clusterer::FormClu(Cluster& pClu, int pDig, gsl::span<const o2::hmpid::Digit> digs, TMatrixF& pDigMap)
+
 {
+
   // Forms the initial cluster as a combination of all adjascent digits. Starts from the given digit then calls itself recursevly  for all neighbours.
   // Arguments: pClu - pointer to cluster being formed
   //   Returns: none
+  //   void digAdd(const o2::hmpid::Digit* pDig);                                         // add new digit to the cluster
 
   pClu.digAdd(&digs[pDig]); // take this digit in cluster
+
+  // ef : add index of digit to cluster
+
+  // pClu.setUnresolvedIndex(pDig);
+
   int cnt = 0;
   int cx[4];
   int cy[4];
@@ -128,7 +378,6 @@ void Clusterer::FormClu(Cluster& pClu, int pDig, gsl::span<const o2::hmpid::Digi
   int padChY = 0;
   int module = 0;
   o2::hmpid::Digit::pad2Absolute(digs[pDig].getPadID(), &module, &padChX, &padChY);
-
   if (padChX > Param::kMinPx) {
     cx[cnt] = padChX - 1;
     cy[cnt] = padChY;
@@ -155,11 +404,68 @@ void Clusterer::FormClu(Cluster& pClu, int pDig, gsl::span<const o2::hmpid::Digi
     if (pDig != -1) {
       FormClu(pClu, pDig, digs, pDigMap);
     } // check if this neighbour pad fired and mark it as taken
-  }   // neighbours loop
+
+  } // neighbours loop
+
 } // FormClu()
 
 //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
+// ef : added function>
+// for MC labeling, the propagation of MC labels of the digits forming the cluster is done here
+void Clusterer::FormCluMC(Cluster& pClu, int pDig, gsl::span<const o2::hmpid::Digit> digs, TMatrixF& pDigMap, std::vector<int>& digitIndicesRawCluster)
+{
+  // Forms the initial cluster as a combination of all adjascent digits. Starts from the given digit then calls itself recursevly  for all neighbours.
+  // Arguments: pClu - pointer to cluster being formed
+  //   Returns: none
+  //   void digAdd(const o2::hmpid::Digit* pDig);                                         // add new digit to the cluster
+  pClu.digAdd(&digs[pDig]); // take this digit in cluster
+  digitIndicesRawCluster.push_back(pDig);
+  // ef : add index of digit to cluster
+
+  // pClu.setUnresolvedIndex(pDig);
+
+  int cnt = 0;
+  int cx[4];
+  int cy[4];
+  int padChX = 0;
+  int padChY = 0;
+  int module = 0;
+  o2::hmpid::Digit::pad2Absolute(digs[pDig].getPadID(), &module, &padChX, &padChY);
+  if (padChX > Param::kMinPx) {
+    cx[cnt] = padChX - 1;
+    cy[cnt] = padChY;
+    cnt++;
+  } // left
+  if (padChX < Param::kMaxPcx) {
+    cx[cnt] = padChX + 1;
+    cy[cnt] = padChY;
+    cnt++;
+  } // right
+  if (padChY > Param::kMinPy) {
+    cx[cnt] = padChX;
+    cy[cnt] = padChY - 1;
+    cnt++;
+  } // down
+  if (padChY < Param::kMaxPcy) {
+    cx[cnt] = padChX;
+    cy[cnt] = padChY + 1;
+    cnt++;
+  }                               // up
+  for (int i = 0; i < cnt; i++) { // neighbours loop
+    pDig = UseDig(cx[i], cy[i], pDigMap);
+    if (pDig != -1) {
+      FormCluMC(pClu, pDig, digs, pDigMap, digitIndicesRawCluster);
+    } // check if this neighbour pad fired and mark it as taken
+  }   // neighbours loop
+} // FormCluMC()
+
+//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
 int Clusterer::UseDig(int padX, int padY, TMatrixF& pPadMap)
+
 {
   // Digit map contains a matrix if digit numbers.
   // Main operation in forming initial cluster is done here. Requested digit pointer is returned and this digit marked as taken.
@@ -167,50 +473,34 @@ int Clusterer::UseDig(int padX, int padY, TMatrixF& pPadMap)
   //            pDigLst   - list of digits for one sector
   //            pDigMap   - map of those digits
   //   Returns: index to digit if not yet used or -1 if used
+
   int iDig = (int)pPadMap(padX, padY);
   pPadMap(padX, padY) = -1; // take digit number from the map and reset this map cell to -1
   return iDig;
 }
+
 //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+
 // bool Clusterer::IsDigSurvive(Int_t *pUserCut, Digit *pDig)const
+
 bool Clusterer::IsDigSurvive(Digit* pDig) const
 {
   // Check if the current digit survive to a riapllied sigma cut
   // Arguments: pDig pointer to the current digit
   //   Returns: kTRUE if charge > mean+n*sigma
   /*int iCh = pDig->Ch();
+
   int iDaqSigCut =(int)fDaqSig->At(iCh)->GetUniqueID();
   if(pUserCut[iCh]<=iDaqSigCut) return kTRUE;
+
   TMatrixF *pM = (TMatrixF*)fDaqSig->At(pDig->Ch());
   float sig = (*pM)(pDig->PadChX(),pDig->PadChY());
   //if(pDig->Q()>pUserCut[iCh]*sig) return kTRUE; to be improved
   */
+
   if (pDig->getQ() > 4.) {
     return true;
   } else {
     return false;
   }
 }
-//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
-/*void Clusterer::process(std::vector<o2::hmpid::Digit> const& digits, std::vector<o2::hmpid::Cluster>& clusters, MCLabelContainer const* digitMCTruth)
-{
-  TStopwatch timerProcess;
-  timerProcess.Start();
-
-  //  reader.init();
-  //  int totNumDigits = 0;
-  //
-  //  while (reader.getNextStripData(mStripData)) {
-  //    LOG(debug) << "HMPIDClusterer got Strip " << mStripData.stripID << " with Ndigits "
-  //               << mStripData.digits.size();
-  //    totNumDigits += mStripData.digits.size();
-  //
-  //    processStrip(clusters, digitMCTruth);
-  //  }
-
-  //  LOG(debug) << "We had " << totNumDigits << " digits in this event";
-  timerProcess.Stop();
-  printf("Timing:\n");
-  printf("Clusterer::process:        ");
-  timerProcess.Print();
-}*/
diff --git a/Detectors/HMPID/workflow/include/HMPIDWorkflow/ClustersReaderSpec.h b/Detectors/HMPID/workflow/include/HMPIDWorkflow/ClustersReaderSpec.h
index 7aba612775..c3e70298e8 100644
--- a/Detectors/HMPID/workflow/include/HMPIDWorkflow/ClustersReaderSpec.h
+++ b/Detectors/HMPID/workflow/include/HMPIDWorkflow/ClustersReaderSpec.h
@@ -13,7 +13,7 @@
 /// \file    DatDecoderSpec.h
 /// \author  Andrea Ferrero
 ///
-/// \brief Definition of a data processor to run the raw decoding
+/// \brief Definition of a data processor to read Clusters
 ///
 
 #ifndef DETECTORS_HMPID_WORKFLOW_INCLUDE_HMPIDWORKFLOW_CLUSTERSREADERSPEC_H_
@@ -41,16 +41,26 @@ namespace hmpid
 class ClusterReaderTask : public framework::Task
 {
  public:
-  ClusterReaderTask() = default;
-  //  : mReadFile(readFile) {}
+  // ef added
+  ClusterReaderTask(bool useMC, bool verbose)
+  {
+    mUseMC = useMC;
+    mVerbose = verbose;
+  };
+
   ~ClusterReaderTask() override = default;
 
   void init(framework::InitContext& ic) final;
-
   void run(framework::ProcessingContext& pc) final;
   // void endOfStream(framework::EndOfStreamContext& ec) override;
 
  private:
+  // ef : added
+  bool mUseMC = false;
+  bool mVerbose = false;
+
+  std::string mClusterMCTruthBranchName = "HMPIDClusterLabels";
+
   bool mReadFile = false;
   void initFileIn(const std::string& filename);
 
@@ -59,6 +69,10 @@ class ClusterReaderTask : public framework::Task
 
   std::unique_ptr<TFile> mFile; // root file with Clusters
   std::unique_ptr<TTree> mTree; // tree inside the file
+
+  // ef: add mLabels for clusteres
+  o2::dataformats::MCTruthContainer<o2::MCCompLabel> mLabels, *mLabelsPtr = &mLabels;
+
   std::vector<o2::hmpid::Trigger> mClusterTriggersFromFile, *mClusterTriggersFromFilePtr = &mClusterTriggersFromFile;
   std::vector<o2::hmpid::Cluster> mClustersFromFile, *mClustersFromFilePtr = &mClustersFromFile;
 
@@ -68,7 +82,7 @@ class ClusterReaderTask : public framework::Task
   // void strToFloatsSplit(std::string s, std::string delimiter, float* res, int maxElem = 7);
 };
 
-o2::framework::DataProcessorSpec getClusterReaderSpec();
+o2::framework::DataProcessorSpec getClusterReaderSpec(bool useMC, bool verbose = false);
 
 } // end namespace hmpid
 } // end namespace o2
diff --git a/Detectors/HMPID/workflow/include/HMPIDWorkflow/ClustersWriterSpec.h b/Detectors/HMPID/workflow/include/HMPIDWorkflow/ClustersWriterSpec.h
index f9d9cd4286..b3d24890d3 100644
--- a/Detectors/HMPID/workflow/include/HMPIDWorkflow/ClustersWriterSpec.h
+++ b/Detectors/HMPID/workflow/include/HMPIDWorkflow/ClustersWriterSpec.h
@@ -16,14 +16,13 @@
 #define STEER_DIGITIZERWORKFLOW_SRC_HMPCLUSTERWRITERSPEC_H_
 
 #include "Framework/DataProcessorSpec.h"
+#include "SimulationDataFormat/MCCompLabel.h"
 
 namespace o2
 {
 namespace hmpid
 {
-
-o2::framework::DataProcessorSpec getClusterWriterSpec();
-
+o2::framework::DataProcessorSpec getClusterWriterSpec(bool useMc);
 } // end namespace hmpid
 } // end namespace o2
 
diff --git a/Detectors/HMPID/workflow/include/HMPIDWorkflow/DigitsReaderSpec.h b/Detectors/HMPID/workflow/include/HMPIDWorkflow/DigitsReaderSpec.h
index a494a1babe..7c5f986fb4 100644
--- a/Detectors/HMPID/workflow/include/HMPIDWorkflow/DigitsReaderSpec.h
+++ b/Detectors/HMPID/workflow/include/HMPIDWorkflow/DigitsReaderSpec.h
@@ -25,6 +25,8 @@
 
 #include "Framework/DataProcessorSpec.h"
 #include "Framework/Task.h"
+#include "SimulationDataFormat/MCTruthContainer.h"
+#include "SimulationDataFormat/MCCompLabel.h"
 
 #include "HMPIDBase/Common.h"
 #include "DataFormatsHMP/Digit.h"
@@ -39,8 +41,7 @@ namespace hmpid
 class DigitReader : public framework::Task
 {
  public:
-  DigitReader() = default;
-  //  : mReadFile(readFile) {}
+  DigitReader(bool useMC, bool verbose) : mUseMC(useMC), mVerbose(verbose) {}
   ~DigitReader() override = default;
 
   void init(framework::InitContext& ic) final;
@@ -49,14 +50,20 @@ class DigitReader : public framework::Task
   // void endOfStream(framework::EndOfStreamContext& ec) override;
 
  private:
+  // ef : added
+  bool mUseMC = false;
+  bool mVerbose = false;
+
+  o2::dataformats::MCTruthContainer<o2::MCCompLabel> mLabels, *mPlabels = &mLabels;
+
   bool mReadFile = false;
   void initFileIn(const std::string& filename);
 
   long mDigitsReceived;
   ExecutionTimer mExTimer;
 
-  std::unique_ptr<TFile> mFile; // root file with digits
-  std::unique_ptr<TTree> mTree; // tree inside the file
+  std::unique_ptr<TFile> mFile;    // root file with digits
+  std::unique_ptr<TTree> mTreeDig; // tree inside the file
 
   unsigned long mNumberOfEntries = 0; // number of entries from TTree
   unsigned long mCurrentEntry = 0;    // index of current entry
@@ -64,7 +71,7 @@ class DigitReader : public framework::Task
   // void strToFloatsSplit(std::string s, std::string delimiter, float* res, int maxElem = 7);
 };
 
-o2::framework::DataProcessorSpec getDigitsReaderSpec();
+framework::DataProcessorSpec getDigitsReaderSpec(bool useMC, bool verbose = false); // default initializer for verbose
 
 } // end namespace hmpid
 } // end namespace o2
diff --git a/Detectors/HMPID/workflow/include/HMPIDWorkflow/DigitsToClustersSpec.h b/Detectors/HMPID/workflow/include/HMPIDWorkflow/DigitsToClustersSpec.h
index 511ad14040..1a7829e6e8 100644
--- a/Detectors/HMPID/workflow/include/HMPIDWorkflow/DigitsToClustersSpec.h
+++ b/Detectors/HMPID/workflow/include/HMPIDWorkflow/DigitsToClustersSpec.h
@@ -25,7 +25,8 @@
 #include "DataFormatsHMP/Digit.h"
 #include "DataFormatsHMP/Trigger.h"
 #include "HMPIDBase/Geo.h"
-
+#include "SimulationDataFormat/MCCompLabel.h"
+#include "SimulationDataFormat/MCTruthContainer.h"
 #include "TFile.h"
 #include "TTree.h"
 
@@ -33,12 +34,18 @@ namespace o2
 {
 namespace hmpid
 {
-
 class DigitsToClustersTask : public framework::Task
 {
  public:
-  DigitsToClustersTask() = default;
+  DigitsToClustersTask(bool useMC) : mUseMC(useMC)
+  {
+    if (useMC) {
+      mClsLabels.reset(new o2::dataformats::MCTruthContainer<o2::MCCompLabel>);
+    }
+  }
+
   ~DigitsToClustersTask() override = default;
+
   void init(framework::InitContext& ic) final;
   void run(framework::ProcessingContext& pc) final;
   void endOfStream(framework::EndOfStreamContext& ec) override;
@@ -54,9 +61,13 @@ class DigitsToClustersTask : public framework::Task
   std::unique_ptr<o2::hmpid::Clusterer> mRec; // ef: changed to smart-pointer
   long mDigitsReceived;
   long mClustersReceived;
+  bool mUseMC = false; // is set in init
 
   void initFileIn(const std::string& fileName);
 
+  std::unique_ptr<o2::dataformats::MCTruthContainer<o2::MCCompLabel>> mClsLabels; // ef added
+  // MCLabelContainer mClsLabels;
+
   ExecutionTimer mExTimer;
   void strToFloatsSplit(std::string s, std::string delimiter, float* res,
                         int maxElem = 7);
@@ -64,7 +75,7 @@ class DigitsToClustersTask : public framework::Task
 
 // ef : read from stream by default:
 o2::framework::DataProcessorSpec
-  getDigitsToClustersSpec();
+  getDigitsToClustersSpec(bool useMC);
 
 } // end namespace hmpid
 } // end namespace o2
diff --git a/Detectors/HMPID/workflow/include/HMPIDWorkflow/DigitsWriterSpec.h b/Detectors/HMPID/workflow/include/HMPIDWorkflow/DigitsWriterSpec.h
index 45edadfa40..5c9d355fb3 100644
--- a/Detectors/HMPID/workflow/include/HMPIDWorkflow/DigitsWriterSpec.h
+++ b/Detectors/HMPID/workflow/include/HMPIDWorkflow/DigitsWriterSpec.h
@@ -25,6 +25,8 @@
 #include "Framework/DataProcessorSpec.h"
 #include "Framework/Task.h"
 
+#include "SimulationDataFormat/MCCompLabel.h"
+#include "SimulationDataFormat/MCTruthContainer.h"
 #include "HMPIDBase/Common.h"
 #include "DataFormatsHMP/Digit.h"
 #include "DataFormatsHMP/Trigger.h"
@@ -40,7 +42,7 @@ namespace hmpid
 class DigitsToRootTask : public framework::Task
 {
  public:
-  DigitsToRootTask() = default;
+  DigitsToRootTask(bool useMC) : mUseMC(useMC) {}
   ~DigitsToRootTask() override = default;
   void init(framework::InitContext& ic) final;
   void run(framework::ProcessingContext& pc) final;
@@ -50,12 +52,22 @@ class DigitsToRootTask : public framework::Task
   ExecutionTimer mExTimer;
   std::vector<o2::hmpid::Trigger> mTriggers;
   std::vector<o2::hmpid::Digit> mDigits;
-  TFile* mfileOut;
-  TTree* mTheTree;
+
+  // ef : added
+  std::vector<o2::dataformats::MCTruthContainer<o2::MCCompLabel>> mDigitLabels;
+
+  // ef : added
+  bool mUseMC = false;
+
+  std::unique_ptr<TFile> mfileOut;
+  std::unique_ptr<TTree> mDigitTree;
   std::string mOutRootFileName;
+
+  std::string mDigitMCTruthBranchName = "HMPIDDigitMCTruth";
 };
 
-o2::framework::DataProcessorSpec getDigitsToRootSpec(std::string inputSpec = "HMP/DIGITS");
+// ef add useMC
+o2::framework::DataProcessorSpec getDigitsToRootSpec(std::string inputSpec = "HMP/DIGITS", bool useMC = false);
 
 } // end namespace hmpid
 } // end namespace o2
diff --git a/Detectors/HMPID/workflow/src/ClustersReaderSpec.cxx b/Detectors/HMPID/workflow/src/ClustersReaderSpec.cxx
index e9e17962cd..80076d60a3 100644
--- a/Detectors/HMPID/workflow/src/ClustersReaderSpec.cxx
+++ b/Detectors/HMPID/workflow/src/ClustersReaderSpec.cxx
@@ -76,34 +76,75 @@ void ClusterReaderTask::run(ProcessingContext& pc)
   mClustersReceived += mClustersFromFile.size();
   LOG(info) << "[HMPID ClusterReader - run() ] clusters  = " << mClustersFromFile.size();
 
-  if (mTree->GetReadEntry() + 1 >= mTree->GetEntries()) {
-    pc.services().get<ControlService>().endOfStream();
-    pc.services().get<ControlService>().readyToQuit(QuitRequest::Me);
-    mExTimer.stop();
-    mExTimer.logMes("End ClusterReader !  clusters = " +
-                    std::to_string(mClustersReceived));
-  }
-
-
-    int tnum = 0;
-
-    LOGP(info, "triggers > {}", mClusterTriggersFromFile.size());
+  if (mVerbose) {
+    int tNum = 0;
     for (const auto trig : *mClusterTriggersFromFilePtr) {
 
       auto timeA = o2::InteractionRecord::bc2ns(trig.getBc(), trig.getOrbit());
       int cnt = 0;
-      int firstentry = trig.getFirstEntry(); int lastEntry = trig.getLastEntry();
-      LOGP(info, "START : trigger number {} : entries {} first {}  lasrt {}  time {} ",tnum, trig.getNumberOfObjects(),  firstentry, lastEntry, timeA / 1000.0f);
 
-      LOGP(info, " bc {} orbit {} ", trig.getBc(), trig.getOrbit());
-      LOGP(info, "end{} entries {}", tnum, trig.getNumberOfObjects());
-      tnum++;
-    }
+      const int firstEntry = trig.getFirstEntry();
+      const int lastEntry = trig.getLastEntry();
+
+      LOGP(debug, "START : trigger number {} : entries {} first {}  lasrt {}  time {} ", tNum, trig.getNumberOfObjects(), firstEntry, lastEntry, timeA / 1000.0f);
+      LOGP(debug, " bc {} orbit {} ", trig.getBc(), trig.getOrbit());
+      LOGP(debug, "end{} entries {}", tNum, trig.getNumberOfObjects());
+
+      if (mUseMC) {
+        std::vector<int> eventLabels;
+
+        for (int i = firstEntry; i <= lastEntry; i++) {
+
+          if (i < mLabels.getIndexedSize() && i < mClustersFromFile.size()) {
+            const auto& labels = mLabels.getLabels(i);
+            int prevEventLabel = 0;
+
+            if (labels.size() > 0) {
+              prevEventLabel = labels[0].getEventID();
+              eventLabels.push_back(prevEventLabel);
+            }
+
+            for (const auto& label : labels) {
+
+              if (label.getEventID() != prevEventLabel) {
+                eventLabels.push_back(label.getEventID());
+              }
+
+              prevEventLabel = label.getEventID();
+            }
+          }
+        }
+
+        LOGP(info, "trigger number {} : entries {}", tNum, trig.getNumberOfObjects());
+        LOGP(info, "\n Different labels from eventLabels {} :::", eventLabels.size());
 
+        std::vector<int> sortedVec = eventLabels;
+        std::sort(sortedVec.begin(), sortedVec.end());
 
+        std::cout << "eventLabels values: ";
+        for (size_t i = 0; i < sortedVec.size(); ++i) {
+          if (i == sortedVec.size() - 1 || sortedVec[i] != sortedVec[i + 1]) {
+            std::cout << sortedVec[i] << " , ";
+          }
+        }
+      }
+      tNum++;
+    }
+  }
 
+  if (mUseMC) {
+    pc.outputs().snapshot(Output{"HMP", "CLUSTERSMCTR", 0}, mLabels);
 
+    LOGP(info, "[HMPID ClustersReader - with useMC : mcLabels size : headerArray {}; truthArray {}", mLabels.getIndexedSize(), mLabels.getNElements());
+  }
 
+  if (mTree->GetReadEntry() + 1 >= mTree->GetEntries()) {
+    pc.services().get<ControlService>().endOfStream();
+    pc.services().get<ControlService>().readyToQuit(QuitRequest::Me);
+    mExTimer.stop();
+    mExTimer.logMes("End ClusterReader !  clusters = " +
+                    std::to_string(mClustersReceived));
+  }
 }
 
 void ClusterReaderTask::initFileIn(const std::string& filename)
@@ -143,80 +184,41 @@ void ClusterReaderTask::initFileIn(const std::string& filename)
       << filename.c_str();
     throw std::runtime_error(
       "HMPID ClusterReaderTask::init() : Did not find Branch HMPIDClusters in clusters tree");
-    }
-
-    int tnum = 0;
-
-    LOGP(info, "triggers > {}", mClusterTriggersFromFile.size());
-    for (const auto trig : *mClusterTriggersFromFilePtr) {
-
-      auto timeA = o2::InteractionRecord::bc2ns(trig.getBc(), trig.getOrbit());
-      int cnt = 0;
-      int firstentry = trig.getFirstEntry(); int lastEntry = trig.getLastEntry();
-      LOGP(info, "START : trigger number {} : entries {} first {}  lasrt {}  time {} ",tnum, trig.getNumberOfObjects(),  firstentry, lastEntry, timeA / 1000.0f);
-
-      LOGP(info, " bc {} orbit {} ", trig.getBc(), trig.getOrbit());
-
-
-      /*std::vector<int> eventLabels;
-
-      for (int i = trig.getFirstEntry(); i <= trig.getLastEntry(); i++) {
-
-        /*****insert from digitsreder* / //
-
-        if (i < mLabels.getIndexedSize() && i < mClustersFromFile.size()) {
-          bool isLabelEventSame = true;
-          const auto& labels = mLabels.getLabels(i);
-          int prevEventLabel = 0;
-
-          if (labels.size() > 0) {
-            prevEventLabel = labels[0].getEventID();
-            eventLabels.push_back(prevEventLabel);
-          }
-          int lblNum = 0;
-          for (const auto& label : labels) {
-
-            if (label.getEventID() != prevEventLabel) {
-              eventLabels.push_back(label.getEventID());
-              isLabelEventSame = false;
-              // LOGP(info, "trigger number {} lblNum {} : event from labelEventId changed!", tnum, lblNum);
-              // LOGP(info, "digit number {}, digEventNum {} labelEventId {} prevEventLabel {}", i, mClustersFromFile[i].getEventNumber(), label.getEventID(), prevEventLabel);
-            }
-            lblNum++;
-
-            prevEventLabel = label.getEventID();
-          }
-        }
-      } 
-      */
-
- 
+  }
 
-      /*****insert from digitsreder*/ //
+  // ef: get useMC, adpted from CPV
+  if (mUseMC) {
 
-      LOGP(info, "end{} entries {}", tnum, trig.getNumberOfObjects());
-      tnum++;
+    if (mTree->GetBranch(mClusterMCTruthBranchName.c_str())) {
+      mTree->SetBranchAddress(mClusterMCTruthBranchName.c_str(), &mLabelsPtr);
+    } else {
+      LOG(warning) << "MC-truth is missing, message will be empty";
     }
+  }
 
-
-  mTree->SetBranchAddress("InteractionRecords", &mClusterTriggersFromFilePtr);
   mTree->Print("toponly");
+  mTree->SetBranchAddress("InteractionRecords", &mClusterTriggersFromFilePtr);
 }
 
 //_________________________________________________________________________________________________
 
-o2::framework::DataProcessorSpec getClusterReaderSpec()
+o2::framework::DataProcessorSpec getClusterReaderSpec(bool useMC, bool verbose)
 {
 
   std::vector<o2::framework::OutputSpec> outputs;
   outputs.emplace_back("HMP", "CLUSTERS", 0, o2::framework::Lifetime::Timeframe);
   outputs.emplace_back("HMP", "INTRECORDS1", 0, o2::framework::Lifetime::Timeframe);
 
+  // ef: added here
+  if (useMC) {
+    outputs.emplace_back("HMP", "CLUSTERSMCTR", 0, Lifetime::Timeframe);
+  }
+
   return DataProcessorSpec{
     "HMP-ClusterReader",
     Inputs{},
     outputs,
-    AlgorithmSpec{adaptFromTask<ClusterReaderTask>()},
+    AlgorithmSpec{adaptFromTask<ClusterReaderTask>(useMC, verbose)},
     Options{{"hmpid-cluster-infile" /*"qc-hmpid-clusters"*/, VariantType::String, "hmpidclusters.root", {"Name of the input file with clusters"}},
             {"input-dir", VariantType::String, "./", {"Input directory"}}}};
 }
diff --git a/Detectors/HMPID/workflow/src/ClustersWriterSpec.cxx b/Detectors/HMPID/workflow/src/ClustersWriterSpec.cxx
index 3d5cdb19be..331816a778 100644
--- a/Detectors/HMPID/workflow/src/ClustersWriterSpec.cxx
+++ b/Detectors/HMPID/workflow/src/ClustersWriterSpec.cxx
@@ -25,8 +25,8 @@ namespace hmpid
 
 template <typename T>
 using BranchDefinition = framework::MakeRootTreeWriterSpec::BranchDefinition<T>;
-
-o2::framework::DataProcessorSpec getClusterWriterSpec()
+using LabelsType = o2::dataformats::MCTruthContainer<o2::MCCompLabel>;
+o2::framework::DataProcessorSpec getClusterWriterSpec(bool useMC)
 {
   using InputSpec = framework::InputSpec;
   using MakeRootTreeWriterSpec = framework::MakeRootTreeWriterSpec;
@@ -35,7 +35,11 @@ o2::framework::DataProcessorSpec getClusterWriterSpec()
                                 "hmpidclusters.root",
                                 MakeRootTreeWriterSpec::TreeAttributes{"o2hmp", "Tree with HMPID clusters"},
                                 BranchDefinition<std::vector<o2::hmpid::Cluster>>{InputSpec{"hmpclusterinput", "HMP", "CLUSTERS"}, "HMPIDclusters"},
-                                BranchDefinition<std::vector<o2::hmpid::Trigger>>{InputSpec{"hmpinteractionrecords", "HMP", "INTRECORDS1"}, "InteractionRecords"})();
+                                BranchDefinition<std::vector<o2::hmpid::Trigger>>{InputSpec{"hmpinteractionrecords", "HMP", "INTRECORDS1"}, "InteractionRecords"},
+                                BranchDefinition<LabelsType>{InputSpec{"clusterlabels", "HMP", "CLUSTERSMCTR", 0},
+                                                             "HMPIDClusterLabels",
+                                                             (useMC ? 1 : 0), // one branch if mc labels enabled
+                                                             ""})();
 }
 
 } // end namespace hmpid
diff --git a/Detectors/HMPID/workflow/src/DigitsReaderSpec.cxx b/Detectors/HMPID/workflow/src/DigitsReaderSpec.cxx
index 91c73bfd7e..a17c5e2d1d 100644
--- a/Detectors/HMPID/workflow/src/DigitsReaderSpec.cxx
+++ b/Detectors/HMPID/workflow/src/DigitsReaderSpec.cxx
@@ -19,7 +19,6 @@
 #include "SimulationDataFormat/MCTruthContainer.h"
 #include "CommonUtils/NameConf.h"
 #include "HMPIDWorkflow/DigitsReaderSpec.h"
-
 #include <random>
 #include <iostream>
 #include <fstream>
@@ -27,9 +26,7 @@
 #include <array>
 #include <functional>
 #include <vector>
-
 #include "CommonUtils/StringUtils.h" // o2::utils::Str
-
 #include "Framework/CallbackService.h"
 #include "Framework/ConfigParamRegistry.h"
 #include "Framework/ControlService.h"
@@ -39,11 +36,10 @@
 #include "Framework/Logger.h"
 #include "Framework/DataRefUtils.h"
 #include "Framework/InputRecordWalker.h"
-
 #include "Headers/RAWDataHeader.h"
+
 #include "DetectorsRaw/RDHUtils.h"
 #include "DPLUtils/DPLRawParser.h"
-
 #include "HMPIDBase/Geo.h"
 
 using namespace o2::framework;
@@ -54,9 +50,10 @@ namespace o2
 {
 namespace hmpid
 {
-
 void DigitReader::init(InitContext& ic)
+
 {
+
   auto filename = o2::utils::Str::concat_string(o2::utils::Str::rectifyDirectory(ic.options().get<std::string>("input-dir")),
                                                 ic.options().get<std::string>("hmpid-digit-infile"));
   mFile.reset(TFile::Open(filename.c_str()));
@@ -64,95 +61,168 @@ void DigitReader::init(InitContext& ic)
   LOG(info) << "HMPID DigitWriterSpec::init() : Trying to read File : " << filename.c_str();
 
   mDigitsReceived = 0;
+
   if (!mFile->IsOpen()) {
     LOG(error) << "HMPID DigitWriterSpec::init() : Did not find any digits file " << filename.c_str() << " file !";
     throw std::runtime_error("cannot open input digits file");
   }
 
   if ((TTree*)mFile->Get("o2sim") != nullptr) {
-    mTree.reset((TTree*)mFile->Get("o2sim"));
+    mTreeDig.reset((TTree*)mFile->Get("o2sim"));
   } else if ((TTree*)mFile->Get("o2hmp") != nullptr) {
-    mTree.reset((TTree*)mFile->Get("o2hmp"));
+    mTreeDig.reset((TTree*)mFile->Get("o2hmp"));
   } else {
     LOG(error) << "Did not find o2hmp tree in " << filename.c_str();
     throw std::runtime_error("Did Not find Any correct Tree in HMPID Digits File");
   }
 
-  if (!mTree) {
+  if (!mTreeDig) {
     LOG(error) << "Did not find o2hmp tree in " << filename.c_str();
     throw std::runtime_error("Did Not find Any correct Tree in HMPID Digits File");
-  } /*else {
-    LOG(info) << "HMPID DigitWriterSpec::init() : Reading From Branch  o2hmp" << File : " << filename.c_str()";
-  } */
+
+  } 
 }
 
 void DigitReader::run(ProcessingContext& pc)
+
 {
   std::vector<o2::hmpid::Digit> mDigitsFromFile, *mDigitsFromFilePtr = &mDigitsFromFile;
   std::vector<o2::hmpid::Trigger> mTriggersFromFile, *mTriggersFromFilePtr = &mTriggersFromFile;
-
   /*  */
-  if (mTree->GetBranchStatus("HMPDigit")) {
-    mTree->SetBranchAddress("HMPDigit", &mDigitsFromFilePtr);
-  } else if (mTree->GetBranchStatus("HMPIDDigits")) {
-    mTree->SetBranchAddress("HMPIDDigits", &mDigitsFromFilePtr);
+
+  mTreeDig->Print("toponly");
+
+  if (mTreeDig->GetBranchStatus("HMPDigit")) {
+    mTreeDig->SetBranchAddress("HMPDigit", &mDigitsFromFilePtr);
+  } else if (mTreeDig->GetBranchStatus("HMPIDDigits")) {
+    mTreeDig->SetBranchAddress("HMPIDDigits", &mDigitsFromFilePtr);
   } else {
     LOG(error)
       << "HMPID DigitWriterSpec::init() : Did not find any branch for Digits";
     throw std::runtime_error("Did Not find Any correct Branch for Digits in HMPID Digits File");
   }
 
-  if (mTree->GetBranchStatus("InteractionRecords")) {
-    mTree->SetBranchAddress("InteractionRecords", &mTriggersFromFilePtr);
+  if (mTreeDig->GetBranchStatus("InteractionRecords")) {
+    mTreeDig->SetBranchAddress("InteractionRecords", &mTriggersFromFilePtr);
   } else {
     LOG(error)
       << "HMPID DigitWriterSpec::init() : Did not find  branch for Triggers";
     throw std::runtime_error("Did Not find Branch For triggers in HMPID Digits File");
   }
-  // mTree->Print("toponly");
-
-  auto ent = mTree->GetReadEntry() + 1;
-  assert(ent < mTree->GetEntries()); // this should not happen
-  mTree->GetEntry(ent);
-
-  int tnum = 0;
-  for(const auto& trig : mTriggersFromFile)	{
-    //int tnum = 0;
-    //iLOGP(info, "trigger : numberOfEntreies {}", trig.getNumberOfObjects());
-    auto timeA = o2::InteractionRecord::bc2ns(trig.getBc(), trig.getOrbit());
-    int firstentry = trig.getFirstEntry(); int lastEntry = trig.getLastEntry();
-    LOGP(info, "START : trigger number {} : entries {} first {}  lasrt {}  time {} ",tnum, trig.getNumberOfObjects(),  firstentry, lastEntry, timeA / 1000.0f);
-    //  LOGP(info, "START : trigger number {} : entries {} first {}  lasrt {}  time {} ",tnum, trig.getNumberOfObjects(),  firstentry, lastEntry, timeA / 1000.0f);
-
-    LOGP(info, " bc {} orbit {} ", trig.getBc(), trig.getOrbit());
-    tnum++;
+
+  if (mUseMC) {
+    if (mTreeDig->GetBranchStatus("HMPDigitLabels")) { // HMPDigitLabels ==>  HMPIDDigitMCTruth
+      mTreeDig->SetBranchAddress("HMPDigitLabels", &mPlabels);
+    } else if (mTreeDig->GetBranchStatus("HMPIDDigitMCTruth")) { // HMPDigitLabels ==>  HMPIDDigitMCTruth
+      mTreeDig->SetBranchAddress("HMPIDDigitMCTruth", &mPlabels);
+    } else {
+      LOGP(error, "useMC was set, but did not find the DigitMC branch");
+      throw std::runtime_error("Did Not find Branch For MC truth in HMPID Digits File");
+    }
   }
 
+  auto ent = mTreeDig->GetReadEntry() + 1;
+  assert(ent < mTreeDig->GetEntries()); // this should not happen
+  mTreeDig->GetEntry(ent);
+
   pc.outputs().snapshot(Output{"HMP", "DIGITS", 0}, mDigitsFromFile);
   pc.outputs().snapshot(Output{"HMP", "INTRECORDS", 0}, mTriggersFromFile);
+
+  if (mUseMC) {
+    pc.outputs().snapshot(Output{"HMP", "DIGITLBL", 0}, mLabels); // DIGITLBL == > DIGITSMCTR?
+  }
+
+  if (mVerbose) {
+    int tNum = 0;
+
+    for (const auto trig : mTriggersFromFile) {
+
+      auto timeA =
+        o2::InteractionRecord::bc2ns(trig.getBc(), trig.getOrbit());
+      const int firsEntry = trig.getFirstEntry();
+      const int lastEntry = trig.getLastEntry();
+      LOGP(info,
+           "START : trigger number {} : entries {} first {}  lasrt {}  time "
+           "{} ",
+           tNum, trig.getNumberOfObjects(), firsEntry, lastEntry,
+           timeA / 1000.0f);
+
+      LOGP(info, " bc {} orbit {} ", trig.getBc(), trig.getOrbit());
+      int cnt = 0;
+      if (mUseMC) {
+        std::vector<int> eventLabels;
+
+        for (int i = firsEntry; i <= lastEntry; i++) {
+
+          if (i < mLabels.getIndexedSize() && i < mDigitsFromFile.size()) {
+
+            bool isLabelEventSame = true;
+            const auto& labels = mLabels.getLabels(i);
+            int prevEventLabel;
+            if (labels.size() > 0) {
+              prevEventLabel = labels[0].getEventID();
+              eventLabels.push_back(prevEventLabel);
+            }
+
+            for (const auto& label : labels) {
+              if (label.getEventID() != prevEventLabel) {
+                eventLabels.push_back(label.getEventID());
+              }
+              prevEventLabel = label.getEventID();
+            }
+          } else {
+            LOGP(info, "out of range {} > numLabels {}", i, mLabels.getIndexedSize());
+          }
+        }
+
+        LOGP(info, "\ndifferent labels from eventLabels {} :::", eventLabels.size());
+        std::vector<int> sortedVec = eventLabels;
+        std::sort(sortedVec.begin(), sortedVec.end());
+
+        std::cout << "eventLabels values: ";
+        for (size_t i = 0; i < sortedVec.size(); ++i) {
+          if (i == sortedVec.size() - 1 || sortedVec[i] != sortedVec[i + 1]) {
+            std::cout << sortedVec[i] << " , ";
+          }
+        }
+      }
+
+      tNum++;
+    }
+  }
+
   mDigitsReceived += mDigitsFromFile.size();
   LOG(info) << "[HMPID DigitsReader - run() ] digits  = " << mDigitsFromFile.size();
-
-  if (mTree->GetReadEntry() + 1 >= mTree->GetEntries()) {
+  if (mTreeDig->GetReadEntry() + 1 >= mTreeDig->GetEntries()) {
     pc.services().get<ControlService>().endOfStream();
     pc.services().get<ControlService>().readyToQuit(QuitRequest::Me);
     mExTimer.stop();
+    if (mUseMC) {
+      LOGP(info, "[HMPID DigitsReader - with useMC : mcLabels size : headerArray {}; truthArray {}", mUseMC, mLabels.getIndexedSize(), mLabels.getNElements());
+    }
+
     mExTimer.logMes("End DigitsReader !  digits = " +
                     std::to_string(mDigitsReceived));
   }
 }
 
-DataProcessorSpec getDigitsReaderSpec()
+DataProcessorSpec getDigitsReaderSpec(bool useMC, bool verbose)
 {
+
   std::vector<OutputSpec> outputs;
   outputs.emplace_back("HMP", "DIGITS", 0, o2::framework::Lifetime::Timeframe);
   outputs.emplace_back("HMP", "INTRECORDS", 0, o2::framework::Lifetime::Timeframe);
 
+  if (useMC) {
+    outputs.emplace_back("HMP", "DIGITLBL", 0, Lifetime::Timeframe); // DIGITLBL ==>DIGITSMCTR
+  }
+
   return DataProcessorSpec{
     "HMP-DigitReader",
     Inputs{},
     outputs,
-    AlgorithmSpec{adaptFromTask<DigitReader>()},
+    AlgorithmSpec{adaptFromTask<DigitReader>(useMC, verbose)},
+
     Options{{"hmpid-digit-infile" /*"/qc-hmpid-digits"*/, VariantType::String, "hmpiddigits.root", {"Name of the input file with digits"}},
             {"input-dir", VariantType::String, "./", {"Input directory"}}}};
 }
diff --git a/Detectors/HMPID/workflow/src/DigitsToClustersSpec.cxx b/Detectors/HMPID/workflow/src/DigitsToClustersSpec.cxx
index 81c04a9875..2835758bcb 100644
--- a/Detectors/HMPID/workflow/src/DigitsToClustersSpec.cxx
+++ b/Detectors/HMPID/workflow/src/DigitsToClustersSpec.cxx
@@ -77,40 +77,123 @@ void DigitsToClustersTask::strToFloatsSplit(std::string s,
 void DigitsToClustersTask::init(framework::InitContext& ic)
 {
   mSigmaCutPar = ic.options().get<std::string>("sigma-cut");
-
   if (mSigmaCutPar != "") {
     strToFloatsSplit(mSigmaCutPar, ",", mSigmaCut, 7);
   }
-
   mDigitsReceived = 0, mClustersReceived = 0;
-
-  mRec.reset(new o2::hmpid::Clusterer()); // ef: changed to smart-pointer
-
+  mRec.reset(new o2::hmpid::Clusterer(mUseMC)); // ef: changed to smart-pointer
   mExTimer.start();
 }
 
 void DigitsToClustersTask::run(framework::ProcessingContext& pc)
 {
+
+  // bool mUseMC = true; // ef do inout tu fcn
   // outputs
   std::vector<o2::hmpid::Cluster> clusters;
   std::vector<o2::hmpid::Trigger> clusterTriggers;
+
   LOG(info) << "[HMPID DClusterization - run() ] Enter ...";
-  clusters.clear();
-  clusterTriggers.clear();
 
   auto triggers = pc.inputs().get<gsl::span<o2::hmpid::Trigger>>("intrecord");
   auto digits = pc.inputs().get<gsl::span<o2::hmpid::Digit>>("digits");
 
+  // ef > added
+  auto labelVector = std::make_shared<o2::dataformats::MCTruthContainer<o2::MCCompLabel>>();
+  if (mUseMC) {
+
+    auto digitlabels = pc.inputs().get<o2::dataformats::MCTruthContainer<o2::MCCompLabel>*>("hmpiddigitlabels");
+
+    if (digitlabels == nullptr) {
+      LOGP(error, "digitlabels nullptr");
+      throw std::runtime_error("digitlabels was nullptr");
+    }
+
+    LOGP(info, "triggers {} : digits : {}", triggers.size(), digits.size());
+
+    LOGP(info, "digitlabels of objs in truthArray : {}", digitlabels->getNElements());
+    LOGP(info, "digitlabels of objs in headArray : {}", digitlabels->getIndexedSize());
+
+    if (labelVector != nullptr) {
+      *labelVector.get() = std::move(*digitlabels);
+    } else {
+      LOGP(error, "labelVector nullptr");
+      throw std::runtime_error("labelVector was nullptr");
+    }
+
+    if (mClsLabels != nullptr) {
+      mRec->setMCTruthContainer(mClsLabels.get());
+    } else {
+      LOGP(error, "mClsLabels nullptr");
+      throw std::runtime_error("mClsLabels was nullptr");
+    }
+  }
+
+  int i = 0;
   for (const auto& trig : triggers) {
     if (trig.getNumberOfObjects()) {
+
+      LOGP(info, "[HMPID DClusterization - run() ]  trigger number {} number of digits : {} ", i, trig.getNumberOfObjects());
+
       gsl::span<const o2::hmpid::Digit> trigDigits{
         digits.data() + trig.getFirstEntry(),
         size_t(trig.getNumberOfObjects())};
       size_t clStart = clusters.size();
-      mRec->Dig2Clu(trigDigits, clusters, mSigmaCut, true);
+
+      if (mUseMC && labelVector != nullptr) {
+
+        LOGP(info, "number of objs in truthArray : {}", labelVector->getNElements());
+        LOGP(info, "number of objs in headArray : {}", labelVector->getIndexedSize());
+
+        // clusLabels is set to Clusterer (mRec)
+        // by : mRec->setMCTruthContainer(mClsLabels.get()
+
+        mRec->Dig2Clu(trigDigits, clusters, mSigmaCut, labelVector.get(), true);
+        // mRec->Dig2Clu(trigDigits, clusters, mSigmaCut, &(labelVector->at(i)), true);
+
+      } else {
+        // pass nullptr for mClustersArray if useMC == false
+        mRec->Dig2Clu(trigDigits, clusters, mSigmaCut, nullptr, true);
+      }
+
+      // ef > remove
+      {
+        auto timeA =
+          o2::InteractionRecord::bc2ns(trig.getBc(), trig.getOrbit());
+        int cnt = 0;
+        int firstentry = trig.getFirstEntry();
+        int lastEntry = trig.getLastEntry();
+        LOGP(info,
+             "START :DIGIT TRIGGER  entries {} first {}  lasrt {}  time {} ",
+             trig.getNumberOfObjects(), firstentry, lastEntry, timeA / 1000.0f);
+
+        LOGP(info, " bc {} orbit {} ", trig.getBc(), trig.getOrbit());
+        LOGP(info, " entries {}", trig.getNumberOfObjects());
+      }
+
       clusterTriggers.emplace_back(trig.getIr(), clStart, clusters.size() - clStart);
+
+      // ef > remove
+      auto t = clusterTriggers.back();
+      {
+        auto timeA = o2::InteractionRecord::bc2ns(t.getBc(), t.getOrbit());
+        int cnt = 0;
+        int firstentry = t.getFirstEntry();
+        int lastEntry = t.getLastEntry();
+        LOGP(info,
+             "START : CLUSTER TRIGGER entries {} first {}  lasrt {}  time {} ",
+             t.getNumberOfObjects(), firstentry, lastEntry, timeA / 1000.0f);
+
+        LOGP(info, " bc {} orbit {} ", trig.getBc(), trig.getOrbit());
+        LOGP(info, "entries {}", trig.getNumberOfObjects());
+      }
+
+    } else {
+      LOGP(warn, "[HMPID DClusterization - run() ] trigger number {} had no digits", i);
     }
+    i++;
   }
+
   LOGP(info, "Received {} triggers with {} digits -> {} triggers with {} clusters",
        triggers.size(), digits.size(), clusterTriggers.size(), clusters.size());
   mDigitsReceived += digits.size();
@@ -121,6 +204,14 @@ void DigitsToClustersTask::run(framework::ProcessingContext& pc)
 
   mExTimer.elapseMes("Clusterization of Digits received = " + std::to_string(mDigitsReceived));
   mExTimer.elapseMes("Clusterization of Clusters received = " + std::to_string(mClustersReceived));
+
+  // ef: added mClsLabels
+  if (mUseMC) {
+    if (mClsLabels) {
+      pc.outputs().snapshot(o2::framework::Output{"HMP", "CLUSTERSMCTR", 0}, *mClsLabels);
+      LOGP(info, "[HMPID DigitsToCluster -  mcLabels size : headerArray {}; truthArray {}", mClsLabels->getIndexedSize(), mClsLabels->getNElements());
+    }
+  }
 }
 
 void DigitsToClustersTask::endOfStream(framework::EndOfStreamContext& ec)
@@ -133,8 +224,7 @@ void DigitsToClustersTask::endOfStream(framework::EndOfStreamContext& ec)
 
 //_______________________________________________________________________________________________
 o2::framework::DataProcessorSpec
-  getDigitsToClustersSpec()
-
+  getDigitsToClustersSpec(bool useMC)
 {
 
   std::vector<o2::framework::InputSpec> inputs;
@@ -144,9 +234,20 @@ o2::framework::DataProcessorSpec
   inputs.emplace_back("intrecord", o2::header::gDataOriginHMP, "INTRECORDS", 0,
                       o2::framework::Lifetime::Timeframe);
 
+  // ef: added
+  if (useMC) {
+    inputs.emplace_back("hmpiddigitlabels", o2::header::gDataOriginHMP, "DIGITLBL", 0, Lifetime::Timeframe); // DIGITLBL == > DIGITSMCTR?
+  }
+
   // define outputs
   std::vector<o2::framework::OutputSpec> outputs;
 
+  // ef: added
+  if (useMC) {
+    outputs.emplace_back("HMP", "CLUSTERSMCTR", 0,
+                         o2::framework::Lifetime::Timeframe);
+  }
+
   outputs.emplace_back("HMP", "CLUSTERS", 0,
                        o2::framework::Lifetime::Timeframe);
   outputs.emplace_back("HMP", "INTRECORDS1", 0,
@@ -154,7 +255,7 @@ o2::framework::DataProcessorSpec
 
   return DataProcessorSpec{
     "HMP-Clusterization", inputs, outputs,
-    AlgorithmSpec{adaptFromTask<DigitsToClustersTask>()},
+    AlgorithmSpec{adaptFromTask<DigitsToClustersTask>(useMC)},
     Options{{"sigma-cut",
              VariantType::String,
              "",
diff --git a/Detectors/HMPID/workflow/src/DigitsWriterSpec.cxx b/Detectors/HMPID/workflow/src/DigitsWriterSpec.cxx
index e726fc4a6a..1a928ddd8b 100644
--- a/Detectors/HMPID/workflow/src/DigitsWriterSpec.cxx
+++ b/Detectors/HMPID/workflow/src/DigitsWriterSpec.cxx
@@ -76,11 +76,17 @@ void DigitsToRootTask::init(framework::InitContext& ic)
   TString tit = TString::Format("HMPID Digits File Decoding");
 
   LOG(info) << "Create the ROOT file " << filename.Data();
-  mfileOut = new TFile(TString::Format("%s", filename.Data()), "RECREATE");
+  mfileOut.reset(new TFile(TString::Format("%s", filename.Data()), "RECREATE"));
 
-  mTheTree = new TTree("o2hmp", tit);
-  mTheTree->Branch("InteractionRecords", &mTriggers);
-  mTheTree->Branch("HMPIDDigits", &mDigits);
+  // BranchDefinition<o2::dataformats::MCTruthContainer<o2::emcal::MCLabel>>{InputSpec{"emcaldigitlabels", "EMC", "DIGITSMCTR"}, "EMCALDigitMCTruth", mctruth ? 1 : 0})();
+
+  mDigitTree.reset(new TTree("o2hmp", tit));
+  mDigitTree->Branch("InteractionRecords", &mTriggers);
+  mDigitTree->Branch("HMPIDDigits", &mDigits);
+
+  if (mUseMC) {
+    mDigitTree->Branch(mDigitMCTruthBranchName.c_str(), &mDigitLabels);
+  }
 
   mExTimer.start();
   return;
@@ -90,15 +96,36 @@ void DigitsToRootTask::run(framework::ProcessingContext& pc)
 {
   std::vector<o2::hmpid::Trigger> triggers;
   std::vector<o2::hmpid::Digit> digits;
+  // std::vector<o2::hmpid::Digit> digits;
+  std::vector<o2::dataformats::MCTruthContainer<o2::MCCompLabel>> digitLabels;
 
   for (auto const& ref : InputRecordWalker(pc.inputs())) {
+
+    LOGP(info, "HMP CLASS DigitsToRootTask ");
+    /*
+     And what about MCLabels?
+    */
     if (DataRefUtils::match(ref, {"check", ConcreteDataTypeMatcher{header::gDataOriginHMP, "INTRECORDS"}})) {
       triggers = pc.inputs().get<std::vector<o2::hmpid::Trigger>>(ref);
       LOG(info) << "We receive triggers =" << triggers.size();
     }
     if (DataRefUtils::match(ref, {"check", ConcreteDataTypeMatcher{header::gDataOriginHMP, "DIGITS"}})) {
       digits = pc.inputs().get<std::vector<o2::hmpid::Digit>>(ref);
-      LOG(info) << "The size of the vector =" << digits.size();
+      LOG(info) << "The size of the cluster-vector =" << digits.size();
+    }
+
+    // // DIGITLBL == > DIGITSMCTR?
+    if (mUseMC) {
+      if (DataRefUtils::match(ref, {"check", ConcreteDataTypeMatcher{header::gDataOriginHMP, "DIGITLBL"}})) {
+
+        // std::vector<o2::dataformats::MCTruthContainer<o2::MCCompLabel>> digitLabels
+        //  o2::dataformats::MCTruthContainer<o2::MCCompLabel>
+
+        // we do this in the STEER?
+        // digitLabels = pc.inputs().get<std::vector<o2::hmpid::Digit>>(ref);
+        // LOG(info) << "The size of the vector =" << digitLabels.size();
+        LOGP(info, "HMP CLASS DigitsToRootTask got DIGITLBL");
+      }
     }
 
     for (int i = 0; i < triggers.size(); i++) {
@@ -108,11 +135,19 @@ void DigitsToRootTask::run(framework::ProcessingContext& pc)
       for (int j = triggers[i].getFirstEntry(); j <= triggers[i].getLastEntry(); j++) {
         mDigits.push_back(digits[j]); // append the cluster
         numberOfDigits++;
+
+        // we do this in the STEER?
+        // if (mUseMC)
+        // mDigitLabels.push_back(digitLabels[j]);
+        // mDigitLabels.mergeAtBack(digitLabels[j]);?
       }
+
       mTriggers.push_back(triggers[i]);
       mTriggers.back().setDataRange(startDigitsIndex, numberOfDigits);
+      // mDigitLabels.mergeAtBack(digitLabels);?
     }
   }
+
   mExTimer.stop();
   return;
 }
@@ -121,27 +156,33 @@ void DigitsToRootTask::endOfStream(framework::EndOfStreamContext& ec)
 {
   mExTimer.logMes("Received an End Of Stream !");
   LOG(info) << "The size of digits vector =" << mDigits.size();
-  mTheTree->Fill();
-  mTheTree->Write();
+  mDigitTree->Fill();
+  mDigitTree->Write();
   mfileOut->Close();
   mExTimer.logMes("Register Tree ! ");
   return;
 }
 
 //_________________________________________________________________________________________________
-o2::framework::DataProcessorSpec getDigitsToRootSpec(std::string inputSpec)
+o2::framework::DataProcessorSpec getDigitsToRootSpec(std::string inputSpec, bool useMC)
 {
   std::vector<o2::framework::InputSpec> inputs;
-  inputs.emplace_back("clusters", o2::header::gDataOriginHMP, "DIGITS", 0, Lifetime::Timeframe);
+
+  // ef changed to digits
+  inputs.emplace_back("digits", o2::header::gDataOriginHMP, "DIGITS", 0, Lifetime::Timeframe); // was "clusters"
   inputs.emplace_back("intrecord", o2::header::gDataOriginHMP, "INTRECORDS", 0, Lifetime::Timeframe);
 
+  if (useMC) {
+    inputs.emplace_back("hmpiddigitlabels", o2::header::gDataOriginHMP, "DIGITLBL", 0, Lifetime::Timeframe); // DIGITLBL == > DIGITSMCTR?
+  }                                                                                                          // ef: do as from the steer..
+
   std::vector<o2::framework::OutputSpec> outputs;
 
   return DataProcessorSpec{
     "HMP-DigitsToRoot",
     inputs,
     outputs,
-    AlgorithmSpec{adaptFromTask<DigitsToRootTask>()},
+    AlgorithmSpec{adaptFromTask<DigitsToRootTask>(useMC)},
     Options{{"out-file", VariantType::String, "hmpDigits.root", {"name of the output file"}}}};
 }
 
diff --git a/Detectors/HMPID/workflow/src/clusters-reader-workflow.cxx b/Detectors/HMPID/workflow/src/clusters-reader-workflow.cxx
index a37bc26f9c..43fe9ce546 100644
--- a/Detectors/HMPID/workflow/src/clusters-reader-workflow.cxx
+++ b/Detectors/HMPID/workflow/src/clusters-reader-workflow.cxx
@@ -46,6 +46,19 @@ void customize(std::vector<o2::framework::ConfigParamSpec>& workflowOptions)
                                    o2::framework::VariantType::Bool,
                                    false,
                                    {"read upstream by default"}}); */
+  // ef added
+  workflowOptions.push_back(
+    o2::framework::ConfigParamSpec{"disable-mc",
+                                   o2::framework::VariantType::Bool,
+                                   false,
+                                   {"Do not propagate MC info"}});
+
+  // ef added
+  workflowOptions.push_back(
+    o2::framework::ConfigParamSpec{"verbose",
+                                   o2::framework::VariantType::Bool,
+                                   false,
+                                   {"Print cluster information"}});
 
   o2::raw::HBFUtilsInitializer::addConfigOption(workflowOptions);
 }
@@ -61,7 +74,11 @@ WorkflowSpec defineDataProcessing(const ConfigContext& configcontext)
   WorkflowSpec specs;
   o2::conf::ConfigurableParam::updateFromString(configcontext.options().get<std::string>("configKeyValues"));
 
-  DataProcessorSpec consumer = o2::hmpid::getClusterReaderSpec();
+  // EF: added
+  bool useMC = !configcontext.options().get<bool>("disable-mc");
+  bool verbose = configcontext.options().get<bool>("verbose");
+
+  DataProcessorSpec consumer = o2::hmpid::getClusterReaderSpec(useMC, verbose);
 
   specs.push_back(consumer);
   return specs;
diff --git a/Detectors/HMPID/workflow/src/clusters-writer-workflow.cxx b/Detectors/HMPID/workflow/src/clusters-writer-workflow.cxx
index 81e0003a64..7b9e99a793 100644
--- a/Detectors/HMPID/workflow/src/clusters-writer-workflow.cxx
+++ b/Detectors/HMPID/workflow/src/clusters-writer-workflow.cxx
@@ -50,6 +50,13 @@ void customize(std::vector<ConfigParamSpec>& workflowOptions)
                     "",
                     {keyvaluehelp}});
 
+  // ef : added
+  workflowOptions.push_back(
+    o2::framework::ConfigParamSpec{"disable-mc",
+                                   o2::framework::VariantType::Bool,
+                                   false,
+                                   {"Do not propagate MC info"}});
+
   o2::raw::HBFUtilsInitializer::addConfigOption(workflowOptions);
 }
 
@@ -65,7 +72,9 @@ WorkflowSpec defineDataProcessing(const ConfigContext& configcontext)
   o2::conf::ConfigurableParam::updateFromString(
     configcontext.options().get<std::string>("configKeyValues"));
 
-  specs.push_back(hmpid::getClusterWriterSpec());
+  // ef : added
+  bool useMC = !configcontext.options().get<bool>("disable-mc");
+  specs.push_back(hmpid::getClusterWriterSpec(useMC));
 
   return specs;
 }
diff --git a/Detectors/HMPID/workflow/src/digits-reader-workflow.cxx b/Detectors/HMPID/workflow/src/digits-reader-workflow.cxx
index 03e20aafd1..3ca16a9f92 100644
--- a/Detectors/HMPID/workflow/src/digits-reader-workflow.cxx
+++ b/Detectors/HMPID/workflow/src/digits-reader-workflow.cxx
@@ -38,12 +38,13 @@ void customize(std::vector<o2::framework::CallbacksPolicy>& policies)
 // we need to add workflow options before including Framework/runDataProcessing
 void customize(std::vector<o2::framework::ConfigParamSpec>& workflowOptions)
 {
-  std::string keyvaluehelp("Semicolon separated key=value strings ...");
-  workflowOptions.push_back(o2::framework::ConfigParamSpec{"configKeyValues", o2::framework::VariantType::String, "", {keyvaluehelp}});
-
+  std::vector<o2::framework::ConfigParamSpec> options{
+    {"disable-mc", o2::framework::VariantType::Bool, false, {"Do not propagate MC info"}},
+    {"verbose", o2::framework::VariantType::Bool, false, {"Print verbose digit info"}},
+    {"configKeyValues", o2::framework::VariantType::String, "", {"Semicolon separated key=value strings"}}};
+  workflowOptions.insert(workflowOptions.end(), options.begin(), options.end());
   o2::raw::HBFUtilsInitializer::addConfigOption(workflowOptions);
 }
-
 #include "Framework/runDataProcessing.h"
 #include "HMPIDWorkflow/DigitsReaderSpec.h"
 
@@ -55,7 +56,11 @@ WorkflowSpec defineDataProcessing(const ConfigContext& configcontext)
   WorkflowSpec specs;
   o2::conf::ConfigurableParam::updateFromString(configcontext.options().get<std::string>("configKeyValues"));
 
-  DataProcessorSpec consumer = o2::hmpid::getDigitsReaderSpec();
+  // ef : added
+  bool useMC = !configcontext.options().get<bool>("disable-mc");
+  bool verbose = configcontext.options().get<bool>("verbose");
+
+  DataProcessorSpec consumer = o2::hmpid::getDigitsReaderSpec(useMC, verbose);
 
   specs.push_back(consumer);
   return specs;
diff --git a/Detectors/HMPID/workflow/src/digits-to-clusters-workflow.cxx b/Detectors/HMPID/workflow/src/digits-to-clusters-workflow.cxx
index 78a63d31e3..b401966f6e 100644
--- a/Detectors/HMPID/workflow/src/digits-to-clusters-workflow.cxx
+++ b/Detectors/HMPID/workflow/src/digits-to-clusters-workflow.cxx
@@ -45,11 +45,12 @@ void customize(std::vector<ConfigParamSpec>& workflowOptions)
 {
   std::string keyvaluehelp("Semicolon separated key=value strings ...");
   workflowOptions.push_back(ConfigParamSpec{"configKeyValues", VariantType::String, "", {keyvaluehelp}});
-
   workflowOptions.push_back(ConfigParamSpec{"disable-root-input", o2::framework::VariantType::Bool, false, {"disable root-files input readers"}});
-
   workflowOptions.push_back(ConfigParamSpec{"disable-root-output", VariantType::Bool, false, {"disable root-files output writers"}});
 
+  // ef : added
+  workflowOptions.push_back(ConfigParamSpec{"disable-mc", o2::framework::VariantType::Bool, false, {"disable MC propagation even if available"}});
+
   o2::raw::HBFUtilsInitializer::addConfigOption(workflowOptions);
 }
 
@@ -71,21 +72,23 @@ WorkflowSpec defineDataProcessing(const ConfigContext& configcontext)
   auto disableRootInp = configcontext.options().get<bool>("disable-root-input");  // read upstream by default
   auto disableRootOut = configcontext.options().get<bool>("disable-root-output"); // write upstream by default
 
-  DataProcessorSpec consumer = hmpid::getDigitsToClustersSpec();
+  // ef : added
+  auto useMC = !configcontext.options().get<bool>("disable-mc");
+  DataProcessorSpec consumer = hmpid::getDigitsToClustersSpec(useMC);
 
   specs.push_back(consumer);
 
   // Read to File; input file and dir can be specified using
   // --hmpid-digit-infile and --input-dir (from DigitsReaderSpec Class)
   if (!disableRootInp) {
-    specs.emplace_back(hmpid::getDigitsReaderSpec());
+    specs.emplace_back(hmpid::getDigitsReaderSpec(useMC, false));
   }
 
   // Write to Cluster-File; output file and dir can be specified using
   // --outfile and --output-dir (from MakeTreeRootWriter Class)
   if (!disableRootOut) {
-    specs.push_back(hmpid::getClusterWriterSpec());
+    specs.push_back(hmpid::getClusterWriterSpec(useMC));
   }
 
   return specs;
-}
+}
\ No newline at end of file
diff --git a/Detectors/ITSMFT/ITS/tracking/CMakeLists.txt b/Detectors/ITSMFT/ITS/tracking/CMakeLists.txt
index 0b106235a5..d11660a116 100644
--- a/Detectors/ITSMFT/ITS/tracking/CMakeLists.txt
+++ b/Detectors/ITSMFT/ITS/tracking/CMakeLists.txt
@@ -13,6 +13,7 @@ o2_add_library(ITStracking
                TARGETVARNAME targetName
                SOURCES src/ClusterLines.cxx
                        src/Cluster.cxx
+                       src/Configuration.cxx
                        src/ROframe.cxx
                        src/TimeFrame.cxx
                        src/IOUtils.cxx
@@ -36,6 +37,15 @@ o2_add_library(ITStracking
                        O2::ITSMFTReconstruction
                        O2::DataFormatsITS)
 
+
+o2_add_library(ITSTrackingInterface
+               TARGETVARNAME targetName
+               SOURCES src/TrackingInterface.cxx
+               PRIVATE_LINK_LIBRARIES
+                       O2::ITStracking
+                       O2::Framework
+                       O2::GPUTracking)
+
 if (OpenMP_CXX_FOUND)
         target_compile_definitions(${targetName} PRIVATE WITH_OPENMP)
         target_link_libraries(${targetName} PRIVATE OpenMP::OpenMP_CXX)
diff --git a/Detectors/ITSMFT/ITS/tracking/GPU/cuda/Utils.cu b/Detectors/ITSMFT/ITS/tracking/GPU/cuda/Utils.cu
index 42b0cb2ce2..99a24f347b 100644
--- a/Detectors/ITSMFT/ITS/tracking/GPU/cuda/Utils.cu
+++ b/Detectors/ITSMFT/ITS/tracking/GPU/cuda/Utils.cu
@@ -20,6 +20,7 @@
 #include <iomanip>
 #include <numeric>
 #include <iostream>
+#include <cstdint>
 
 namespace
 {
@@ -283,14 +284,6 @@ void utils::gpuMemcpyFromSymbol(void* dst, const void* symbol, int size)
 {
   checkGPUError(cudaMemcpyFromSymbol(dst, symbol, size, 0, cudaMemcpyDeviceToHost), __FILE__, __LINE__);
 }
-
-GPUd() int utils::getLaneIndex()
-{
-  uint32_t laneIndex;
-  asm volatile("mov.u32 %0, %%laneid;"
-               : "=r"(laneIndex));
-  return static_cast<int>(laneIndex);
-}
 } // namespace gpu
 } // namespace its
 } // namespace o2
diff --git a/Detectors/ITSMFT/ITS/tracking/include/ITStracking/Configuration.h b/Detectors/ITSMFT/ITS/tracking/include/ITStracking/Configuration.h
index fc8d128c6e..2a66bbd245 100644
--- a/Detectors/ITSMFT/ITS/tracking/include/ITStracking/Configuration.h
+++ b/Detectors/ITSMFT/ITS/tracking/include/ITStracking/Configuration.h
@@ -31,6 +31,15 @@ namespace o2
 namespace its
 {
 
+enum class TrackingMode {
+  Sync,
+  Async,
+  Cosmics
+};
+
+std::string asString(TrackingMode mode);
+std::ostream& operator<<(std::ostream& os, TrackingMode v);
+
 template <typename Param>
 class Configuration : public Param
 {
@@ -123,19 +132,11 @@ struct VertexingParameters {
 
 struct TimeFrameGPUParameters {
   TimeFrameGPUParameters() = default;
-  // TimeFrameGPUParameters(size_t cubBufferSize,
-  //                        size_t maxTrkClu,
-  //                        size_t cluLayCap,
-  //                        size_t cluROfCap,
-  //                        size_t maxTrkCap,
-  //                        size_t maxVertCap,
-  //                        size_t maxROFs);
 
   size_t tmpCUBBufferSize = 1e5; // In average in pp events there are required 4096 bytes
   size_t maxTrackletsPerCluster = 1e2;
   size_t clustersPerLayerCapacity = 2.5e5;
   size_t clustersPerROfCapacity = 1.5e3;
-  // size_t trackletsCapacity = maxTrackletsPerCluster * clustersPerROfCapacity;
   size_t validatedTrackletsCapacity = 1e3;
   size_t cellsLUTsize = validatedTrackletsCapacity;
   size_t maxNeighboursSize = 1e2;
@@ -148,29 +149,6 @@ struct TimeFrameGPUParameters {
   int maxGPUMemoryGB = -1;
 };
 
-// inline TimeFrameGPUParameters::TimeFrameGPUParameters(size_t cubBufferSize,
-//                                                       size_t maxTrkClu,
-//                                                       size_t cluLayCap,
-//                                                       size_t cluROfCap,
-//                                                       size_t maxTrkCap,
-//                                                       size_t maxVertCap,
-//                                                       size_t maxROFs,
-//                                                       size_t validatedTrackletsCapacity,
-//                                                       size_t cellsLUTsize,
-//                                                       size_t maxNeighboursSize,
-//                                                       size_t neighboursLUTsize,
-//                                                       size_t maxRoadPerRofSize,
-//                                                       size_t maxLinesCapacity) : tmpCUBBufferSize{cubBufferSize},
-//                                                                                  maxTrackletsPerCluster{maxTrkClu},
-//                                                                                  clustersPerLayerCapacity{cluLayCap},
-//                                                                                  clustersPerROfCapacity{cluROfCap},
-//                                                                                  maxLinesCapacity{maxTrkCap},
-//                                                                                  maxVerticesCapacity{maxVertCap},
-//                                                                                  nMaxROFs{maxROFs}
-// {
-//   trackletsCapacity = maxTrackletsPerCluster * clustersPerLayerCapacity;
-// }
-
 } // namespace its
 } // namespace o2
 
diff --git a/Detectors/ITSMFT/ITS/tracking/include/ITStracking/TrackingInterface.h b/Detectors/ITSMFT/ITS/tracking/include/ITStracking/TrackingInterface.h
new file mode 100644
index 0000000000..0700cfdf09
--- /dev/null
+++ b/Detectors/ITSMFT/ITS/tracking/include/ITStracking/TrackingInterface.h
@@ -0,0 +1,80 @@
+// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
+// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
+// All rights not expressly granted are reserved.
+//
+// This software is distributed under the terms of the GNU General Public
+// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
+//
+// In applying this license CERN does not waive the privileges and immunities
+// granted to it by virtue of its status as an Intergovernmental Organization
+// or submit itself to any jurisdiction.
+
+#ifndef O2_ITS_TRACKINGINTERFACE
+#define O2_ITS_TRACKINGINTERFACE
+
+#include "Framework/DataProcessorSpec.h"
+
+#include "ITStracking/TimeFrame.h"
+#include "ITStracking/Tracker.h"
+#include "ITStracking/TrackerTraits.h"
+#include "ITStracking/Vertexer.h"
+#include "ITStracking/VertexerTraits.h"
+#include "DataFormatsParameters/GRPObject.h"
+#include "DataFormatsITSMFT/TopologyDictionary.h"
+#include "DataFormatsCalibration/MeanVertexObject.h"
+
+#include "GPUDataTypes.h"
+#include "GPUO2Interface.h"
+#include "GPUChainITS.h"
+
+namespace o2::its
+{
+class ITSTrackingInterface
+{
+ public:
+  ITSTrackingInterface(bool isMC,
+                       int trgType,
+                       const TrackingMode trMode,
+                       const bool overrBeamEst)
+    : mIsMC{isMC},
+      mUseTriggers{trgType},
+      mMode{trMode},
+      mOverrideBeamEstimation{overrBeamEst}
+  {
+  }
+
+  void setClusterDictionary(const o2::itsmft::TopologyDictionary* d) { mDict = d; }
+  void setMeanVertex(const o2::dataformats::MeanVertexObject* v)
+  {
+    if (!v) {
+      return;
+    }
+    mMeanVertex = v;
+  }
+  // Task callbacks
+  void initialise();
+  template <bool isGPU = false>
+  void run(framework::ProcessingContext& pc);
+
+  void updateTimeDependentParams(framework::ProcessingContext& pc);
+  void finaliseCCDB(framework::ConcreteDataMatcher& matcher, void* obj);
+
+  // Custom
+  void setTraitsFromProvider(VertexerTraits*, TrackerTraits*, TimeFrame*);
+
+ private:
+  bool mIsMC = false;
+  bool mRunVertexer = true;
+  bool mCosmicsProcessing = false;
+  int mUseTriggers = 0;
+  TrackingMode mMode = TrackingMode::Sync;
+  bool mOverrideBeamEstimation = false;
+  const o2::itsmft::TopologyDictionary* mDict = nullptr;
+  std::unique_ptr<Tracker> mTracker = nullptr;
+  std::unique_ptr<Vertexer> mVertexer = nullptr;
+  TimeFrame* mTimeFrame = nullptr;
+  const o2::dataformats::MeanVertexObject* mMeanVertex;
+};
+
+} // namespace o2::its
+#endif // O2_ITS_TRACKINGINTERFACE
\ No newline at end of file
diff --git a/Detectors/ITSMFT/ITS/tracking/src/Configuration.cxx b/Detectors/ITSMFT/ITS/tracking/src/Configuration.cxx
new file mode 100644
index 0000000000..3c22260901
--- /dev/null
+++ b/Detectors/ITSMFT/ITS/tracking/src/Configuration.cxx
@@ -0,0 +1,34 @@
+// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
+// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
+// All rights not expressly granted are reserved.
+//
+// This software is distributed under the terms of the GNU General Public
+// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
+//
+// In applying this license CERN does not waive the privileges and immunities
+// granted to it by virtue of its status as an Intergovernmental Organization
+// or submit itself to any jurisdiction.
+
+#include "ITStracking/Configuration.h"
+
+namespace o2::its
+{
+std::string asString(TrackingMode mode)
+{
+  switch (mode) {
+    case TrackingMode::Sync:
+      return "sync";
+    case TrackingMode::Async:
+      return "async";
+    case TrackingMode::Cosmics:
+      return "cosmics";
+  }
+  return "unknown";
+}
+
+std::ostream& operator<<(std::ostream& os, TrackingMode v)
+{
+  os << asString(v);
+  return os;
+}
+} // namespace o2::its
\ No newline at end of file
diff --git a/Detectors/ITSMFT/ITS/tracking/src/TrackingInterface.cxx b/Detectors/ITSMFT/ITS/tracking/src/TrackingInterface.cxx
new file mode 100644
index 0000000000..066d400a17
--- /dev/null
+++ b/Detectors/ITSMFT/ITS/tracking/src/TrackingInterface.cxx
@@ -0,0 +1,353 @@
+// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
+// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
+// All rights not expressly granted are reserved.
+//
+// This software is distributed under the terms of the GNU General Public
+// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
+//
+// In applying this license CERN does not waive the privileges and immunities
+// granted to it by virtue of its status as an Intergovernmental Organization
+// or submit itself to any jurisdiction.
+
+#include "ITSMFTBase/DPLAlpideParam.h"
+#include "ITSBase/GeometryTGeo.h"
+
+#include "ITSReconstruction/FastMultEstConfig.h"
+#include "ITSReconstruction/FastMultEst.h"
+
+#include "ITStracking/TrackingInterface.h"
+
+#include "DataFormatsITSMFT/ROFRecord.h"
+#include "DataFormatsITSMFT/PhysTrigger.h"
+#include "DataFormatsTRD/TriggerRecord.h"
+#include "CommonDataFormat/IRFrame.h"
+#include "DetectorsBase/GRPGeomHelper.h"
+
+namespace o2
+{
+using namespace framework;
+namespace its
+{
+void ITSTrackingInterface::initialise()
+{
+  mRunVertexer = true;
+  mCosmicsProcessing = false;
+  std::vector<TrackingParameters> trackParams;
+
+  if (mMode == TrackingMode::Async) {
+
+    trackParams.resize(3);
+    for (auto& param : trackParams) {
+      param.ZBins = 64;
+      param.PhiBins = 32;
+      param.CellsPerClusterLimit = 1.e3f;
+      param.TrackletsPerClusterLimit = 1.e3f;
+    }
+    trackParams[1].TrackletMinPt = 0.2f;
+    trackParams[1].CellDeltaTanLambdaSigma *= 2.;
+    trackParams[2].TrackletMinPt = 0.1f;
+    trackParams[2].CellDeltaTanLambdaSigma *= 4.;
+    trackParams[2].MinTrackLength = 4;
+    LOG(info) << "Initializing tracker in async. phase reconstruction with " << trackParams.size() << " passes";
+
+  } else if (mMode == TrackingMode::Sync) {
+    trackParams.resize(1);
+    trackParams[0].ZBins = 64;
+    trackParams[0].PhiBins = 32;
+    trackParams[0].MinTrackLength = 4;
+    LOG(info) << "Initializing tracker in sync. phase reconstruction with " << trackParams.size() << " passes";
+  } else if (mMode == TrackingMode::Cosmics) {
+    mCosmicsProcessing = true;
+    mRunVertexer = false;
+    trackParams.resize(1);
+    trackParams[0].MinTrackLength = 4;
+    trackParams[0].CellDeltaTanLambdaSigma *= 10;
+    trackParams[0].PhiBins = 4;
+    trackParams[0].ZBins = 16;
+    trackParams[0].PVres = 1.e5f;
+    trackParams[0].MaxChi2ClusterAttachment = 60.;
+    trackParams[0].MaxChi2NDF = 40.;
+    trackParams[0].TrackletsPerClusterLimit = 100.;
+    trackParams[0].CellsPerClusterLimit = 100.;
+    LOG(info) << "Initializing tracker in reconstruction for cosmics with " << trackParams.size() << " passes";
+
+  } else {
+    throw std::runtime_error(fmt::format("Unsupported ITS tracking mode {:s} ", asString(mMode)));
+  }
+
+  for (auto& params : trackParams) {
+    params.CorrType = o2::base::PropagatorImpl<float>::MatCorrType::USEMatCorrLUT;
+  }
+  mTracker->setParameters(trackParams);
+}
+
+template <bool isGPU>
+void ITSTrackingInterface::run(framework::ProcessingContext& pc)
+{
+  auto compClusters = pc.inputs().get<gsl::span<o2::itsmft::CompClusterExt>>("compClusters");
+  gsl::span<const unsigned char> patterns = pc.inputs().get<gsl::span<unsigned char>>("patterns");
+  gsl::span<const o2::itsmft::PhysTrigger> physTriggers;
+  std::vector<o2::itsmft::PhysTrigger> fromTRD;
+  if (mUseTriggers == 2) { // use TRD triggers
+    o2::InteractionRecord ir{0, pc.services().get<o2::framework::TimingInfo>().firstTForbit};
+    auto trdTriggers = pc.inputs().get<gsl::span<o2::trd::TriggerRecord>>("phystrig");
+    for (const auto& trig : trdTriggers) {
+      if (trig.getBCData() >= ir && trig.getNumberOfTracklets()) {
+        ir = trig.getBCData();
+        fromTRD.emplace_back(o2::itsmft::PhysTrigger{ir, 0});
+      }
+    }
+    physTriggers = gsl::span<const o2::itsmft::PhysTrigger>(fromTRD.data(), fromTRD.size());
+  } else if (mUseTriggers == 1) { // use Phys triggers from ITS stream
+    physTriggers = pc.inputs().get<gsl::span<o2::itsmft::PhysTrigger>>("phystrig");
+  }
+
+  auto rofsinput = pc.inputs().get<gsl::span<o2::itsmft::ROFRecord>>("ROframes");
+  auto& rofs = pc.outputs().make<std::vector<o2::itsmft::ROFRecord>>(Output{"ITS", "ITSTrackROF", 0}, rofsinput.begin(), rofsinput.end());
+  auto& irFrames = pc.outputs().make<std::vector<o2::dataformats::IRFrame>>(Output{"ITS", "IRFRAMES", 0});
+  const auto& alpParams = o2::itsmft::DPLAlpideParam<o2::detectors::DetID::ITS>::Instance(); // RS: this should come from CCDB
+
+  irFrames.reserve(rofs.size());
+  int nBCPerTF = alpParams.roFrameLengthInBC;
+
+  LOGP(info, "ITSTracker pulled {} clusters, {} RO frames", compClusters.size(), rofs.size());
+
+  const dataformats::MCTruthContainer<MCCompLabel>* labels = nullptr;
+  gsl::span<itsmft::MC2ROFRecord const> mc2rofs;
+  if (mIsMC) {
+    labels = pc.inputs().get<const dataformats::MCTruthContainer<MCCompLabel>*>("itsmclabels").release();
+    // get the array as read-only span, a snapshot is sent forward
+    pc.outputs().snapshot(Output{"ITS", "ITSTrackMC2ROF", 0}, pc.inputs().get<gsl::span<itsmft::MC2ROFRecord>>("ITSMC2ROframes"));
+    LOG(info) << labels->getIndexedSize() << " MC label objects , in " << mc2rofs.size() << " MC events";
+  }
+
+  auto& allClusIdx = pc.outputs().make<std::vector<int>>(Output{"ITS", "TRACKCLSID", 0});
+  auto& allTracks = pc.outputs().make<std::vector<o2::its::TrackITS>>(Output{"ITS", "TRACKS", 0});
+  auto& vertROFvec = pc.outputs().make<std::vector<o2::itsmft::ROFRecord>>(Output{"ITS", "VERTICESROF", 0});
+  auto& vertices = pc.outputs().make<std::vector<Vertex>>(Output{"ITS", "VERTICES", 0});
+
+  // MC
+  static pmr::vector<o2::MCCompLabel> dummyMCLabTracks, dummyMCLabVerts;
+  auto& allTrackLabels = mIsMC ? pc.outputs().make<std::vector<o2::MCCompLabel>>(Output{"ITS", "TRACKSMCTR", 0}) : dummyMCLabTracks;
+  auto& allVerticesLabels = mIsMC ? pc.outputs().make<std::vector<o2::MCCompLabel>>(Output{"ITS", "VERTICESMCTR", 0}) : dummyMCLabVerts;
+
+  std::uint32_t roFrame = 0;
+
+  bool continuous = o2::base::GRPGeomHelper::instance().getGRPECS()->isDetContinuousReadOut(o2::detectors::DetID::ITS);
+  LOG(info) << "ITSTracker RO: continuous=" << continuous;
+
+  if (mOverrideBeamEstimation) {
+    mTimeFrame->setBeamPosition(mMeanVertex->getX(),
+                                mMeanVertex->getY(),
+                                mMeanVertex->getSigmaY2(),
+                                mTracker->getParameters()[0].LayerResolution[0],
+                                mTracker->getParameters()[0].SystErrorY2[0]);
+  }
+
+  mTracker->setBz(o2::base::Propagator::Instance()->getNominalBz());
+
+  gsl::span<const unsigned char>::iterator pattIt = patterns.begin();
+
+  gsl::span<itsmft::ROFRecord> rofspan(rofs);
+  mTimeFrame->loadROFrameData(rofspan, compClusters, pattIt, mDict, labels);
+  pattIt = patterns.begin();
+  std::vector<int> savedROF;
+  auto logger = [&](std::string s) { LOG(info) << s; };
+  auto fatalLogger = [&](std::string s) { LOG(fatal) << s; };
+  auto errorLogger = [&](std::string s) { LOG(error) << s; };
+
+  FastMultEst multEst; // mult estimator
+  std::vector<bool> processingMask;
+  int cutVertexMult{0}, cutRandomMult = int(rofs.size()) - multEst.selectROFs(rofs, compClusters, physTriggers, processingMask);
+  mTimeFrame->setMultiplicityCutMask(processingMask);
+  float vertexerElapsedTime{0.f};
+  if (mRunVertexer) {
+    vertROFvec.reserve(rofs.size());
+    // Run seeding vertexer
+    if constexpr (isGPU) {
+      vertexerElapsedTime = mVertexer->clustersToVerticesHybrid(logger);
+    } else {
+      vertexerElapsedTime = mVertexer->clustersToVertices(logger);
+    }
+  } else { // cosmics
+    mTimeFrame->resetRofPV();
+  }
+  const auto& multEstConf = FastMultEstConfig::Instance(); // parameters for mult estimation and cuts
+  for (auto iRof{0}; iRof < rofspan.size(); ++iRof) {
+    std::vector<Vertex> vtxVecLoc;
+    auto& vtxROF = vertROFvec.emplace_back(rofspan[iRof]);
+    vtxROF.setFirstEntry(vertices.size());
+    if (mRunVertexer) {
+      auto vtxSpan = mTimeFrame->getPrimaryVertices(iRof);
+      vtxROF.setNEntries(vtxSpan.size());
+      bool selROF = vtxSpan.size() == 0;
+      for (auto iV{0}; iV < vtxSpan.size(); ++iV) {
+        auto& v = vtxSpan[iV];
+        if (multEstConf.isVtxMultCutRequested() && !multEstConf.isPassingVtxMultCut(v.getNContributors())) {
+          continue; // skip vertex of unwanted multiplicity
+        }
+        selROF = true;
+        vertices.push_back(v);
+        if (mIsMC) {
+          auto vLabels = mTimeFrame->getPrimaryVerticesLabels(iRof)[iV];
+          allVerticesLabels.reserve(allVerticesLabels.size() + vLabels.size());
+          std::copy(vLabels.begin(), vLabels.end(), std::back_inserter(allVerticesLabels));
+        }
+      }
+      if (processingMask[iRof] && !selROF) { // passed selection in clusters and not in vertex multiplicity
+        LOG(debug) << fmt::format("ROF {} rejected by the vertex multiplicity selection [{},{}]",
+                                  iRof,
+                                  multEstConf.cutMultVtxLow,
+                                  multEstConf.cutMultVtxHigh);
+        processingMask[iRof] = selROF;
+        cutVertexMult++;
+      }
+    } else { // cosmics
+      vtxVecLoc.emplace_back(Vertex());
+      vtxVecLoc.back().setNContributors(1);
+      vtxROF.setNEntries(vtxVecLoc.size());
+      for (auto& v : vtxVecLoc) {
+        vertices.push_back(v);
+      }
+      mTimeFrame->addPrimaryVertices(vtxVecLoc);
+    }
+  }
+  LOG(info) << fmt::format(" - rejected {}/{} ROFs: random/mult.sel:{} (seed {}), vtx.sel:{}", cutRandomMult + cutVertexMult, rofspan.size(), cutRandomMult, multEst.lastRandomSeed, cutVertexMult);
+  LOG(info) << fmt::format(" - Vertex seeding total elapsed time: {} ms for {} vertices found in {} ROFs", vertexerElapsedTime, mTimeFrame->getPrimaryVerticesNum(), rofspan.size());
+
+  if (mOverrideBeamEstimation) {
+    LOG(info) << fmt::format(" - Beam position set to: {}, {} from meanvertex object", mTimeFrame->getBeamX(), mTimeFrame->getBeamY());
+  } else {
+    LOG(info) << fmt::format(" - Beam position computed for the TF: {}, {}", mTimeFrame->getBeamX(), mTimeFrame->getBeamY());
+  }
+  if (mCosmicsProcessing && compClusters.size() > 1500 * rofspan.size()) {
+    LOG(error) << "Cosmics processing was requested with an average detector occupancy exceeding 1.e-7, skipping TF processing.";
+  } else {
+
+    mTimeFrame->setMultiplicityCutMask(processingMask);
+    // Run CA tracker
+    if constexpr (isGPU) {
+      if (mMode == o2::its::TrackingMode::Async) {
+        mTracker->clustersToTracksHybrid(logger, fatalLogger);
+      } else {
+        mTracker->clustersToTracksHybrid(logger, errorLogger);
+      }
+    } else {
+      if (mMode == o2::its::TrackingMode::Async) {
+        mTracker->clustersToTracks(logger, fatalLogger);
+      } else {
+        mTracker->clustersToTracks(logger, errorLogger);
+      }
+    }
+    size_t totTracks{mTimeFrame->getNumberOfTracks()}, totClusIDs{mTimeFrame->getNumberOfUsedClusters()};
+    allTracks.reserve(totTracks);
+    allClusIdx.reserve(totClusIDs);
+
+    if (mTimeFrame->hasBogusClusters()) {
+      LOG(warning) << fmt::format(" - The processed timeframe had {} clusters with wild z coordinates, check the dictionaries", mTimeFrame->hasBogusClusters());
+    }
+
+    for (unsigned int iROF{0}; iROF < rofs.size(); ++iROF) {
+      auto& rof{rofs[iROF]};
+      auto& tracks = mTimeFrame->getTracks(iROF);
+      auto number{tracks.size()};
+      auto first{allTracks.size()};
+      int offset = -rof.getFirstEntry(); // cluster entry!!!
+      rof.setFirstEntry(first);
+      rof.setNEntries(number);
+
+      if (processingMask[iROF]) {
+        irFrames.emplace_back(rof.getBCData(), rof.getBCData() + nBCPerTF - 1).info = tracks.size();
+      }
+      allTrackLabels.reserve(mTimeFrame->getTracksLabel(iROF).size()); // should be 0 if not MC
+      std::copy(mTimeFrame->getTracksLabel(iROF).begin(), mTimeFrame->getTracksLabel(iROF).end(), std::back_inserter(allTrackLabels));
+      // Some conversions that needs to be moved in the tracker internals
+      for (unsigned int iTrk{0}; iTrk < tracks.size(); ++iTrk) {
+        auto& trc{tracks[iTrk]};
+        trc.setFirstClusterEntry(allClusIdx.size()); // before adding tracks, create final cluster indices
+        int ncl = trc.getNumberOfClusters(), nclf = 0;
+        for (int ic = TrackITSExt::MaxClusters; ic--;) { // track internally keeps in->out cluster indices, but we want to store the references as out->in!!!
+          auto clid = trc.getClusterIndex(ic);
+          if (clid >= 0) {
+            trc.setClusterSize(ic, mTimeFrame->getClusterSize(clid));
+            allClusIdx.push_back(clid);
+            nclf++;
+          }
+        }
+        assert(ncl == nclf);
+        allTracks.emplace_back(trc);
+      }
+    }
+    LOGP(info, "ITSTracker pushed {} tracks and {} vertices", allTracks.size(), vertices.size());
+    if (mIsMC) {
+      LOGP(info, "ITSTracker pushed {} track labels", allTrackLabels.size());
+      LOGP(info, "ITSTracker pushed {} vertex labels", allVerticesLabels.size());
+    }
+  }
+}
+
+void ITSTrackingInterface::updateTimeDependentParams(framework::ProcessingContext& pc)
+{
+  o2::base::GRPGeomHelper::instance().checkUpdates(pc);
+  static bool initOnceDone = false;
+  if (!initOnceDone) { // this params need to be queried only once
+    initOnceDone = true;
+    pc.inputs().get<o2::itsmft::TopologyDictionary*>("itscldict"); // just to trigger the finaliseCCDB
+    pc.inputs().get<o2::itsmft::DPLAlpideParam<o2::detectors::DetID::ITS>*>("itsalppar");
+    if (pc.inputs().getPos("itsTGeo") >= 0) {
+      pc.inputs().get<o2::its::GeometryTGeo*>("itsTGeo");
+    }
+    GeometryTGeo* geom = GeometryTGeo::Instance();
+    geom->fillMatrixCache(o2::math_utils::bit2Mask(o2::math_utils::TransformType::T2L, o2::math_utils::TransformType::T2GRot, o2::math_utils::TransformType::T2G));
+    mVertexer->getGlobalConfiguration();
+    mTracker->getGlobalConfiguration();
+    if (mOverrideBeamEstimation) {
+      pc.inputs().get<o2::dataformats::MeanVertexObject*>("meanvtx");
+    }
+  }
+}
+
+void ITSTrackingInterface::finaliseCCDB(ConcreteDataMatcher& matcher, void* obj)
+{
+  if (o2::base::GRPGeomHelper::instance().finaliseCCDB(matcher, obj)) {
+    return;
+  }
+  if (matcher == ConcreteDataMatcher("ITS", "CLUSDICT", 0)) {
+    LOG(info) << "cluster dictionary updated";
+    setClusterDictionary((const o2::itsmft::TopologyDictionary*)obj);
+    return;
+  }
+  // Note: strictly speaking, for Configurable params we don't need finaliseCCDB check, the singletons are updated at the CCDB fetcher level
+  if (matcher == ConcreteDataMatcher("ITS", "ALPIDEPARAM", 0)) {
+    LOG(info) << "Alpide param updated";
+    const auto& par = o2::itsmft::DPLAlpideParam<o2::detectors::DetID::ITS>::Instance();
+    par.printKeyValues();
+    return;
+  }
+  if (matcher == ConcreteDataMatcher("GLO", "MEANVERTEX", 0)) {
+    LOGP(info, "mean vertex acquired");
+    setMeanVertex((const o2::dataformats::MeanVertexObject*)obj);
+    return;
+  }
+  if (matcher == ConcreteDataMatcher("ITS", "GEOMTGEO", 0)) {
+    LOG(info) << "ITS GeometryTGeo loaded from ccdb";
+    o2::its::GeometryTGeo::adopt((o2::its::GeometryTGeo*)obj);
+    return;
+  }
+}
+
+void ITSTrackingInterface::setTraitsFromProvider(VertexerTraits* vertexerTraits,
+                                                 TrackerTraits* trackerTraits,
+                                                 TimeFrame* frame)
+{
+  mVertexer = std::make_unique<Vertexer>(vertexerTraits);
+  mTracker = std::make_unique<Tracker>(trackerTraits);
+  mTimeFrame = frame;
+  mVertexer->adoptTimeFrame(*mTimeFrame);
+  mTracker->adoptTimeFrame(*mTimeFrame);
+}
+
+template void ITSTrackingInterface::run<true>(framework::ProcessingContext& pc);
+template void ITSTrackingInterface::run<false>(framework::ProcessingContext& pc);
+} // namespace its
+} // namespace o2
\ No newline at end of file
diff --git a/Detectors/ITSMFT/ITS/workflow/CMakeLists.txt b/Detectors/ITSMFT/ITS/workflow/CMakeLists.txt
index 785417d915..f221a41691 100644
--- a/Detectors/ITSMFT/ITS/workflow/CMakeLists.txt
+++ b/Detectors/ITSMFT/ITS/workflow/CMakeLists.txt
@@ -28,7 +28,7 @@ o2_add_library(ITSWorkflow
                        src/DCSAdaposParserWorkflow.cxx
                        src/DCSAdaposParserSpec.cxx
                        src/DCSDataGeneratorWorkflow.cxx
-           src/DCSGeneratorSpec.cxx
+                       src/DCSGeneratorSpec.cxx
          PUBLIC_LINK_LIBRARIES O2::Framework
                                O2::SimConfig
                                O2::DetectorsDCS
@@ -37,7 +37,7 @@ o2_add_library(ITSWorkflow
                                O2::DataFormatsTRD
                                O2::DataFormatsGlobalTracking
                                O2::SimulationDataFormat
-                               O2::ITStracking
+                               O2::ITSTrackingInterface
                                O2::ITSReconstruction
                                O2::ITSMFTReconstruction
                                O2::ITSMFTWorkflow
diff --git a/Detectors/ITSMFT/ITS/workflow/include/ITSWorkflow/CookedTrackerSpec.h b/Detectors/ITSMFT/ITS/workflow/include/ITSWorkflow/CookedTrackerSpec.h
index 68ef7f0c02..02e278eeed 100644
--- a/Detectors/ITSMFT/ITS/workflow/include/ITSWorkflow/CookedTrackerSpec.h
+++ b/Detectors/ITSMFT/ITS/workflow/include/ITSWorkflow/CookedTrackerSpec.h
@@ -35,7 +35,7 @@ namespace its
 class CookedTrackerDPL : public Task
 {
  public:
-  CookedTrackerDPL(std::shared_ptr<o2::base::GRPGeomRequest> gr, bool useMC, int trgType, const std::string& trMode);
+  CookedTrackerDPL(std::shared_ptr<o2::base::GRPGeomRequest> gr, bool useMC, int trgType, const TrackingMode& trMode);
   ~CookedTrackerDPL() override = default;
   void init(InitContext& ic) final;
   void run(ProcessingContext& pc) final;
@@ -51,7 +51,7 @@ class CookedTrackerDPL : public Task
   bool mUseMC = true;
   bool mRunVertexer = true;
   int mUseTriggers = 0;
-  std::string mMode = "async";
+  TrackingMode mMode = TrackingMode::Sync;
   const o2::itsmft::TopologyDictionary* mDict = nullptr;
   std::unique_ptr<o2::parameters::GRPObject> mGRP = nullptr;
   o2::its::CookedTracker mTracker;
diff --git a/Detectors/ITSMFT/ITS/workflow/include/ITSWorkflow/RecoWorkflow.h b/Detectors/ITSMFT/ITS/workflow/include/ITSWorkflow/RecoWorkflow.h
index 9106881139..7f9efa2098 100644
--- a/Detectors/ITSMFT/ITS/workflow/include/ITSWorkflow/RecoWorkflow.h
+++ b/Detectors/ITSMFT/ITS/workflow/include/ITSWorkflow/RecoWorkflow.h
@@ -16,9 +16,7 @@
 
 #include "Framework/WorkflowSpec.h"
 
-#include "GPUO2Interface.h"
-#include "GPUReconstruction.h"
-#include "GPUChainITS.h"
+#include "GPUDataTypes.h"
 
 namespace o2
 {
diff --git a/Detectors/ITSMFT/ITS/workflow/include/ITSWorkflow/TrackerSpec.h b/Detectors/ITSMFT/ITS/workflow/include/ITSWorkflow/TrackerSpec.h
index 10a9a9d7c0..643511cbfc 100644
--- a/Detectors/ITSMFT/ITS/workflow/include/ITSWorkflow/TrackerSpec.h
+++ b/Detectors/ITSMFT/ITS/workflow/include/ITSWorkflow/TrackerSpec.h
@@ -21,11 +21,7 @@
 #include "Framework/DataProcessorSpec.h"
 #include "Framework/Task.h"
 
-#include "ITStracking/TimeFrame.h"
-#include "ITStracking/Tracker.h"
-#include "ITStracking/TrackerTraits.h"
-#include "ITStracking/Vertexer.h"
-#include "ITStracking/VertexerTraits.h"
+#include "ITStracking/TrackingInterface.h"
 
 #include "GPUO2Interface.h"
 #include "GPUReconstruction.h"
@@ -45,7 +41,7 @@ class TrackerDPL : public framework::Task
   TrackerDPL(std::shared_ptr<o2::base::GRPGeomRequest> gr,
              bool isMC,
              int trgType,
-             const std::string& trModeS,
+             const TrackingMode& trMode,
              const bool overrBeamEst = false,
              o2::gpu::GPUDataTypes::DeviceType dType = o2::gpu::GPUDataTypes::DeviceType::CPU);
   ~TrackerDPL() override = default;
@@ -54,37 +50,16 @@ class TrackerDPL : public framework::Task
   void endOfStream(framework::EndOfStreamContext& ec) final;
   void finaliseCCDB(framework::ConcreteDataMatcher& matcher, void* obj) final;
   void stop() final;
-  void setClusterDictionary(const o2::itsmft::TopologyDictionary* d) { mDict = d; }
-  void setMeanVertex(const o2::dataformats::MeanVertexObject* v)
-  {
-    if (!v) {
-      return;
-    }
-    mMeanVertex = v;
-  }
 
  private:
   void updateTimeDependentParams(framework::ProcessingContext& pc);
-
-  bool mIsMC = false;
-  bool mRunVertexer = true;
-  bool mCosmicsProcessing = false;
-  int mUseTriggers = 0;
-  std::string mMode = "sync";
-  bool mOverrideBeamEstimation = false;
-  std::shared_ptr<o2::base::GRPGeomRequest> mGGCCDBRequest;
-  const o2::itsmft::TopologyDictionary* mDict = nullptr;
   std::unique_ptr<o2::gpu::GPUReconstruction> mRecChain = nullptr;
   std::unique_ptr<o2::gpu::GPUChainITS> mChainITS = nullptr;
-  std::unique_ptr<Tracker> mTracker = nullptr;
-  std::unique_ptr<Vertexer> mVertexer = nullptr;
-  TimeFrame* mTimeFrame = nullptr;
-  const o2::dataformats::MeanVertexObject* mMeanVertex;
+  std::shared_ptr<o2::base::GRPGeomRequest> mGGCCDBRequest;
+  ITSTrackingInterface mITSTrackingInterface;
   TStopwatch mTimer;
 };
 
-/// create a processor spec
-/// run ITS CA tracker
 framework::DataProcessorSpec getTrackerSpec(bool useMC, bool useGeom, int useTrig, const std::string& trModeS, const bool overrBeamEst, o2::gpu::GPUDataTypes::DeviceType dType);
 
 } // namespace its
diff --git a/Detectors/ITSMFT/ITS/workflow/src/CookedTrackerSpec.cxx b/Detectors/ITSMFT/ITS/workflow/src/CookedTrackerSpec.cxx
index 463932dc92..01e649f982 100644
--- a/Detectors/ITSMFT/ITS/workflow/src/CookedTrackerSpec.cxx
+++ b/Detectors/ITSMFT/ITS/workflow/src/CookedTrackerSpec.cxx
@@ -52,7 +52,7 @@ namespace its
 
 using Vertex = o2::dataformats::Vertex<o2::dataformats::TimeStamp<int>>;
 
-CookedTrackerDPL::CookedTrackerDPL(std::shared_ptr<o2::base::GRPGeomRequest> gr, bool useMC, int trgType, const std::string& trMode) : mGGCCDBRequest(gr), mUseMC(useMC), mUseTriggers{trgType}, mMode(trMode)
+CookedTrackerDPL::CookedTrackerDPL(std::shared_ptr<o2::base::GRPGeomRequest> gr, bool useMC, int trgType, const TrackingMode& trMode) : mGGCCDBRequest(gr), mUseMC(useMC), mUseTriggers{trgType}, mMode(trMode)
 {
   mVertexerTraitsPtr = std::make_unique<VertexerTraits>();
   mVertexerPtr = std::make_unique<Vertexer>(mVertexerTraitsPtr.get());
@@ -232,7 +232,7 @@ void CookedTrackerDPL::updateTimeDependentParams(ProcessingContext& pc)
     mTracker.setGeometry(geom);
     mTracker.setConfigParams();
     LOG(info) << "Tracking mode " << mMode;
-    if (mMode == "cosmics") {
+    if (mMode == TrackingMode::Cosmics) {
       LOG(info) << "Setting cosmics parameters...";
       mTracker.setParametersCosmics();
       mRunVertexer = false;
@@ -263,13 +263,13 @@ void CookedTrackerDPL::finaliseCCDB(ConcreteDataMatcher& matcher, void* obj)
     return;
   }
   if (matcher == ConcreteDataMatcher("ITS", "GEOMTGEO", 0)) {
-    LOG(info) << "ITS GeomtetryTGeo loaded from ccdb";
+    LOG(info) << "ITS GeometryTGeo loaded from ccdb";
     o2::its::GeometryTGeo::adopt((o2::its::GeometryTGeo*)obj);
     return;
   }
 }
 
-DataProcessorSpec getCookedTrackerSpec(bool useMC, bool useGeom, int trgType, const std::string& trMode)
+DataProcessorSpec getCookedTrackerSpec(bool useMC, bool useGeom, int trgType, const std::string& trModeS)
 {
   std::vector<InputSpec> inputs;
   inputs.emplace_back("compClusters", "ITS", "COMPCLUSTERS", 0, Lifetime::Timeframe);
@@ -312,7 +312,11 @@ DataProcessorSpec getCookedTrackerSpec(bool useMC, bool useGeom, int trgType, co
     "its-cooked-tracker",
     inputs,
     outputs,
-    AlgorithmSpec{adaptFromTask<CookedTrackerDPL>(ggRequest, useMC, trgType, trMode)},
+    AlgorithmSpec{adaptFromTask<CookedTrackerDPL>(ggRequest,
+                                                  useMC,
+                                                  trgType,
+                                                  trModeS == "sync" ? o2::its::TrackingMode::Sync : trModeS == "async" ? o2::its::TrackingMode::Async
+                                                                                                                       : o2::its::TrackingMode::Cosmics)},
     Options{{"nthreads", VariantType::Int, 1, {"Number of threads"}}}};
 }
 
diff --git a/Detectors/ITSMFT/ITS/workflow/src/RecoWorkflow.cxx b/Detectors/ITSMFT/ITS/workflow/src/RecoWorkflow.cxx
index 767651d731..dfa958ccd5 100644
--- a/Detectors/ITSMFT/ITS/workflow/src/RecoWorkflow.cxx
+++ b/Detectors/ITSMFT/ITS/workflow/src/RecoWorkflow.cxx
@@ -31,6 +31,7 @@ namespace o2
 {
 namespace its
 {
+// using ITSTrackReconstruction::TrackingMode;
 
 namespace reco_workflow
 {
@@ -64,7 +65,7 @@ framework::WorkflowSpec getWorkflow(bool useMC,
         cfg.runITSTracking = true;
         cfg.itsTriggerType = useTrig;
         cfg.itsOverrBeamEst = overrideBeamPosition;
-        cfg.itsTrackingMode = trmode == "sync" ? 0 : (trmode == "async" ? 1 : 2);
+        cfg.itsTrackingMode = trmode == "sync" ? (int)TrackingMode::Sync : (trmode == "async" ? (int)TrackingMode::Async : (int)TrackingMode::Cosmics);
 
         Inputs ggInputs;
         auto ggRequest = std::make_shared<o2::base::GRPGeomRequest>(false, true, false, true, true,
diff --git a/Detectors/ITSMFT/ITS/workflow/src/TrackerSpec.cxx b/Detectors/ITSMFT/ITS/workflow/src/TrackerSpec.cxx
index f993187546..c26bc5171d 100644
--- a/Detectors/ITSMFT/ITS/workflow/src/TrackerSpec.cxx
+++ b/Detectors/ITSMFT/ITS/workflow/src/TrackerSpec.cxx
@@ -9,39 +9,12 @@
 // granted to it by virtue of its status as an Intergovernmental Organization
 // or submit itself to any jurisdiction.
 
-/// @file   TrackerSpec.cxx
-
 #include <vector>
 
-#include "TGeoGlobalMagField.h"
-
 #include "Framework/ControlService.h"
 #include "Framework/ConfigParamRegistry.h"
 #include "Framework/CCDBParamSpec.h"
 #include "ITSWorkflow/TrackerSpec.h"
-#include "DataFormatsITSMFT/CompCluster.h"
-#include "DataFormatsITS/TrackITS.h"
-#include "SimulationDataFormat/MCCompLabel.h"
-#include "SimulationDataFormat/MCTruthContainer.h"
-#include "DataFormatsITSMFT/ROFRecord.h"
-#include "DataFormatsITSMFT/PhysTrigger.h"
-
-#include "ITStracking/ROframe.h"
-#include "ITStracking/IOUtils.h"
-#include "ITStracking/TrackingConfigParam.h"
-#include "ITSMFTBase/DPLAlpideParam.h"
-#include "ITSMFTReconstruction/ClustererParam.h"
-
-#include "Field/MagneticField.h"
-#include "DetectorsBase/GeometryManager.h"
-#include "DetectorsBase/Propagator.h"
-#include "ITSBase/GeometryTGeo.h"
-#include "CommonDataFormat/IRFrame.h"
-#include "DetectorsCommonDataFormats/DetectorNameConf.h"
-#include "DataFormatsTRD/TriggerRecord.h"
-#include "ITSReconstruction/FastMultEstConfig.h"
-#include "ITSReconstruction/FastMultEst.h"
-#include <fmt/format.h>
 
 namespace o2
 {
@@ -53,16 +26,12 @@ using Vertex = o2::dataformats::Vertex<o2::dataformats::TimeStamp<int>>;
 TrackerDPL::TrackerDPL(std::shared_ptr<o2::base::GRPGeomRequest> gr,
                        bool isMC,
                        int trgType,
-                       const std::string& trModeS,
+                       const TrackingMode& trMode,
                        const bool overrBeamEst,
                        o2::gpu::GPUDataTypes::DeviceType dType) : mGGCCDBRequest(gr),
-                                                                  mIsMC{isMC},
-                                                                  mUseTriggers{trgType},
-                                                                  mMode{trModeS},
-                                                                  mOverrideBeamEstimation{overrBeamEst},
-                                                                  mRecChain{o2::gpu::GPUReconstruction::CreateInstance(dType, true)}
+                                                                  mRecChain{o2::gpu::GPUReconstruction::CreateInstance(dType, true)},
+                                                                  mITSTrackingInterface{isMC, trgType, trMode, overrBeamEst}
 {
-  std::transform(mMode.begin(), mMode.end(), mMode.begin(), [](unsigned char c) { return std::tolower(c); });
 }
 
 void TrackerDPL::init(InitContext& ic)
@@ -71,60 +40,10 @@ void TrackerDPL::init(InitContext& ic)
   mTimer.Reset();
   o2::base::GRPGeomHelper::instance().setRequest(mGGCCDBRequest);
   mChainITS.reset(mRecChain->AddChain<o2::gpu::GPUChainITS>());
-  mVertexer = std::make_unique<Vertexer>(mChainITS->GetITSVertexerTraits());
-  mTracker = std::make_unique<Tracker>(mChainITS->GetITSTrackerTraits());
-  mTimeFrame = mChainITS->GetITSTimeframe();
-  mVertexer->adoptTimeFrame(*mTimeFrame);
-  mTracker->adoptTimeFrame(*mTimeFrame);
-  mRunVertexer = true;
-  mCosmicsProcessing = false;
-  std::vector<TrackingParameters> trackParams;
-
-  if (mMode == "async") {
-
-    trackParams.resize(3);
-    for (auto& param : trackParams) {
-      param.ZBins = 64;
-      param.PhiBins = 32;
-      param.CellsPerClusterLimit = 1.e3f;
-      param.TrackletsPerClusterLimit = 1.e3f;
-    }
-    trackParams[1].TrackletMinPt = 0.2f;
-    trackParams[1].CellDeltaTanLambdaSigma *= 2.;
-    trackParams[2].TrackletMinPt = 0.1f;
-    trackParams[2].CellDeltaTanLambdaSigma *= 4.;
-    trackParams[2].MinTrackLength = 4;
-    LOG(info) << "Initializing tracker in async. phase reconstruction with " << trackParams.size() << " passes";
-
-  } else if (mMode == "sync") {
-    trackParams.resize(1);
-    trackParams[0].ZBins = 64;
-    trackParams[0].PhiBins = 32;
-    trackParams[0].MinTrackLength = 4;
-    LOG(info) << "Initializing tracker in sync. phase reconstruction with " << trackParams.size() << " passes";
-  } else if (mMode == "cosmics") {
-    mCosmicsProcessing = true;
-    mRunVertexer = false;
-    trackParams.resize(1);
-    trackParams[0].MinTrackLength = 4;
-    trackParams[0].CellDeltaTanLambdaSigma *= 10;
-    trackParams[0].PhiBins = 4;
-    trackParams[0].ZBins = 16;
-    trackParams[0].PVres = 1.e5f;
-    trackParams[0].MaxChi2ClusterAttachment = 60.;
-    trackParams[0].MaxChi2NDF = 40.;
-    trackParams[0].TrackletsPerClusterLimit = 100.;
-    trackParams[0].CellsPerClusterLimit = 100.;
-    LOG(info) << "Initializing tracker in reconstruction for cosmics with " << trackParams.size() << " passes";
-
-  } else {
-    throw std::runtime_error(fmt::format("Unsupported ITS tracking mode {:s} ", mMode));
-  }
-
-  for (auto& params : trackParams) {
-    params.CorrType = o2::base::PropagatorImpl<float>::MatCorrType::USEMatCorrLUT;
-  }
-  mTracker->setParameters(trackParams);
+  mITSTrackingInterface.setTraitsFromProvider(mChainITS->GetITSVertexerTraits(),
+                                              mChainITS->GetITSTrackerTraits(),
+                                              mChainITS->GetITSTimeframe());
+  mITSTrackingInterface.initialise();
 }
 
 void TrackerDPL::stop()
@@ -137,255 +56,20 @@ void TrackerDPL::run(ProcessingContext& pc)
   auto cput = mTimer.CpuTime();
   auto realt = mTimer.RealTime();
   mTimer.Start(false);
-  updateTimeDependentParams(pc);
-  auto compClusters = pc.inputs().get<gsl::span<o2::itsmft::CompClusterExt>>("compClusters");
-  gsl::span<const unsigned char> patterns = pc.inputs().get<gsl::span<unsigned char>>("patterns");
-  gsl::span<const o2::itsmft::PhysTrigger> physTriggers;
-  std::vector<o2::itsmft::PhysTrigger> fromTRD;
-  if (mUseTriggers == 2) { // use TRD triggers
-    o2::InteractionRecord ir{0, pc.services().get<o2::framework::TimingInfo>().firstTForbit};
-    auto trdTriggers = pc.inputs().get<gsl::span<o2::trd::TriggerRecord>>("phystrig");
-    for (const auto& trig : trdTriggers) {
-      if (trig.getBCData() >= ir && trig.getNumberOfTracklets()) {
-        ir = trig.getBCData();
-        fromTRD.emplace_back(o2::itsmft::PhysTrigger{ir, 0});
-      }
-    }
-    physTriggers = gsl::span<const o2::itsmft::PhysTrigger>(fromTRD.data(), fromTRD.size());
-  } else if (mUseTriggers == 1) { // use Phys triggers from ITS stream
-    physTriggers = pc.inputs().get<gsl::span<o2::itsmft::PhysTrigger>>("phystrig");
-  }
-
-  auto rofsinput = pc.inputs().get<gsl::span<o2::itsmft::ROFRecord>>("ROframes");
-  auto& rofs = pc.outputs().make<std::vector<o2::itsmft::ROFRecord>>(Output{"ITS", "ITSTrackROF", 0}, rofsinput.begin(), rofsinput.end());
-  auto& irFrames = pc.outputs().make<std::vector<o2::dataformats::IRFrame>>(Output{"ITS", "IRFRAMES", 0});
-  const auto& alpParams = o2::itsmft::DPLAlpideParam<o2::detectors::DetID::ITS>::Instance(); // RS: this should come from CCDB
-
-  irFrames.reserve(rofs.size());
-  int nBCPerTF = alpParams.roFrameLengthInBC;
-
-  LOGP(info, "ITSTracker pulled {} clusters, {} RO frames", compClusters.size(), rofs.size());
-
-  const dataformats::MCTruthContainer<MCCompLabel>* labels = nullptr;
-  gsl::span<itsmft::MC2ROFRecord const> mc2rofs;
-  if (mIsMC) {
-    labels = pc.inputs().get<const dataformats::MCTruthContainer<MCCompLabel>*>("itsmclabels").release();
-    // get the array as read-only span, a snapshot is sent forward
-    pc.outputs().snapshot(Output{"ITS", "ITSTrackMC2ROF", 0}, pc.inputs().get<gsl::span<itsmft::MC2ROFRecord>>("ITSMC2ROframes"));
-    LOG(info) << labels->getIndexedSize() << " MC label objects , in " << mc2rofs.size() << " MC events";
-  }
-
-  auto& allClusIdx = pc.outputs().make<std::vector<int>>(Output{"ITS", "TRACKCLSID", 0});
-  auto& allTracks = pc.outputs().make<std::vector<o2::its::TrackITS>>(Output{"ITS", "TRACKS", 0});
-  auto& vertROFvec = pc.outputs().make<std::vector<o2::itsmft::ROFRecord>>(Output{"ITS", "VERTICESROF", 0});
-  auto& vertices = pc.outputs().make<std::vector<Vertex>>(Output{"ITS", "VERTICES", 0});
-
-  // MC
-  static pmr::vector<o2::MCCompLabel> dummyMCLabTracks, dummyMCLabVerts;
-  auto& allTrackLabels = mIsMC ? pc.outputs().make<std::vector<o2::MCCompLabel>>(Output{"ITS", "TRACKSMCTR", 0}) : dummyMCLabTracks;
-  auto& allVerticesLabels = mIsMC ? pc.outputs().make<std::vector<o2::MCCompLabel>>(Output{"ITS", "VERTICESMCTR", 0}) : dummyMCLabVerts;
-
-  std::uint32_t roFrame = 0;
-
-  bool continuous = o2::base::GRPGeomHelper::instance().getGRPECS()->isDetContinuousReadOut(o2::detectors::DetID::ITS);
-  LOG(info) << "ITSTracker RO: continuous=" << continuous;
-
-  if (mOverrideBeamEstimation) {
-    mTimeFrame->setBeamPosition(mMeanVertex->getX(),
-                                mMeanVertex->getY(),
-                                mMeanVertex->getSigmaY2(),
-                                mTracker->getParameters()[0].LayerResolution[0],
-                                mTracker->getParameters()[0].SystErrorY2[0]);
-  }
-
-  mTracker->setBz(o2::base::Propagator::Instance()->getNominalBz());
-
-  gsl::span<const unsigned char>::iterator pattIt = patterns.begin();
-
-  gsl::span<itsmft::ROFRecord> rofspan(rofs);
-  mTimeFrame->loadROFrameData(rofspan, compClusters, pattIt, mDict, labels);
-  pattIt = patterns.begin();
-  std::vector<int> savedROF;
-  auto logger = [&](std::string s) { LOG(info) << s; };
-  auto fatalLogger = [&](std::string s) { LOG(fatal) << s; };
-  auto errorLogger = [&](std::string s) { LOG(error) << s; };
-
-  FastMultEst multEst; // mult estimator
-  std::vector<bool> processingMask;
-  int cutVertexMult{0}, cutRandomMult = int(rofs.size()) - multEst.selectROFs(rofs, compClusters, physTriggers, processingMask);
-  mTimeFrame->setMultiplicityCutMask(processingMask);
-  float vertexerElapsedTime{0.f};
-  if (mRunVertexer) {
-    vertROFvec.reserve(rofs.size());
-    // Run seeding vertexer
-    vertexerElapsedTime = mVertexer->clustersToVertices(logger);
-  } else { // cosmics
-    mTimeFrame->resetRofPV();
-  }
-  const auto& multEstConf = FastMultEstConfig::Instance(); // parameters for mult estimation and cuts
-  for (auto iRof{0}; iRof < rofspan.size(); ++iRof) {
-    std::vector<Vertex> vtxVecLoc;
-    auto& vtxROF = vertROFvec.emplace_back(rofspan[iRof]);
-    vtxROF.setFirstEntry(vertices.size());
-    if (mRunVertexer) {
-      auto vtxSpan = mTimeFrame->getPrimaryVertices(iRof);
-      vtxROF.setNEntries(vtxSpan.size());
-      bool selROF = vtxSpan.size() == 0;
-      for (auto iV{0}; iV < vtxSpan.size(); ++iV) {
-        auto& v = vtxSpan[iV];
-        if (multEstConf.isVtxMultCutRequested() && !multEstConf.isPassingVtxMultCut(v.getNContributors())) {
-          continue; // skip vertex of unwanted multiplicity
-        }
-        selROF = true;
-        vertices.push_back(v);
-        if (mIsMC) {
-          auto vLabels = mTimeFrame->getPrimaryVerticesLabels(iRof)[iV];
-          allVerticesLabels.reserve(allVerticesLabels.size() + vLabels.size());
-          std::copy(vLabels.begin(), vLabels.end(), std::back_inserter(allVerticesLabels));
-        }
-      }
-      if (processingMask[iRof] && !selROF) { // passed selection in clusters and not in vertex multiplicity
-        LOG(debug) << fmt::format("ROF {} rejected by the vertex multiplicity selection [{},{}]",
-                                  iRof,
-                                  multEstConf.cutMultVtxLow,
-                                  multEstConf.cutMultVtxHigh);
-        processingMask[iRof] = selROF;
-        cutVertexMult++;
-      }
-    } else { // cosmics
-      vtxVecLoc.emplace_back(Vertex());
-      vtxVecLoc.back().setNContributors(1);
-      vtxROF.setNEntries(vtxVecLoc.size());
-      for (auto& v : vtxVecLoc) {
-        vertices.push_back(v);
-      }
-      mTimeFrame->addPrimaryVertices(vtxVecLoc);
-    }
-  }
-  LOG(info) << fmt::format(" - rejected {}/{} ROFs: random/mult.sel:{} (seed {}), vtx.sel:{}", cutRandomMult + cutVertexMult, rofspan.size(), cutRandomMult, multEst.lastRandomSeed, cutVertexMult);
-  LOG(info) << fmt::format(" - Vertex seeding total elapsed time: {} ms for {} vertices found in {} ROFs", vertexerElapsedTime, mTimeFrame->getPrimaryVerticesNum(), rofspan.size());
-
-  if (mOverrideBeamEstimation) {
-    LOG(info) << fmt::format(" - Beam position set to: {}, {} from meanvertex object", mTimeFrame->getBeamX(), mTimeFrame->getBeamY());
-  } else {
-    LOG(info) << fmt::format(" - Beam position computed for the TF: {}, {}", mTimeFrame->getBeamX(), mTimeFrame->getBeamY());
-  }
-  if (mCosmicsProcessing && compClusters.size() > 1500 * rofspan.size()) {
-    LOG(error) << "Cosmics processing was requested with an average detector occupancy exceeding 1.e-7, skipping TF processing.";
-  } else {
-
-    mTimeFrame->setMultiplicityCutMask(processingMask);
-    // Run CA tracker
-    if (mMode == "async") {
-      mTracker->clustersToTracks(logger, fatalLogger);
-    } else {
-      mTracker->clustersToTracks(logger, errorLogger);
-    }
-    size_t totTracks{mTimeFrame->getNumberOfTracks()}, totClusIDs{mTimeFrame->getNumberOfUsedClusters()};
-    allTracks.reserve(totTracks);
-    allClusIdx.reserve(totClusIDs);
-
-    if (mTimeFrame->hasBogusClusters()) {
-      LOG(warning) << fmt::format(" - The processed timeframe had {} clusters with wild z coordinates, check the dictionaries", mTimeFrame->hasBogusClusters());
-    }
-
-    for (unsigned int iROF{0}; iROF < rofs.size(); ++iROF) {
-      auto& rof{rofs[iROF]};
-      auto& tracks = mTimeFrame->getTracks(iROF);
-      auto number{tracks.size()};
-      auto first{allTracks.size()};
-      int offset = -rof.getFirstEntry(); // cluster entry!!!
-      rof.setFirstEntry(first);
-      rof.setNEntries(number);
-
-      if (processingMask[iROF]) {
-        irFrames.emplace_back(rof.getBCData(), rof.getBCData() + nBCPerTF - 1).info = tracks.size();
-      }
-      allTrackLabels.reserve(mTimeFrame->getTracksLabel(iROF).size()); // should be 0 if not MC
-      std::copy(mTimeFrame->getTracksLabel(iROF).begin(), mTimeFrame->getTracksLabel(iROF).end(), std::back_inserter(allTrackLabels));
-      // Some conversions that needs to be moved in the tracker internals
-      for (unsigned int iTrk{0}; iTrk < tracks.size(); ++iTrk) {
-        auto& trc{tracks[iTrk]};
-        trc.setFirstClusterEntry(allClusIdx.size()); // before adding tracks, create final cluster indices
-        int ncl = trc.getNumberOfClusters(), nclf = 0;
-        for (int ic = TrackITSExt::MaxClusters; ic--;) { // track internally keeps in->out cluster indices, but we want to store the references as out->in!!!
-          auto clid = trc.getClusterIndex(ic);
-          if (clid >= 0) {
-            trc.setClusterSize(ic, mTimeFrame->getClusterSize(clid));
-            allClusIdx.push_back(clid);
-            nclf++;
-          }
-        }
-        assert(ncl == nclf);
-        allTracks.emplace_back(trc);
-      }
-    }
-    LOGP(info, "ITSTracker pushed {} tracks and {} vertices", allTracks.size(), vertices.size());
-    if (mIsMC) {
-      LOGP(info, "ITSTracker pushed {} track labels", allTrackLabels.size());
-      LOGP(info, "ITSTracker pushed {} vertex labels", allVerticesLabels.size());
-    }
-  }
+  mITSTrackingInterface.updateTimeDependentParams(pc);
+  mITSTrackingInterface.run(pc);
   mTimer.Stop();
-  LOG(info) << "CPU Reconstruction time for this TF " << mTimer.CpuTime() - cput << " s (cpu), " << mTimer.RealTime() - realt << " s (wall)";
-}
-
-///_______________________________________
-void TrackerDPL::updateTimeDependentParams(ProcessingContext& pc)
-{
-  o2::base::GRPGeomHelper::instance().checkUpdates(pc);
-  static bool initOnceDone = false;
-  if (!initOnceDone) { // this params need to be queried only once
-    initOnceDone = true;
-    pc.inputs().get<o2::itsmft::TopologyDictionary*>("cldict"); // just to trigger the finaliseCCDB
-    pc.inputs().get<o2::itsmft::DPLAlpideParam<o2::detectors::DetID::ITS>*>("alppar");
-    if (pc.inputs().getPos("itsTGeo") >= 0) {
-      pc.inputs().get<o2::its::GeometryTGeo*>("itsTGeo");
-    }
-    GeometryTGeo* geom = GeometryTGeo::Instance();
-    geom->fillMatrixCache(o2::math_utils::bit2Mask(o2::math_utils::TransformType::T2L, o2::math_utils::TransformType::T2GRot, o2::math_utils::TransformType::T2G));
-    mVertexer->getGlobalConfiguration();
-    mTracker->getGlobalConfiguration();
-    if (mOverrideBeamEstimation) {
-      pc.inputs().get<o2::dataformats::MeanVertexObject*>("meanvtx");
-    }
-  }
+  LOGP(info, "CPU Reconstruction time for this TF {} s (cpu), {} s (wall)", mTimer.CpuTime() - cput, mTimer.RealTime() - realt);
 }
 
-///_______________________________________
 void TrackerDPL::finaliseCCDB(ConcreteDataMatcher& matcher, void* obj)
 {
-  if (o2::base::GRPGeomHelper::instance().finaliseCCDB(matcher, obj)) {
-    return;
-  }
-  if (matcher == ConcreteDataMatcher("ITS", "CLUSDICT", 0)) {
-    LOG(info) << "cluster dictionary updated";
-    setClusterDictionary((const o2::itsmft::TopologyDictionary*)obj);
-    return;
-  }
-  // Note: strictly speaking, for Configurable params we don't need finaliseCCDB check, the singletons are updated at the CCDB fetcher level
-  if (matcher == ConcreteDataMatcher("ITS", "ALPIDEPARAM", 0)) {
-    LOG(info) << "Alpide param updated";
-    const auto& par = o2::itsmft::DPLAlpideParam<o2::detectors::DetID::ITS>::Instance();
-    par.printKeyValues();
-    return;
-  }
-  if (matcher == ConcreteDataMatcher("GLO", "MEANVERTEX", 0)) {
-    LOGP(info, "mean vertex acquired");
-    setMeanVertex((const o2::dataformats::MeanVertexObject*)obj);
-    return;
-  }
-  if (matcher == ConcreteDataMatcher("ITS", "GEOMTGEO", 0)) {
-    LOG(info) << "ITS GeomtetryTGeo loaded from ccdb";
-    o2::its::GeometryTGeo::adopt((o2::its::GeometryTGeo*)obj);
-    return;
-  }
+  mITSTrackingInterface.finaliseCCDB(matcher, obj);
 }
 
 void TrackerDPL::endOfStream(EndOfStreamContext& ec)
 {
-  LOGF(info, "ITS CA-Tracker total timing: Cpu: %.3e Real: %.3e s in %d slots",
-       mTimer.CpuTime(), mTimer.RealTime(), mTimer.Counter() - 1);
+  LOGF(info, "ITS CA-Tracker total timing: Cpu: %.3e Real: %.3e s in %d slots", mTimer.CpuTime(), mTimer.RealTime(), mTimer.Counter() - 1);
 }
 
 DataProcessorSpec getTrackerSpec(bool useMC, bool useGeom, int trgType, const std::string& trModeS, const bool overrBeamEst, o2::gpu::GPUDataTypes::DeviceType dType)
@@ -400,8 +84,8 @@ DataProcessorSpec getTrackerSpec(bool useMC, bool useGeom, int trgType, const st
   } else if (trgType == 2) {
     inputs.emplace_back("phystrig", "TRD", "TRKTRGRD", 0, Lifetime::Timeframe);
   }
-  inputs.emplace_back("cldict", "ITS", "CLUSDICT", 0, Lifetime::Condition, ccdbParamSpec("ITS/Calib/ClusterDictionary"));
-  inputs.emplace_back("alppar", "ITS", "ALPIDEPARAM", 0, Lifetime::Condition, ccdbParamSpec("ITS/Config/AlpideParam"));
+  inputs.emplace_back("itscldict", "ITS", "CLUSDICT", 0, Lifetime::Condition, ccdbParamSpec("ITS/Calib/ClusterDictionary"));
+  inputs.emplace_back("itsalppar", "ITS", "ALPIDEPARAM", 0, Lifetime::Condition, ccdbParamSpec("ITS/Config/AlpideParam"));
   auto ggRequest = std::make_shared<o2::base::GRPGeomRequest>(false,                                                                        // orbitResetTime
                                                               true,                                                                         // GRPECS=true
                                                               false,                                                                        // GRPLHCIF
@@ -437,7 +121,13 @@ DataProcessorSpec getTrackerSpec(bool useMC, bool useGeom, int trgType, const st
     "its-tracker",
     inputs,
     outputs,
-    AlgorithmSpec{adaptFromTask<TrackerDPL>(ggRequest, useMC, trgType, trModeS, overrBeamEst, dType)},
+    AlgorithmSpec{adaptFromTask<TrackerDPL>(ggRequest,
+                                            useMC,
+                                            trgType,
+                                            trModeS == "sync" ? o2::its::TrackingMode::Sync : trModeS == "async" ? o2::its::TrackingMode::Async
+                                                                                                                 : o2::its::TrackingMode::Cosmics,
+                                            overrBeamEst,
+                                            dType)},
     Options{}};
 }
 
diff --git a/Detectors/ITSMFT/common/reconstruction/include/ITSMFTReconstruction/RawPixelDecoder.h b/Detectors/ITSMFT/common/reconstruction/include/ITSMFTReconstruction/RawPixelDecoder.h
index 0047f8311b..a6f44a984c 100644
--- a/Detectors/ITSMFT/common/reconstruction/include/ITSMFTReconstruction/RawPixelDecoder.h
+++ b/Detectors/ITSMFT/common/reconstruction/include/ITSMFTReconstruction/RawPixelDecoder.h
@@ -120,6 +120,7 @@ class RawPixelDecoder final : public PixelReader
 
   void setSkipRampUpData(bool v = true) { mSkipRampUpData = v; }
   bool getSkipRampUpData() const { return mSkipRampUpData; }
+  auto getNROFsProcessed() const { return mROFCounter; }
 
   struct LinkEntry {
     int entry = -1;
diff --git a/Detectors/ITSMFT/common/reconstruction/src/RawPixelDecoder.cxx b/Detectors/ITSMFT/common/reconstruction/src/RawPixelDecoder.cxx
index 1443744c5c..b0db826fd3 100644
--- a/Detectors/ITSMFT/common/reconstruction/src/RawPixelDecoder.cxx
+++ b/Detectors/ITSMFT/common/reconstruction/src/RawPixelDecoder.cxx
@@ -95,6 +95,8 @@ int RawPixelDecoder<Mapping>::decodeNextTrigger()
       collectROFCableData(iru);
     }
 
+    mROFCounter++;
+
     if (!doIRMajorityPoll()) {
       continue; // no links with data
     }
@@ -114,7 +116,6 @@ int RawPixelDecoder<Mapping>::decodeNextTrigger()
 
     if (mNChipsFiredROF || (mAlloEmptyROFs && mNLinksDone < mNLinksInTF)) { // fill some statistics
       mTrigger = mLinkForTriggers ? mLinkForTriggers->trigger : 0;
-      mROFCounter++;
       mNChipsFired += mNChipsFiredROF;
       mNPixelsFired += mNPixelsFiredROF;
       mCurRUDecodeID = 0; // getNextChipData will start from here
diff --git a/Detectors/ITSMFT/common/workflow/src/DeadMapBuilderSpec.cxx b/Detectors/ITSMFT/common/workflow/src/DeadMapBuilderSpec.cxx
index 3194a62d6b..362787500a 100644
--- a/Detectors/ITSMFT/common/workflow/src/DeadMapBuilderSpec.cxx
+++ b/Detectors/ITSMFT/common/workflow/src/DeadMapBuilderSpec.cxx
@@ -269,9 +269,9 @@ void ITSMFTDeadMapBuilder::PrepareOutputCcdb(EndOfStreamContext* ec, std::string
 
   if (ec != nullptr) {
 
-    LOG(info) << "Sending object " << info.getPath() << "/" << info.getFileName()
-              << "to ccdb-populator, of size " << image->size() << " bytes, valid for "
-              << info.getStartValidityTimestamp() << " : " << info.getEndValidityTimestamp();
+    LOG(important) << "Sending object " << info.getPath() << "/" << info.getFileName()
+                   << "to ccdb-populator, of size " << image->size() << " bytes, valid for "
+                   << info.getStartValidityTimestamp() << " : " << info.getEndValidityTimestamp();
 
     if (mRunMFT) {
       ec->outputs().snapshot(Output{o2::calibration::Utils::gDataOriginCDBPayload, "TimeDeadMap", 1}, *image.get());
@@ -284,9 +284,9 @@ void ITSMFTDeadMapBuilder::PrepareOutputCcdb(EndOfStreamContext* ec, std::string
 
   else if (!ccdburl.empty()) { // send from this workflow
 
-    LOG(info) << mSelfName << "sending object " << ccdburl << "/browse/" << info.getFileName()
-              << " of size " << image->size() << " bytes, valid for "
-              << info.getStartValidityTimestamp() << " : " << info.getEndValidityTimestamp();
+    LOG(important) << mSelfName << "sending object " << ccdburl << "/browse/" << info.getPath() << "/" << info.getFileName()
+                   << " of size " << image->size() << " bytes, valid for "
+                   << info.getStartValidityTimestamp() << " : " << info.getEndValidityTimestamp();
 
     o2::ccdb::CcdbApi mApi;
     mApi.init(ccdburl);
@@ -335,7 +335,7 @@ void ITSMFTDeadMapBuilder::stop()
       LOG(warning) << "endOfStream not processed. Sending output to ccdb from the " << detname << "deadmap builder workflow.";
       PrepareOutputCcdb(nullptr, mCCDBUrl);
     } else {
-      LOG(warning) << "endOfStream not processed. Nothing forwarded as output.";
+      LOG(alarm) << "endOfStream not processed. Nothing forwarded as output.";
     }
     isEnded = true;
   }
diff --git a/Detectors/ITSMFT/common/workflow/src/STFDecoderSpec.cxx b/Detectors/ITSMFT/common/workflow/src/STFDecoderSpec.cxx
index 2b80a5ffca..0e0b0dabaa 100644
--- a/Detectors/ITSMFT/common/workflow/src/STFDecoderSpec.cxx
+++ b/Detectors/ITSMFT/common/workflow/src/STFDecoderSpec.cxx
@@ -159,6 +159,7 @@ void STFDecoder<Mapping>::run(ProcessingContext& pc)
 
     mDecoder->setDecodeNextAuto(false);
     o2::InteractionRecord lastIR{}, firstIR{0, pc.services().get<o2::framework::TimingInfo>().firstTForbit};
+    int nTriggersProcessed = mDecoder->getNROFsProcessed();
     while (mDecoder->decodeNextTrigger() >= 0) {
       if ((!lastIR.isDummy() && lastIR >= mDecoder->getInteractionRecord()) || firstIR > mDecoder->getInteractionRecord()) {
         const int MaxErrLog = 2;
@@ -166,11 +167,13 @@ void STFDecoder<Mapping>::run(ProcessingContext& pc)
         if (errLocCount++ < MaxErrLog) {
           LOGP(warn, "Impossible ROF IR {}, previous was {}, TF 1st IR was {}, discarding in decoding", mDecoder->getInteractionRecord().asString(), lastIR.asString(), firstIR.asString());
         }
+        nTriggersProcessed = 0x7fffffff; // to account for a problem with event
         continue;
       }
       lastIR = mDecoder->getInteractionRecord();
-      if (mDoDigits || mClusterer->getMaxROFDepthToSquash()) { // call before clusterization, since the latter will hide the digits
+      if (mDoDigits || mClusterer->getMaxROFDepthToSquash()) {      // call before clusterization, since the latter will hide the digits
         mDecoder->fillDecodedDigits(digVec, digROFVec, chipStatus); // lot of copying involved
+
         if (mDoCalibData) {
           mDecoder->fillCalibData(calVec);
         }
@@ -181,7 +184,13 @@ void STFDecoder<Mapping>::run(ProcessingContext& pc)
         mClusterer->process(mNThreads, *mDecoder.get(), &clusCompVec, mDoPatterns ? &clusPattVec : nullptr, &clusROFVec);
       }
     }
+    nTriggersProcessed = mDecoder->getNROFsProcessed() - nTriggersProcessed - 1;
 
+    const auto& alpParams = o2::itsmft::DPLAlpideParam<o2::detectors::DetID::ITS>::Instance();
+    int expectedTFSize = static_cast<int>(o2::constants::lhc::LHCMaxBunches * o2::base::GRPGeomHelper::instance().getGRPECS()->getNHBFPerTF() / alpParams.roFrameLengthInBC); // 3564*32 / ROF Length in BS = number of ROFs per TF
+    if ((expectedTFSize != nTriggersProcessed) && mTFCounter > 1 && nTriggersProcessed > 0) {
+      LOG(error) << "Inconsistent number of ROF per TF. From parameters: " << expectedTFSize << " from readout: " << nTriggersProcessed;
+    }
     if (mDoClusters && mClusterer->getMaxROFDepthToSquash()) {
       // Digits squashing require to run on a batch of digits and uses a digit reader, cannot (?) run with decoder
       //  - Setup decoder for running on a batch of digits
diff --git a/Detectors/MUON/MCH/Align/CMakeLists.txt b/Detectors/MUON/MCH/Align/CMakeLists.txt
index 4f9c3cd7f3..15ab93353e 100644
--- a/Detectors/MUON/MCH/Align/CMakeLists.txt
+++ b/Detectors/MUON/MCH/Align/CMakeLists.txt
@@ -13,16 +13,20 @@ o2_add_library(MCHAlign
   SOURCES
     src/Aligner.cxx
     src/AlignmentSpec.cxx
+    src/AlignRecordSpec.cxx
   PUBLIC_LINK_LIBRARIES
     O2::MathUtils
     O2::CCDB
     O2::DataFormatsMCH
     O2::ForwardAlign
     O2::MCHTracking
+    O2::GlobalTracking
+    O2::GlobalTrackingWorkflow
     O2::MCHGeometryTransformer
     O2::CommonUtils
     O2::DataFormatsParameters
     O2::DetectorsBase
+    O2::DetectorsRaw
     O2::Framework
     O2::DetectorsRaw
     O2::Headers
@@ -32,7 +36,8 @@ o2_add_library(MCHAlign
 o2_target_root_dictionary(MCHAlign
   HEADERS
     include/MCHAlign/Aligner.h
-    include/MCHAlign/AlignmentSpec.h)
+    include/MCHAlign/AlignmentSpec.h
+    include/MCHAlign/AlignRecordSpec.h)
 
 o2_add_executable(
         alignment-workflow
@@ -43,5 +48,12 @@ o2_add_executable(
           O2::MCHAlign
           Boost::program_options)
 
+o2_add_executable(
+        align-record-workflow
+        SOURCES src/align-record-workflow.cxx
+        COMPONENT_NAME mch
+        PUBLIC_LINK_LIBRARIES
+          O2::MCHAlign)
+
 
 
diff --git a/Detectors/MUON/MCH/Align/include/MCHAlign/AlignRecordSpec.h b/Detectors/MUON/MCH/Align/include/MCHAlign/AlignRecordSpec.h
new file mode 100644
index 0000000000..7d4415fed0
--- /dev/null
+++ b/Detectors/MUON/MCH/Align/include/MCHAlign/AlignRecordSpec.h
@@ -0,0 +1,35 @@
+// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
+// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
+// All rights not expressly granted are reserved.
+//
+// This software is distributed under the terms of the GNU General Public
+// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
+//
+// In applying this license CERN does not waive the privileges and immunities
+// granted to it by virtue of its status as an Intergovernmental Organization
+// or submit itself to any jurisdiction.
+
+/// \file AlignRecordSpec.h
+/// \brief Definition of the process for creating alignment record during reconstruction
+///
+/// \author Chi ZHANG, CEA-Saclay, chi.zhang@cern.ch
+
+#ifndef O2_MCH_ALIGNRECORD_H_
+#define O2_MCH_ALIGNRECORD_H_
+
+#include "Framework/DataProcessorSpec.h"
+#include "ReconstructionDataFormats/GlobalTrackID.h"
+
+using GID = o2::dataformats::GlobalTrackID;
+
+namespace o2
+{
+namespace mch
+{
+
+o2::framework::DataProcessorSpec getAlignRecordSpec(bool useMC, bool disableCCDB = false);
+
+} // end namespace mch
+} // end namespace o2
+
+#endif // O2_MCH_ALIGNRECORD_H_
\ No newline at end of file
diff --git a/Detectors/MUON/MCH/Align/include/MCHAlign/Aligner.h b/Detectors/MUON/MCH/Align/include/MCHAlign/Aligner.h
index fe18c337cb..450c860dba 100644
--- a/Detectors/MUON/MCH/Align/include/MCHAlign/Aligner.h
+++ b/Detectors/MUON/MCH/Align/include/MCHAlign/Aligner.h
@@ -107,13 +107,13 @@ class Aligner : public TObject
  public:
   Aligner();
 
-  ~Aligner() = default;
+  ~Aligner();
 
   // initialize
-  void init(TString DataRecFName = "recDataFile.root", TString ConsRecFName = "recConsFile.root");
+  void init(TString DataRecFName = "millerecords.root", TString ConsRecFName = "milleconstraints.root");
 
   // terminate
-  void terminate(void);
+  void terminate();
 
   // array dimendions
   enum {
@@ -184,9 +184,7 @@ class Aligner : public TObject
     AllSides = SideTop | SideBottom | SideLeft | SideRight
   };
 
-  o2::fwdalign::MillePedeRecord* ProcessTrack(Track& track, const o2::mch::geo::TransformationCreator& transformation, Bool_t doAlignment, Double_t weight = 1);
-
-  void ProcessTrack(o2::fwdalign::MillePedeRecord*);
+  void ProcessTrack(Track& track, const o2::mch::geo::TransformationCreator& transformation, Bool_t doAlignment, Double_t weight = 1);
 
   //@name modifiers
   //@{
@@ -302,6 +300,8 @@ class Aligner : public TObject
   /// get error on a given parameter
   double GetParError(int iPar) const;
 
+  o2::fwdalign::MillePedeRecord& GetRecord() { return fTrackRecord; }
+
   void ReAlign(std::vector<o2::detectors::AlignParam>& params, std::vector<double>& misAlignments);
 
   void SetAlignmentResolution(const TClonesArray* misAlignArray, int chId, double chResX, double chResY, double deResX, double deResY);
@@ -316,6 +316,11 @@ class Aligner : public TObject
     mRead = true;
   }
 
+  void DisableRecordWriter()
+  {
+    fDisableRecordWriter = true;
+  }
+
  private:
   /// Not implemented
   Aligner(const Aligner& right);
@@ -396,9 +401,6 @@ class Aligner : public TObject
   /// Detector independent alignment class
   o2::fwdalign::MillePede2* fMillepede; // AliMillePede2 implementation
 
-  /// MCH cluster class
-  o2::mch::Cluster* fCluster;
-
   /// Number of standard deviations for chi2 cut
   int fNStdDev;
 
@@ -452,9 +454,8 @@ class Aligner : public TObject
   /// preform evaluation
   bool fDoEvaluation;
 
-  /// original local track params
-  LocalTrackParam* fTrackParamOrig;
-  LocalTrackParam* fTrackParamNew;
+  /// disable record saving
+  bool fDisableRecordWriter;
 
   LocalTrackClusterResidual* fTrkClRes;
 
diff --git a/Detectors/MUON/MCH/Align/src/AlignRecordSpec.cxx b/Detectors/MUON/MCH/Align/src/AlignRecordSpec.cxx
new file mode 100644
index 0000000000..e31968ae3d
--- /dev/null
+++ b/Detectors/MUON/MCH/Align/src/AlignRecordSpec.cxx
@@ -0,0 +1,365 @@
+// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
+// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
+// All rights not expressly granted are reserved.
+//
+// This software is distributed under the terms of the GNU General Public
+// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
+//
+// In applying this license CERN does not waive the privileges and immunities
+// granted to it by virtue of its status as an Intergovernmental Organization
+// or submit itself to any jurisdiction.
+#include <filesystem>
+
+#include "MCHAlign/AlignRecordSpec.h"
+
+#include "DataFormatsMCH/TrackMCH.h"
+#include "DataFormatsMCH/Cluster.h"
+#include "DataFormatsParameters/GRPECSObject.h"
+#include "MathUtils/Utils.h"
+#include "CCDB/BasicCCDBManager.h"
+#include "DataFormatsParameters/GRPObject.h"
+#include "DataFormatsParameters/GRPMagField.h"
+#include "DetectorsBase/GeometryManager.h"
+#include "DetectorsBase/GRPGeomHelper.h"
+#include "DetectorsBase/Propagator.h"
+#include "Framework/AnalysisDataModel.h"
+#include "Framework/ConfigParamRegistry.h"
+#include "Framework/DataProcessorSpec.h"
+#include "Framework/DataTypes.h"
+#include "Framework/TableBuilder.h"
+#include "Framework/CCDBParamSpec.h"
+#include "Framework/CallbackService.h"
+#include "Framework/Task.h"
+#include "FT0Base/Geometry.h"
+#include "GlobalTracking/MatchTOF.h"
+#include "ReconstructionDataFormats/Cascade.h"
+#include "GlobalTracking/MatchGlobalFwd.h"
+#include "MCHTracking/TrackExtrap.h"
+#include "MCHTracking/TrackFitter.h"
+#include "MCHTracking/TrackParam.h"
+#include "MCHAlign/Aligner.h"
+#include "MCHBase/TrackerParam.h"
+#include "ForwardAlign/MillePedeRecord.h"
+#include "DetectorsCommonDataFormats/AlignParam.h"
+#include "DetectorsCommonDataFormats/DetID.h"
+#include "DetectorsCommonDataFormats/DetectorNameConf.h"
+#include "MCHGeometryTransformer/Transformations.h"
+#include "ReconstructionDataFormats/GlobalFwdTrack.h"
+#include "ReconstructionDataFormats/GlobalTrackID.h"
+#include "ReconstructionDataFormats/PrimaryVertex.h"
+#include "ReconstructionDataFormats/StrangeTrack.h"
+#include "ReconstructionDataFormats/Track.h"
+#include "ReconstructionDataFormats/TrackTPCITS.h"
+#include "ReconstructionDataFormats/TrackMCHMID.h"
+
+#include <TTree.h>
+#include <TChain.h>
+
+const int fgNCh = 10;
+const int fgNDetElemCh[fgNCh] = {4, 4, 4, 4, 18, 18, 26, 26, 26, 26};
+const int fgSNDetElemCh[fgNCh + 1] = {0, 4, 8, 12, 16, 34, 52, 78, 104, 130, 156};
+
+namespace o2
+{
+namespace mch
+{
+
+using namespace o2;
+using namespace o2::framework;
+using namespace o2::framework::expressions;
+
+using namespace std;
+using std::cout;
+using std::endl;
+using DataRequest = o2::globaltracking::DataRequest;
+using GID = o2::dataformats::GlobalTrackID;
+
+class AlignRecordTask
+{
+ public:
+  //_________________________________________________________________________________________________
+  AlignRecordTask(std::shared_ptr<DataRequest> dataRequest, std::shared_ptr<base::GRPGeomRequest> ccdbRequest, bool useMC = true)
+    : mDataRequest(dataRequest), mCCDBRequest(ccdbRequest), mUseMC(useMC) {}
+
+  //_________________________________________________________________________________________________
+  void init(framework::InitContext& ic)
+  {
+
+    LOG(info) << "initializing align record maker";
+    mTrackCount = 0;
+    mTrackMatched = 0;
+    if (mCCDBRequest) {
+      base::GRPGeomHelper::instance().setRequest(mCCDBRequest);
+    } else {
+      auto grpFile = ic.options().get<std::string>("grp-file");
+      if (std::filesystem::exists(grpFile)) {
+        const auto grp = parameters::GRPObject::loadFrom(grpFile);
+        base::Propagator::initFieldFromGRP(grp);
+        TrackExtrap::setField();
+        TrackExtrap::useExtrapV2();
+        mAlign.SetBFieldOn(mch::TrackExtrap::isFieldON());
+      } else {
+        LOG(fatal) << "GRP file doesn't exist!";
+      }
+    }
+
+    // Configuration for alignment object
+    mAlign.SetDoEvaluation(false);
+    mAlign.DisableRecordWriter();
+    mAlign.SetAllowedVariation(0, 2.0);
+    mAlign.SetAllowedVariation(1, 0.3);
+    mAlign.SetAllowedVariation(2, 0.002);
+    mAlign.SetAllowedVariation(3, 2.0);
+
+    // Configuration for track fitter
+    const auto& trackerParam = TrackerParam::Instance();
+    trackFitter.setBendingVertexDispersion(trackerParam.bendingVertexDispersion);
+    trackFitter.setChamberResolution(trackerParam.chamberResolutionX, trackerParam.chamberResolutionY);
+    trackFitter.smoothTracks(true);
+    trackFitter.useChamberResolution();
+    mImproveCutChi2 = 2. * trackerParam.sigmaCutForImprovement * trackerParam.sigmaCutForImprovement;
+
+    // Configuration for chamber fixing
+    auto chambers = ic.options().get<string>("fix-chamber");
+    for (int i = 0; i < chambers.length(); ++i) {
+      if (chambers[i] == ',') {
+        continue;
+      }
+      int chamber = chambers[i] - '0';
+      LOG(info) << Form("%s%d", "Fixing chamber: ", chamber);
+      mAlign.FixChamber(chamber);
+    }
+
+    // Init for output saving
+    auto OutputRecFileName = ic.options().get<string>("output-record-data");
+    auto OutputConsFileName = ic.options().get<string>("output-record-constraint");
+    mAlign.init(OutputRecFileName, OutputConsFileName);
+
+    ic.services().get<CallbackService>().set<CallbackService::Id::Stop>([this]() {
+      LOG(info) << "Saving records into ROOT file";
+      LOG(info) << "Nb of records to be saved: " << mTrackCount;
+      LOG(info) << "Nb of matched MCH-MID tracks: " << mTrackMatched;
+      mAlign.terminate();
+    });
+  }
+
+  //_________________________________________________________________________________________________
+  void finaliseCCDB(framework::ConcreteDataMatcher& matcher, void* obj)
+  {
+    /// finalize the track extrapolation setting
+    if (mCCDBRequest && base::GRPGeomHelper::instance().finaliseCCDB(matcher, obj)) {
+      if (matcher == framework::ConcreteDataMatcher("GLO", "GRPMAGFIELD", 0)) {
+        TrackExtrap::setField();
+        TrackExtrap::useExtrapV2();
+        mAlign.SetBFieldOn(mch::TrackExtrap::isFieldON());
+      }
+
+      if (matcher == framework::ConcreteDataMatcher("GLO", "GEOMALIGN", 0)) {
+        LOG(info) << "Loading reference geometry from CCDB";
+        transformation = geo::transformationFromTGeoManager(*gGeoManager);
+        for (int i = 0; i < 156; i++) {
+          int iDEN = GetDetElemId(i);
+          transform[iDEN] = transformation(iDEN);
+        }
+      }
+    }
+  }
+
+  //_________________________________________________________________________________________________
+  void run(framework::ProcessingContext& pc)
+  {
+    if (mCCDBRequest) {
+      base::GRPGeomHelper::instance().checkUpdates(pc);
+    }
+
+    o2::globaltracking::RecoContainer recoData;
+    recoData.collectData(pc, *mDataRequest.get());
+
+    const auto& mchTracks = recoData.getMCHTracks();
+    const auto& mchmidMatches = recoData.getMCHMIDMatches();
+    const auto& mchClusters = recoData.getMCHTrackClusters();
+    mTrackMatched += mchmidMatches.size();
+
+    for (auto const& mchmidMatch : mchmidMatches) {
+
+      int mchTrackID = mchmidMatch.getMCHRef().getIndex();
+      const auto& mchTrack = mchTracks[mchTrackID];
+      int first = mchTrack.getFirstClusterIdx();
+      int last = mchTrack.getLastClusterIdx();
+      int Ncluster = last - first + 1;
+
+      if (Ncluster <= 9) {
+        continue;
+      }
+
+      mch::Track convertedTrack;
+
+      for (int i = first; i <= last; i++) {
+        const auto& cluster = mchClusters[i];
+        convertedTrack.createParamAtCluster(cluster);
+      }
+
+      // Erase removable track
+      if (!RemoveTrack(convertedTrack)) {
+        mAlign.ProcessTrack(convertedTrack, transformation, false, weightRecord);
+        mTrackCount += 1;
+        pc.outputs().snapshot(Output{"MUON", "RECORD_MCHMID", 0}, mAlign.GetRecord());
+      }
+    }
+  }
+
+ private:
+  //_________________________________________________________________________________________________
+  bool RemoveTrack(mch::Track& track)
+  {
+    bool removeTrack = false;
+
+    try {
+      trackFitter.fit(track, false);
+    } catch (exception const& e) {
+      removeTrack = true;
+      return removeTrack;
+    }
+
+    auto itStartingParam = std::prev(track.rend());
+
+    while (true) {
+      try {
+        trackFitter.fit(track, true, false, (itStartingParam == track.rbegin()) ? nullptr : &itStartingParam);
+      } catch (exception const&) {
+        removeTrack = true;
+        break;
+      }
+
+      double worstLocalChi2 = -1.0;
+
+      track.tagRemovableClusters(0x1F, false);
+      auto itWorstParam = track.end();
+
+      for (auto itParam = track.begin(); itParam != track.end(); ++itParam) {
+        if (itParam->getLocalChi2() > worstLocalChi2) {
+          worstLocalChi2 = itParam->getLocalChi2();
+          itWorstParam = itParam;
+        }
+      }
+
+      if (worstLocalChi2 < mImproveCutChi2) {
+        break;
+      }
+
+      if (!itWorstParam->isRemovable()) {
+        removeTrack = true;
+        track.removable();
+        break;
+      }
+
+      auto itNextParam = track.removeParamAtCluster(itWorstParam);
+      auto itNextToNextParam = (itNextParam == track.end()) ? itNextParam : std::next(itNextParam);
+      itStartingParam = track.rbegin();
+
+      if (track.getNClusters() < 10) {
+        removeTrack = true;
+        break;
+      } else {
+        while (itNextToNextParam != track.end()) {
+          if (itNextToNextParam->getClusterPtr()->getChamberId() != itNextParam->getClusterPtr()->getChamberId()) {
+            itStartingParam = std::make_reverse_iterator(++itNextParam);
+            break;
+          }
+          ++itNextToNextParam;
+        }
+      }
+    }
+
+    if (!removeTrack) {
+      for (auto& param : track) {
+        param.setParameters(param.getSmoothParameters());
+        param.setCovariances(param.getSmoothCovariances());
+      }
+    }
+
+    return removeTrack;
+  }
+
+  //_________________________________________________________________________________________________
+  Int_t GetDetElemId(Int_t iDetElemNumber)
+  {
+    // make sure detector number is valid
+    if (!(iDetElemNumber >= fgSNDetElemCh[0] &&
+          iDetElemNumber < fgSNDetElemCh[fgNCh])) {
+      LOG(fatal) << "Invalid detector element number: " << iDetElemNumber;
+    }
+    /// get det element number from ID
+    // get chamber and element number in chamber
+    int iCh = 0;
+    int iDet = 0;
+    for (int i = 1; i <= fgNCh; i++) {
+      if (iDetElemNumber < fgSNDetElemCh[i]) {
+        iCh = i;
+        iDet = iDetElemNumber - fgSNDetElemCh[i - 1];
+        break;
+      }
+    }
+
+    // make sure detector index is valid
+    if (!(iCh > 0 && iCh <= fgNCh && iDet < fgNDetElemCh[iCh - 1])) {
+      LOG(fatal) << "Invalid detector element id: " << 100 * iCh + iDet;
+    }
+
+    // add number of detectors up to this chamber
+    return 100 * iCh + iDet;
+  }
+
+  std::shared_ptr<base::GRPGeomRequest> mCCDBRequest; ///< pointer to the CCDB requests
+  std::shared_ptr<DataRequest> mDataRequest;
+  GID::mask_t mInputSources;
+  bool mUseMC = true;
+  parameters::GRPMagField* grpmag;
+  TGeoManager* geo;
+
+  mch::TrackFitter trackFitter;
+  double mImproveCutChi2{};
+  int mTrackCount{};
+  int mTrackMatched{};
+  mch::Aligner mAlign{};
+  Double_t weightRecord{1.0};
+  std::vector<o2::fwdalign::MillePedeRecord> mRecords;
+
+  map<int, math_utils::Transform3D> transform;
+  mch::geo::TransformationCreator transformation;
+};
+
+//_________________________________________________________________________________________________
+o2::framework::DataProcessorSpec getAlignRecordSpec(bool useMC, bool disableCCDB)
+{
+  auto dataRequest = std::make_shared<DataRequest>();
+  o2::dataformats::GlobalTrackID::mask_t src = o2::dataformats::GlobalTrackID::getSourcesMask("MCH-MID");
+  dataRequest->requestMCHClusters(false);
+  dataRequest->requestTracks(src, useMC);
+
+  vector<OutputSpec> outputSpecs{};
+  auto ccdbRequest = disableCCDB ? nullptr : std::make_shared<base::GRPGeomRequest>(false,                         // orbitResetTime
+                                                                                    false,                         // GRPECS=true
+                                                                                    false,                         // GRPLHCIF
+                                                                                    true,                          // GRPMagField
+                                                                                    false,                         // askMatLUT
+                                                                                    base::GRPGeomRequest::Aligned, // geometry
+                                                                                    dataRequest->inputs,
+                                                                                    true); // query only once all objects except mag.field
+
+  outputSpecs.emplace_back("MUON", "RECORD_MCHMID", 0, Lifetime::Sporadic);
+
+  return DataProcessorSpec{
+    "mch-align-record",
+    dataRequest->inputs,
+    outputSpecs,
+    AlgorithmSpec{adaptFromTask<AlignRecordTask>(dataRequest, ccdbRequest, useMC)},
+    Options{{"geo-file", VariantType::String, o2::base::NameConf::getAlignedGeomFileName(), {"Name of the reference geometry file"}},
+            {"grp-file", VariantType::String, o2::base::NameConf::getGRPFileName(), {"Name of the grp file"}},
+            {"fix-chamber", VariantType::String, "", {"Chamber fixing, ex 1,2,3"}},
+            {"output-record-data", VariantType::String, "recDataFile.root", {"Option for name of output record file for data"}},
+            {"output-record-constraint", VariantType::String, "recConsFile.root", {"Option for name of output record file for constraint"}}}};
+}
+
+} // namespace mch
+} // namespace o2
\ No newline at end of file
diff --git a/Detectors/MUON/MCH/Align/src/Aligner.cxx b/Detectors/MUON/MCH/Align/src/Aligner.cxx
index 39a00cdd89..71bafad5b9 100644
--- a/Detectors/MUON/MCH/Align/src/Aligner.cxx
+++ b/Detectors/MUON/MCH/Align/src/Aligner.cxx
@@ -29,6 +29,7 @@
 #include "ForwardAlign/MillePedeRecord.h"
 #include "Framework/Logger.h"
 #include "MCHAlign/Aligner.h"
+#include "MathUtils/Cartesian.h"
 #include "MCHTracking/Track.h"
 #include "MCHTracking/TrackParam.h"
 #include "MCHGeometryTransformer/Transformations.h"
@@ -131,8 +132,7 @@ Aligner::Aligner()
     fStartFac(65536),
     fResCutInitial(1000),
     fResCut(100),
-    fMillepede(nullptr), // to be modified
-    fCluster(nullptr),
+    fMillepede(nullptr),
     fNStdDev(3),
     fDetElemNumber(0),
     fGlobalParameterStatus(std::vector<int>(fNGlobal)),
@@ -147,11 +147,9 @@ Aligner::Aligner()
     mWithConstraintsRecReader(false),
     mConstraintsRecReader(nullptr),
     fTransformCreator(),
-    // fGeoCombiTransInverse(),
     fDoEvaluation(false),
+    fDisableRecordWriter(false),
     mRead(false),
-    fTrackParamOrig(nullptr),
-    fTrackParamNew(nullptr),
     fTrkClRes(nullptr),
     fTFile(nullptr),
     fTTree(nullptr)
@@ -185,6 +183,14 @@ Aligner::Aligner()
   }
 }
 
+//________________________________________________________________________
+Aligner::~Aligner()
+{
+  delete mRecordWriter;
+  delete mRecordReader;
+  delete fMillepede;
+}
+
 //_____________________________________________________________________
 void Aligner::init(TString DataRecFName, TString ConsRecFName)
 {
@@ -200,15 +206,18 @@ void Aligner::init(TString DataRecFName, TString ConsRecFName)
   }
 
   if (!mRead) {
-
-    mRecordWriter->setCyclicAutoSave(mNEntriesAutoSave);
-    mRecordWriter->setDataFileName(DataRecFName);
-    fMillepede->SetRecordWriter(mRecordWriter);
-
-    if (mWithConstraintsRecWriter) {
-      mConstraintsRecWriter->setCyclicAutoSave(mNEntriesAutoSave);
-      mConstraintsRecWriter->setDataFileName(ConsRecFName);
-      fMillepede->SetConstraintsRecWriter(mConstraintsRecWriter);
+    if (!fDisableRecordWriter) {
+      mRecordWriter->setCyclicAutoSave(mNEntriesAutoSave);
+      mRecordWriter->setDataFileName(DataRecFName);
+      fMillepede->SetRecordWriter(mRecordWriter);
+
+      if (mWithConstraintsRecWriter) {
+        mConstraintsRecWriter->setCyclicAutoSave(mNEntriesAutoSave);
+        mConstraintsRecWriter->setDataFileName(ConsRecFName);
+        fMillepede->SetConstraintsRecWriter(mConstraintsRecWriter);
+      }
+    } else {
+      fMillepede->SetRecord(&fTrackRecord);
     }
 
   } else {
@@ -283,7 +292,11 @@ void Aligner::init(TString DataRecFName, TString ConsRecFName)
   fMillepede->InitMille(fNGlobal, fNLocal, fNStdDev, fResCut, fResCutInitial, fGlobalParameterStatus);
 
   if (!mRead) {
-    mRecordWriter->init();
+    if (!fDisableRecordWriter) {
+      mRecordWriter->init();
+    } else {
+      fMillepede->DisableRecordWriter();
+    }
   }
 
   fInitialized = true;
@@ -315,12 +328,6 @@ void Aligner::init(TString DataRecFName, TString ConsRecFName)
     const int kSplitlevel = 98;
     const int kBufsize = 32000;
 
-    // fTrackParamOrig = new LocalTrackParam();
-    // fTTree->Branch("fTrackParamOrig", "LocalTrackParam", &fTrackParamOrig, kBufsize, kSplitlevel);
-
-    // fTrackParamNew = new LocalTrackParam();
-    // fTTree->Branch("fTrackParamNew", "LocalTrackParam", &fTrackParamNew, kBufsize, kSplitlevel);
-
     fTrkClRes = new o2::mch::LocalTrackClusterResidual();
     fTTree->Branch("fClDetElem", &(fTrkClRes->fClDetElem), "fClDetElem/I");
     fTTree->Branch("fClDetElemNumber", &(fTrkClRes->fClDetElemNumber), "fClDetElemNumber/I");
@@ -351,24 +358,24 @@ void Aligner::init(TString DataRecFName, TString ConsRecFName)
 //_____________________________________________________
 void Aligner::terminate()
 {
-  mRecordWriter->terminate();
   fInitialized = kFALSE;
   LOG(info) << "Closing Evaluation TFile";
-  if (fTFile && fTTree) {
-    fTFile->cd();
-    fTTree->Write();
-    fTFile->Close();
+  if (fDoEvaluation) {
+    if (fTFile && fTTree) {
+      fTFile->cd();
+      fTTree->Write();
+      fTFile->Close();
+    }
   }
 }
 
 //_____________________________________________________
-o2::fwdalign::MillePedeRecord* Aligner::ProcessTrack(Track& track, const o2::mch::geo::TransformationCreator& transformation, bool doAlignment, double weight)
+void Aligner::ProcessTrack(Track& track, const o2::mch::geo::TransformationCreator& transformation, bool doAlignment, double weight)
 {
 
   /// process track for alignment minimization
-
   // reset track records
-  fTrackRecord.Reset();
+
   if (fMillepede->GetRecord()) {
     fMillepede->GetRecord()->Reset();
   }
@@ -436,8 +443,7 @@ o2::fwdalign::MillePedeRecord* Aligner::ProcessTrack(Track& track, const o2::mch
 
     // 'inverse' (GlobalToLocal) rotation matrix
     // const double* r(fGeoCombiTransInverse.GetRotationMatrix());
-
-    auto trans = transformation(cluster->getDEId());
+    o2::math_utils::Transform3D trans = transformation(cluster->getDEId());
     // LOG(info) << Form("cluster ID: %i", cluster->getDEId());
     TMatrixD transMat(3, 4);
     trans.GetTransformMatrix(transMat);
@@ -455,7 +461,6 @@ o2::fwdalign::MillePedeRecord* Aligner::ProcessTrack(Track& track, const o2::mch
     r[9] = transMat(0, 3);
     r[10] = transMat(1, 3);
     r[11] = transMat(2, 3);
-
     // calculate measurements
     if (fBFieldOn) {
 
@@ -529,42 +534,17 @@ o2::fwdalign::MillePedeRecord* Aligner::ProcessTrack(Track& track, const o2::mch
   }
 
   // copy track record
-  mRecordWriter->setRecordRun(fRunNumber);
-  mRecordWriter->setRecordWeight(weight);
-  fTrackRecord = *fMillepede->GetRecord();
+  if (!fDisableRecordWriter) {
+    mRecordWriter->setRecordRun(fRunNumber);
+    mRecordWriter->setRecordWeight(weight);
+  }
 
   // save record data
   if (doAlignment) {
-    mRecordWriter->fillRecordTree();
-  }
-
-  // return record
-  return &fTrackRecord;
-}
-
-//______________________________________________________________________________
-void Aligner::ProcessTrack(o2::fwdalign::MillePedeRecord* trackRecord)
-{
-  LOG(fatal) << __PRETTY_FUNCTION__ << " is disabled";
-
-  /// process track record
-  if (!trackRecord) {
-    return;
-  }
-
-  // // make sure record storage is initialized
-  if (!fMillepede->GetRecord()) {
-    mRecordWriter->init();
+    if (!fDisableRecordWriter) {
+      mRecordWriter->fillRecordTree();
+    }
   }
-  // // copy content
-  *fMillepede->GetRecord() = *trackRecord;
-
-  // save record
-  mRecordWriter->fillRecordTree();
-  // write to local file
-  // mRecordWriter->terminate();
-
-  return;
 }
 
 //_____________________________________________________________________
diff --git a/Detectors/MUON/MCH/Align/src/AlignmentSpec.cxx b/Detectors/MUON/MCH/Align/src/AlignmentSpec.cxx
index 2d50a8235b..6a3ed06a6b 100644
--- a/Detectors/MUON/MCH/Align/src/AlignmentSpec.cxx
+++ b/Detectors/MUON/MCH/Align/src/AlignmentSpec.cxx
@@ -74,6 +74,7 @@
 #include "MCHTracking/TrackExtrap.h"
 #include "MCHTracking/TrackParam.h"
 #include "MCHTracking/TrackFitter.h"
+#include "MCHBase/TrackerParam.h"
 #include "ReconstructionDataFormats/TrackMCHMID.h"
 
 namespace o2
@@ -88,15 +89,6 @@ using namespace o2;
 class AlignmentTask
 {
  public:
-  double Reso_X{0.4};
-  double Reso_Y{0.4};
-  double ImproveCut{6.0};
-
-  int tracksGood = 0;
-  int tracksGoodwithoutFit = 0;
-  int tracksAll = 0;
-  int trackMCHMID = 0;
-
   const int fgNDetElemCh[10] = {4, 4, 4, 4, 18, 18, 26, 26, 26, 26};
   const int fgSNDetElemCh[11] = {0, 4, 8, 12, 16, 34, 52, 78, 104, 130, 156};
   const int fgNDetElemHalfCh[20] = {2, 2, 2, 2, 2, 2, 2, 2, 9,
@@ -170,22 +162,6 @@ class AlignmentTask
       LOG(info) << "Re-alignment mode";
     }
 
-    auto param_config = ic.options().get<string>("fitter-config");
-    if (param_config == "PbPb") {
-      Reso_X = 0.2;
-      Reso_Y = 0.2;
-      ImproveCut = 4.0;
-      LOG(info) << "Using PbPb parameter set for TrackFitter";
-    } else if (param_config == "pp") {
-      Reso_X = 0.4;
-      Reso_Y = 0.4;
-      ImproveCut = 6.0;
-      LOG(info) << "Using pp parameter set for TrackFitter";
-    } else {
-      LOG(fatal) << "Please enter a correct parameter configuration option";
-      exit(-1);
-    }
-
     if (mCCDBRequest) {
       LOG(info) << "Loading magnetic field and reference geometry from CCDB";
       base::GRPGeomHelper::instance().setRequest(mCCDBRequest);
@@ -229,17 +205,22 @@ class AlignmentTask
       }
     }
 
-    trackFitter.smoothTracks(true);
-    trackFitter.setChamberResolution(Reso_X, Reso_Y);
-    trackFitter.useChamberResolution();
-
-    mAlign.SetDoEvaluation(true);
+    auto doEvaluation = ic.options().get<bool>("do-evaluation");
+    mAlign.SetDoEvaluation(doEvaluation);
     // Variation range for parameters
     mAlign.SetAllowedVariation(0, 2.0);
     mAlign.SetAllowedVariation(1, 0.3);
     mAlign.SetAllowedVariation(2, 0.002);
     mAlign.SetAllowedVariation(3, 2.0);
 
+    // Configuration for track fitter
+    const auto& trackerParam = TrackerParam::Instance();
+    trackFitter.setBendingVertexDispersion(trackerParam.bendingVertexDispersion);
+    trackFitter.setChamberResolution(trackerParam.chamberResolutionX, trackerParam.chamberResolutionY);
+    trackFitter.smoothTracks(true);
+    trackFitter.useChamberResolution();
+    mImproveCutChi2 = 2. * trackerParam.sigmaCutForImprovement * trackerParam.sigmaCutForImprovement;
+
     // Fix chambers
     auto chambers = ic.options().get<string>("fix-chamber");
     for (int i = 0; i < chambers.length(); ++i) {
@@ -298,12 +279,10 @@ class AlignmentTask
 
       for (int iMCHTrack = mchROF.getFirstIdx();
            iMCHTrack <= mchROF.getLastIdx(); ++iMCHTrack) {
-        tracksAll += 1;
         // MCH-MID matching
         if (!FindMuon(iMCHTrack, muonTracks)) {
           continue;
         }
-        trackMCHMID += 1;
 
         auto mchTrack = mchTracks.at(iMCHTrack);
         int id_track = iMCHTrack;
@@ -313,21 +292,17 @@ class AlignmentTask
         if (nb_clusters <= 9) {
           continue;
         }
-        tracksGoodwithoutFit += 1;
 
         // Format conversion from TrackMCH to Track(MCH internal use)
         mch::Track convertedTrack = MCHFormatConvert(mchTrack, mchClusters, doReAlign);
 
         // Erase removable track
-        if (RemoveTrack(convertedTrack, ImproveCut)) {
+        if (RemoveTrack(convertedTrack)) {
           continue;
-        } else {
-          tracksGood += 1;
         }
 
         //  Track processing, saving residuals
-        o2::fwdalign::MillePedeRecord* mchRecord = mAlign.ProcessTrack(convertedTrack, transformation,
-                                                                       doAlign, weightRecord);
+        mAlign.ProcessTrack(convertedTrack, transformation, doAlign, weightRecord);
       }
     }
   }
@@ -345,27 +320,22 @@ class AlignmentTask
         auto mchTrack = mchTracks.at(iMCHTrack);
         int id_track = iMCHTrack;
         int nb_clusters = mchTrack.getNClusters();
-        tracksAll += 1;
 
         // Track selection, saving only tracks having exactly 10 clusters
         if (nb_clusters <= 9) {
           continue;
         }
-        tracksGoodwithoutFit += 1;
 
         // Format conversion from TrackMCH to Track(MCH internal use)
         Track convertedTrack = MCHFormatConvert(mchTrack, mchClusters, doReAlign);
 
         // Erase removable track
-        if (RemoveTrack(convertedTrack, ImproveCut)) {
+        if (RemoveTrack(convertedTrack)) {
           continue;
-        } else {
-          tracksGood += 1;
         }
 
         //  Track processing, saving residuals
-        o2::fwdalign::MillePedeRecord* mchRecord = mAlign.ProcessTrack(convertedTrack, transformation,
-                                                                       doAlign, weightRecord);
+        mAlign.ProcessTrack(convertedTrack, transformation, doAlign, weightRecord);
       }
     }
   }
@@ -445,14 +415,6 @@ class AlignmentTask
     }
     auto tEnd = std::chrono::high_resolution_clock::now();
     mElapsedTime = tEnd - tStart;
-    // Evaluation for track removing and selection
-    LOG(info) << Form("%s%d", "Number of good tracks used in alignment process: ", tracksGood);
-    LOG(info) << Form("%s%d", "Number of good tracks without fit processing: ", tracksGoodwithoutFit);
-    LOG(info) << Form("%s%d", "Number of MCH-MID tracks: ", trackMCHMID);
-    LOG(info) << Form("%s%d", "Total number of tracks loaded: ", tracksAll);
-    LOG(info) << Form("%s%f", "Ratio of MCH-MID track: ", double(trackMCHMID) / tracksAll);
-    LOG(info) << Form("%s%f", "Ratio before fit: ", double(tracksGoodwithoutFit) / tracksAll);
-    LOG(info) << Form("%s%f", "Ratio after fit: ", double(tracksGood) / tracksAll);
 
     // Generate new geometry w.r.t alignment results
     if (doAlign) {
@@ -573,10 +535,9 @@ class AlignmentTask
   }
 
   //_________________________________________________________________________________________________
-  bool RemoveTrack(Track& track, double ImproveCut)
+  bool RemoveTrack(Track& track)
   {
 
-    double maxChi2Cluster = 2 * ImproveCut * ImproveCut;
     bool removeTrack = false;
 
     try {
@@ -610,7 +571,7 @@ class AlignmentTask
         }
       }
 
-      if (worstLocalChi2 < maxChi2Cluster) {
+      if (worstLocalChi2 < mImproveCutChi2) {
         break;
       }
 
@@ -905,6 +866,7 @@ class AlignmentTask
 
   geo::TransformationCreator transformation{};
   TrackFitter trackFitter{};
+  double mImproveCutChi2{};
 
   std::chrono::duration<double> mElapsedTime{};
 };
@@ -933,8 +895,8 @@ o2::framework::DataProcessorSpec getAlignmentSpec(bool disableCCDB)
     Options{{"geo-file-ref", VariantType::String, o2::base::NameConf::getAlignedGeomFileName(), {"Name of the reference geometry file"}},
             {"geo-file-ideal", VariantType::String, o2::base::NameConf::getGeomFileName(), {"Name of the ideal geometry file"}},
             {"grp-file", VariantType::String, o2::base::NameConf::getGRPFileName(), {"Name of the grp file"}},
-            {"fitter-config", VariantType::String, "", {"Option of parameter set for TrackFitter, pp or PbPb"}},
             {"do-align", VariantType::Bool, false, {"Switch for alignment, otherwise only residuals will be stored"}},
+            {"do-evaluation", VariantType::Bool, false, {"Option for saving residuals for evaluation"}},
             {"do-realign", VariantType::Bool, false, {"Switch for re-alignment using another geometry"}},
             {"matched", VariantType::Bool, false, {"Switch for using MCH-MID matched tracks"}},
             {"fix-chamber", VariantType::String, "", {"Chamber fixing, ex 1,2,3"}},
diff --git a/Detectors/MUON/MCH/Align/src/align-record-workflow.cxx b/Detectors/MUON/MCH/Align/src/align-record-workflow.cxx
new file mode 100644
index 0000000000..5640fcfb20
--- /dev/null
+++ b/Detectors/MUON/MCH/Align/src/align-record-workflow.cxx
@@ -0,0 +1,76 @@
+// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
+// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
+// All rights not expressly granted are reserved.
+//
+// This software is distributed under the terms of the GNU General Public
+// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
+//
+// In applying this license CERN does not waive the privileges and immunities
+// granted to it by virtue of its status as an Intergovernmental Organization
+// or submit itself to any jurisdiction.
+
+/// \file align-record-workflow.cxx
+/// \brief Implementation of a DPL device to create MillePede record for muon alignment
+///
+/// \author Chi ZHANG, CEA-Saclay, chi.zhang@cern.ch
+
+#include "MCHAlign/AlignRecordSpec.h"
+
+#include "Framework/CompletionPolicy.h"
+#include "ReconstructionDataFormats/GlobalTrackID.h"
+#include "CommonUtils/ConfigurableParam.h"
+#include "GlobalTrackingWorkflowHelpers/InputHelper.h"
+#include "DetectorsRaw/HBFUtilsInitializer.h"
+#include "Framework/CallbacksPolicy.h"
+#include "ForwardAlign/MilleRecordWriterSpec.h"
+
+using namespace o2::framework;
+using namespace std;
+
+using GID = o2::dataformats::GlobalTrackID;
+
+void customize(std::vector<o2::framework::CallbacksPolicy>& policies)
+{
+  o2::raw::HBFUtilsInitializer::addNewTimeSliceCallback(policies);
+}
+
+void customize(std::vector<ConfigParamSpec>& workflowOptions)
+{
+  // option allowing to set parameters
+  std::vector<o2::framework::ConfigParamSpec> options{
+    {"disable-mc", o2::framework::VariantType::Bool, false, {"disable MC propagation"}},
+    {"disable-root-input", o2::framework::VariantType::Bool, false, {"disable root-files input reader"}},
+    {"disable-root-output", o2::framework::VariantType::Bool, false, {"do not write output root files"}},
+    {"disable-ccdb", VariantType::Bool, false, {"disable input files from CCDB"}},
+    {"configKeyValues", VariantType::String, "", {"Semicolon separated key=value strings ..."}}};
+  o2::raw::HBFUtilsInitializer::addConfigOption(options);
+  std::swap(workflowOptions, options);
+}
+
+#include "Framework/runDataProcessing.h"
+WorkflowSpec defineDataProcessing(const ConfigContext& configcontext)
+{
+  o2::conf::ConfigurableParam::updateFromString(configcontext.options().get<std::string>("configKeyValues"));
+  o2::conf::ConfigurableParam::writeINI("o2mchalignrecord-workflow_configuration.ini");
+
+  auto useMC = !configcontext.options().get<bool>("disable-mc");
+  bool disableCCDB = configcontext.options().get<bool>("disable-ccdb");
+  bool disableRootOutput = configcontext.options().get<bool>("disable-root-output");
+
+  WorkflowSpec specs;
+  specs.emplace_back(o2::mch::getAlignRecordSpec(useMC, disableCCDB));
+  auto srcTracks = GID::getSourcesMask("MCH");
+  auto srcClusters = GID::getSourcesMask("MCH");
+  auto matchMask = GID::getSourcesMask("MCH-MID");
+
+  if (!disableRootOutput) {
+    specs.emplace_back(o2::fwdalign::getMilleRecordWriterSpec(useMC));
+  }
+
+  o2::globaltracking::InputHelper::addInputSpecs(configcontext, specs, srcClusters, matchMask, srcTracks, useMC, srcClusters, srcTracks);
+
+  // configure dpl timer to inject correct firstTForbit: start from the 1st orbit of TF containing 1st sampled orbit
+  o2::raw::HBFUtilsInitializer hbfIni(configcontext, specs);
+
+  return std::move(specs);
+}
\ No newline at end of file
diff --git a/Detectors/MUON/MCH/Status/include/MCHStatus/StatusMap.h b/Detectors/MUON/MCH/Status/include/MCHStatus/StatusMap.h
index 8d082f9fe3..7e7bb70758 100644
--- a/Detectors/MUON/MCH/Status/include/MCHStatus/StatusMap.h
+++ b/Detectors/MUON/MCH/Status/include/MCHStatus/StatusMap.h
@@ -13,6 +13,8 @@
 #define O2_MCH_CONDITIONS_STATUSMAP_H
 
 #include "MCHGlobalMapping/ChannelCode.h"
+#include "MCHGlobalMapping/DsIndex.h"
+#include "MCHRawElecMap/DsDetId.h"
 #include "DataFormatsMCH/DsChannelId.h"
 #include <cstdint>
 #include <gsl/span>
@@ -29,12 +31,13 @@ namespace o2::mch
  * Each potentially bad channel is ascribed a 32-bits mask that indicate
  * the source of information used to incriminate it.
  *
- * So far only two sources exist :
+ * So far only three sources exist :
  * - kBadPedestal : the list generated at each pedestal run at Pt2
  * - kRejectList : a (manual) list
+ * - kBadHV : the list derived from the DCS HV values
  *
  * In the future (based on our experience during Run1,2), we'll most probably
- * need to add information from the DCS HV (and possibly LV) values as well.
+ * need to add information from the DCS LV values as well.
  *
  */
 class StatusMap
@@ -43,7 +46,8 @@ class StatusMap
   enum Status : uint32_t {
     kOK = 0,
     kBadPedestal = 1 << 0,
-    kRejectList = 1 << 1
+    kRejectList = 1 << 1,
+    kBadHV = 1 << 2
   };
 
   using iterator = std::map<ChannelCode, uint32_t>::iterator;
@@ -67,6 +71,24 @@ class StatusMap
    */
   void add(gsl::span<const ChannelCode> badchannels, uint32_t mask);
 
+  /** add all the channels of the badDS referenced using DsIndex
+   * to this status map, assigning them the corresponding mask.
+   * @throw runtime_error if the mask is invalid
+   */
+  void addDS(DsIndex badDS, uint32_t mask);
+
+  /** add all the channels of the badDS referenced using DsDetId
+   * to this status map, assigning them the corresponding mask.
+   * @throw runtime_error if the mask is invalid
+   */
+  void addDS(raw::DsDetId badDS, uint32_t mask);
+
+  /** add all the channels of the badDE referenced using DE Id
+   * to this status map, assigning them the corresponding mask.
+   * @throw runtime_error if the mask is invalid
+   */
+  void addDE(uint16_t badDE, uint32_t mask);
+
   /** whether or not this statusmap contains no (potentially) bad channels */
   bool empty() const { return mStatus.empty(); }
 
diff --git a/Detectors/MUON/MCH/Status/src/StatusMap.cxx b/Detectors/MUON/MCH/Status/src/StatusMap.cxx
index 40957186ba..3a4d3bee0d 100644
--- a/Detectors/MUON/MCH/Status/src/StatusMap.cxx
+++ b/Detectors/MUON/MCH/Status/src/StatusMap.cxx
@@ -10,7 +10,12 @@
 // or submit itself to any jurisdiction.
 
 #include "MCHStatus/StatusMap.h"
+
+#include <stdexcept>
+
 #include "Framework/Logger.h"
+#include "MCHConstants/DetectionElements.h"
+#include "MCHMappingInterface/Segmentation.h"
 
 #include <fmt/format.h>
 
@@ -21,7 +26,7 @@ namespace o2::mch
 
 void assertValidMask(uint32_t mask)
 {
-  uint32_t maxMask = StatusMap::kBadPedestal + StatusMap::kRejectList;
+  static constexpr uint32_t maxMask = StatusMap::kBadPedestal | StatusMap::kRejectList | StatusMap::kBadHV;
   if (mask > maxMask) {
     throw std::runtime_error(fmt::format("invalid mask {} (max allowed is {}",
                                          mask, maxMask));
@@ -36,8 +41,8 @@ void StatusMap::add(gsl::span<const DsChannelId> badchannels, uint32_t mask)
       ChannelCode cc(id.getSolarId(), id.getElinkId(), id.getChannel());
       mStatus[cc] |= mask;
     } catch (const std::exception& e) {
-      // Catch exceptions thrown by the ChannelCode constructor
-      LOGP(warning, "Error processing channel - SolarId: {} ElinkId: {} Channel: {}. Error: {}. This channel is skipped.", id.getSolarId(), id.getElinkId(), id.getChannel(), e.what());
+      LOGP(warning, "Error processing channel - SolarId: {} ElinkId: {} Channel: {}. Error: {}. This channel is skipped.",
+           id.getSolarId(), id.getElinkId(), id.getChannel(), e.what());
     }
   }
 }
@@ -50,6 +55,54 @@ void StatusMap::add(gsl::span<const ChannelCode> badchannels, uint32_t mask)
   }
 }
 
+void StatusMap::addDS(DsIndex badDS, uint32_t mask)
+{
+  if (badDS >= NumberOfDualSampas) {
+    LOGP(warning, "Error processing Dual Sampa - index: {}. This DS is skipped.", badDS);
+    return;
+  }
+  addDS(getDsDetId(badDS), mask);
+}
+
+void StatusMap::addDS(raw::DsDetId badDS, uint32_t mask)
+{
+  assertValidMask(mask);
+  auto deId = badDS.deId();
+  if (!constants::isValidDetElemId(deId)) {
+    LOGP(warning, "Error processing Dual Sampa - {}. This DS is skipped.", raw::asString(badDS));
+    return;
+  }
+  const auto& seg = mapping::segmentation(deId);
+  seg.forEachPadInDualSampa(badDS.dsId(), [&](int dePadIndex) {
+    try {
+      ChannelCode cc(deId, dePadIndex);
+      mStatus[cc] |= mask;
+    } catch (const std::exception& e) {
+      LOGP(warning, "Error processing channel - {} padIndex: {}. Error: {}. This channel is skipped.",
+           raw::asString(badDS), dePadIndex, e.what());
+    }
+  });
+}
+
+void StatusMap::addDE(uint16_t badDE, uint32_t mask)
+{
+  assertValidMask(mask);
+  if (!constants::isValidDetElemId(badDE)) {
+    LOGP(warning, "Error processing DE - Id: {}. This DE is skipped.", badDE);
+    return;
+  }
+  const auto& seg = mapping::segmentation(badDE);
+  seg.forEachPad([&](int dePadIndex) {
+    try {
+      ChannelCode cc(badDE, dePadIndex);
+      mStatus[cc] |= mask;
+    } catch (const std::exception& e) {
+      LOGP(warning, "Error processing channel - deId: {} padIndex: {}. Error: {}. This channel is skipped.",
+           badDE, dePadIndex, e.what());
+    }
+  });
+}
+
 uint32_t StatusMap::status(const ChannelCode& id) const
 {
   auto s = mStatus.find(id);
diff --git a/Detectors/MUON/MCH/Status/src/testStatusMap.cxx b/Detectors/MUON/MCH/Status/src/testStatusMap.cxx
index 3fd737ad06..2ab7ebba79 100644
--- a/Detectors/MUON/MCH/Status/src/testStatusMap.cxx
+++ b/Detectors/MUON/MCH/Status/src/testStatusMap.cxx
@@ -18,6 +18,7 @@
 #include <boost/test/data/monomorphic.hpp>
 
 #include "MCHGlobalMapping/ChannelCode.h"
+#include "MCHGlobalMapping/DsIndex.h"
 #include "MCHStatus/StatusMap.h"
 #include <fmt/format.h>
 
@@ -39,6 +40,12 @@ std::vector<o2::mch::ChannelCode> cc{
   {1025, 8},
   {515, 1863}};
 
+o2::mch::DsIndex ds = 246; // 56 pads, contains chid[1]
+
+uint16_t de = 1025; // 6976 pads, contains cc[2]
+
+uint32_t badMask = 1 << 3;
+
 BOOST_AUTO_TEST_CASE(ClearShouldGiveEmptyMap)
 {
   o2::mch::StatusMap statusMap;
@@ -50,21 +57,35 @@ BOOST_AUTO_TEST_CASE(ClearShouldGiveEmptyMap)
 BOOST_AUTO_TEST_CASE(AddChannelIdWithInvalidMaskShouldThrow)
 {
   o2::mch::StatusMap statusMap;
-  BOOST_CHECK_THROW(statusMap.add(chid, 4), std::runtime_error);
+  BOOST_CHECK_THROW(statusMap.add(chid, badMask), std::runtime_error);
 }
 
 BOOST_AUTO_TEST_CASE(AddChannelCodeWithInvalidMaskShouldThrow)
 {
   o2::mch::StatusMap statusMap;
-  BOOST_CHECK_THROW(statusMap.add(cc, 4), std::runtime_error);
+  BOOST_CHECK_THROW(statusMap.add(cc, badMask), std::runtime_error);
 }
 
-std::array<uint32_t, 3> maskList = {
+BOOST_AUTO_TEST_CASE(AddDSWithInvalidMaskShouldThrow)
+{
+  o2::mch::StatusMap statusMap;
+  BOOST_CHECK_THROW(statusMap.addDS(0, badMask), std::runtime_error);
+}
+
+BOOST_AUTO_TEST_CASE(AddDEWithInvalidMaskShouldThrow)
+{
+  o2::mch::StatusMap statusMap;
+  BOOST_CHECK_THROW(statusMap.addDE(100, badMask), std::runtime_error);
+}
+
+std::array<uint32_t, 5> maskList = {
   o2::mch::StatusMap::kBadPedestal,
   o2::mch::StatusMap::kRejectList,
-  o2::mch::StatusMap::kRejectList + o2::mch::StatusMap::kBadPedestal};
+  o2::mch::StatusMap::kBadHV,
+  o2::mch::StatusMap::kBadPedestal | o2::mch::StatusMap::kBadHV,
+  o2::mch::StatusMap::kRejectList | o2::mch::StatusMap::kBadPedestal | o2::mch::StatusMap::kBadHV};
 
-BOOST_DATA_TEST_CASE(CheckAddedChannelsGetTheRightMask, bdata::xrange(maskList.size() + 1), maskIndex)
+BOOST_DATA_TEST_CASE(CheckAddedChannelsGetTheRightMask, bdata::xrange(maskList.size()), maskIndex)
 {
   o2::mch::StatusMap statusMap;
   auto mask = maskList[maskIndex];
@@ -74,15 +95,62 @@ BOOST_DATA_TEST_CASE(CheckAddedChannelsGetTheRightMask, bdata::xrange(maskList.s
   }
 }
 
+BOOST_AUTO_TEST_CASE(CheckChannelStatusCombination)
+{
+  auto size = [](const o2::mch::StatusMap& statusMap) {
+    int n = 0;
+    for (const auto& status : statusMap) {
+      ++n;
+    }
+    return n;
+  };
+  o2::mch::StatusMap statusMap;
+  statusMap.add(cc, o2::mch::StatusMap::kBadPedestal);
+  BOOST_CHECK_EQUAL(size(statusMap), 4);
+  statusMap.add(chid, o2::mch::StatusMap::kRejectList);
+  BOOST_CHECK_EQUAL(size(statusMap), 4);
+  statusMap.addDS(ds, o2::mch::StatusMap::kBadHV);
+  BOOST_CHECK_EQUAL(size(statusMap), 59);
+  statusMap.addDE(de, o2::mch::StatusMap::kBadHV);
+  BOOST_CHECK_EQUAL(size(statusMap), 7034);
+  BOOST_CHECK_EQUAL(statusMap.status(cc[0]), o2::mch::StatusMap::kBadPedestal | o2::mch::StatusMap::kRejectList);
+  BOOST_CHECK_EQUAL(statusMap.status(cc[1]), o2::mch::StatusMap::kBadPedestal | o2::mch::StatusMap::kRejectList | o2::mch::StatusMap::kBadHV);
+  BOOST_CHECK_EQUAL(statusMap.status(cc[2]), o2::mch::StatusMap::kBadPedestal | o2::mch::StatusMap::kBadHV);
+  BOOST_CHECK_EQUAL(statusMap.status(cc[3]), o2::mch::StatusMap::kBadPedestal);
+}
+
 BOOST_AUTO_TEST_CASE(ApplyMaskShouldReturnASubsetDependingOnMask)
 {
+  auto size = [](const std::map<int, std::vector<int>>& badChannels) {
+    int n = 0;
+    for (const auto& channels : badChannels) {
+      n += channels.second.size();
+    }
+    return n;
+  };
   o2::mch::StatusMap statusMap;
   statusMap.add(cc, o2::mch::StatusMap::kBadPedestal);
   statusMap.add(chid, o2::mch::StatusMap::kRejectList);
+  statusMap.addDS(ds, o2::mch::StatusMap::kBadHV);
+  statusMap.addDE(de, o2::mch::StatusMap::kBadHV);
   auto badPed = applyMask(statusMap, o2::mch::StatusMap::kBadPedestal);
   auto rejectList = applyMask(statusMap, o2::mch::StatusMap::kRejectList);
-  auto all = applyMask(statusMap, o2::mch::StatusMap::kBadPedestal | o2::mch::StatusMap::kRejectList);
-  BOOST_CHECK_EQUAL(badPed.size(), cc.size());
-  BOOST_CHECK_EQUAL(rejectList.size(), chid.size());
-  BOOST_CHECK_EQUAL(all.size(), 4);
+  auto badHV = applyMask(statusMap, o2::mch::StatusMap::kBadHV);
+  auto badHVOrRL = applyMask(statusMap, o2::mch::StatusMap::kBadHV | o2::mch::StatusMap::kRejectList);
+  auto any = applyMask(statusMap, o2::mch::StatusMap::kBadPedestal | o2::mch::StatusMap::kRejectList | o2::mch::StatusMap::kBadHV);
+  BOOST_CHECK_EQUAL(badPed.size(), 4);
+  BOOST_CHECK_EQUAL(size(badPed), 4);
+  BOOST_CHECK_EQUAL(badPed[1025][0], 8);
+  BOOST_CHECK_EQUAL(rejectList.size(), 2);
+  BOOST_CHECK_EQUAL(size(rejectList), 2);
+  BOOST_CHECK_EQUAL(rejectList[100][0], 15665);
+  BOOST_CHECK_EQUAL(badHV.size(), 2);
+  BOOST_CHECK_EQUAL(size(badHV), 7032);
+  BOOST_CHECK_EQUAL(badHV[1025].size(), 6976);
+  BOOST_CHECK_EQUAL(badHVOrRL.size(), 3);
+  BOOST_CHECK_EQUAL(size(badHVOrRL), 7033);
+  BOOST_CHECK_EQUAL(badHVOrRL[515].size(), 0);
+  BOOST_CHECK_EQUAL(any.size(), 4);
+  BOOST_CHECK_EQUAL(size(any), 7034);
+  BOOST_CHECK_EQUAL(any[302][0], 20117);
 }
diff --git a/Detectors/Raw/TFReaderDD/src/TFReaderSpec.cxx b/Detectors/Raw/TFReaderDD/src/TFReaderSpec.cxx
index 32242f2cde..594d26b568 100644
--- a/Detectors/Raw/TFReaderDD/src/TFReaderSpec.cxx
+++ b/Detectors/Raw/TFReaderDD/src/TFReaderSpec.cxx
@@ -346,7 +346,7 @@ void TFReaderSpec::TFBuilder()
   bool waitAcknowledged = false;
   long startWait = 0;
   while (mRunning && mDevice) {
-    LOGP(info, "mTFQueue.size()={} mWaitSendingLast = {}", mTFQueue.size(), mWaitSendingLast);
+    LOGP(debug, "mTFQueue.size()={} mWaitSendingLast = {}", mTFQueue.size(), mWaitSendingLast);
     if (mTFQueue.size() >= size_t(mInput.maxTFCache)) {
       mWaitSendingLast = false;
       std::this_thread::sleep_for(sleepTime);
diff --git a/Detectors/TPC/calibration/include/TPCCalibration/CalibPadGainTracks.h b/Detectors/TPC/calibration/include/TPCCalibration/CalibPadGainTracks.h
index 827beb7a51..b3fd532c06 100644
--- a/Detectors/TPC/calibration/include/TPCCalibration/CalibPadGainTracks.h
+++ b/Detectors/TPC/calibration/include/TPCCalibration/CalibPadGainTracks.h
@@ -104,7 +104,7 @@ class CalibPadGainTracks : public CalibPadGainTracksBase
   /// \param vTPCTracksArrayInp vector of tpc tracks
   /// \param tpcTrackClIdxVecInput set the TPCClRefElem member variable
   /// \param clIndex set the ClusterNativeAccess member variable
-  void setMembers(gsl::span<const o2::tpc::TrackTPC>* vTPCTracksArrayInp, gsl::span<const o2::tpc::TPCClRefElem>* tpcTrackClIdxVecInput, const o2::tpc::ClusterNativeAccess& clIndex);
+  void setMembers(gsl::span<const o2::tpc::TrackTPC>* vTPCTracksArrayInp, gsl::span<const o2::tpc::TPCClRefElem>* tpcTrackClIdxVecInput, const o2::tpc::ClusterNativeAccess& clIndex, gsl::span<const unsigned char> TPCRefitterShMap, gsl::span<const unsigned int> TPCRefitterOccMap);
 
   /// this function sets the mode of the class.
   /// e.g. mode=0 -> use the truncated mean from the track for normalizing the dedx
@@ -220,8 +220,9 @@ class CalibPadGainTracks : public CalibPadGainTracksBase
   gsl::span<const TrackTPC>* mTracks{nullptr};                                        ///<! vector containing the tpc tracks which will be processed. Cant be const due to the propagate function
   gsl::span<const TPCClRefElem>* mTPCTrackClIdxVecInput{nullptr};                     ///<! input vector with TPC tracks cluster indicies
   const o2::tpc::ClusterNativeAccess* mClusterIndex{nullptr};                         ///<! needed to access clusternative with tpctracks
+  gsl::span<const unsigned char> mTPCRefitterShMap;                                   ///<! externally set TPC clusters sharing map
+  gsl::span<const unsigned int> mTPCRefitterOccMap;                                   ///<! externally set TPC clusters occupancy map
   std::vector<unsigned char> mBufVec;                                                 ///<! buffer for filling shared cluster map
-  unsigned char* mClusterShMapTPC{nullptr};                                           ///<! externally set TPC clusters sharing map
   DEdxType mMode = dedxTrack;                                                         ///< normalization type: type=DedxTrack use truncated mean, type=DedxBB use value from BB fit
   DEdxRegion mDedxRegion = stack;                                                     ///<  using the dE/dx per chamber, stack or per sector
   float mFieldNominalGPUBz{-5};                                                       ///< Magnetic field in kG, used for track propagation
diff --git a/Detectors/TPC/calibration/include/TPCCalibration/TPCVDriftTglCalibration.h b/Detectors/TPC/calibration/include/TPCCalibration/TPCVDriftTglCalibration.h
index 2db4cb241e..4964154732 100644
--- a/Detectors/TPC/calibration/include/TPCCalibration/TPCVDriftTglCalibration.h
+++ b/Detectors/TPC/calibration/include/TPCCalibration/TPCVDriftTglCalibration.h
@@ -66,7 +66,7 @@ struct TPCVDTglContainer {
     }
     driftVFullMean = (driftVFullMean * nTFProc + vfull) / (nTFProc + 1);
     if (tOffsetRef == 0.f) {
-      tOffsetRef = data[0].first; // assign 1st full toffset as a reference
+      tOffsetRef = data[1].first; // assign 1st full toffset as a reference
     }
     nTFProc++;
   }
diff --git a/Detectors/TPC/calibration/src/CalculatedEdx.cxx b/Detectors/TPC/calibration/src/CalculatedEdx.cxx
index 31bd7677b4..b70be76407 100644
--- a/Detectors/TPC/calibration/src/CalculatedEdx.cxx
+++ b/Detectors/TPC/calibration/src/CalculatedEdx.cxx
@@ -45,7 +45,7 @@ void CalculatedEdx::setMembers(std::vector<o2::tpc::TPCClRefElem>* tpcTrackClIdx
 
 void CalculatedEdx::setRefit()
 {
-  mRefit = std::make_unique<o2::gpu::GPUO2InterfaceRefit>(mClusterIndex, &mTPCCorrMapsHelper, mFieldNominalGPUBz, mTPCTrackClIdxVecInput->data(), nullptr, mTracks);
+  mRefit = std::make_unique<o2::gpu::GPUO2InterfaceRefit>(mClusterIndex, &mTPCCorrMapsHelper, mFieldNominalGPUBz, mTPCTrackClIdxVecInput->data(), 0, nullptr, nullptr, -1, mTracks);
 }
 
 void CalculatedEdx::fillMissingClusters(int missingClusters[4], float minChargeTot, float minChargeMax, int method)
diff --git a/Detectors/TPC/calibration/src/CalibPadGainTracks.cxx b/Detectors/TPC/calibration/src/CalibPadGainTracks.cxx
index bab84a446d..93cdb7c47e 100644
--- a/Detectors/TPC/calibration/src/CalibPadGainTracks.cxx
+++ b/Detectors/TPC/calibration/src/CalibPadGainTracks.cxx
@@ -37,10 +37,7 @@ void CalibPadGainTracks::processTracks(const int nMaxTracks)
 {
   std::unique_ptr<o2::gpu::GPUO2InterfaceRefit> refit;
   if (!mPropagateTrack) {
-    mBufVec.resize(mClusterIndex->nClustersTotal);
-    o2::gpu::GPUO2InterfaceRefit::fillSharedClustersMap(mClusterIndex, *mTracks, mTPCTrackClIdxVecInput->data(), mBufVec.data());
-    mClusterShMapTPC = mBufVec.data();
-    refit = std::make_unique<o2::gpu::GPUO2InterfaceRefit>(mClusterIndex, mTPCCorrMapsHelper, mFieldNominalGPUBz, mTPCTrackClIdxVecInput->data(), mClusterShMapTPC);
+    refit = std::make_unique<o2::gpu::GPUO2InterfaceRefit>(mClusterIndex, mTPCCorrMapsHelper, mFieldNominalGPUBz, mTPCTrackClIdxVecInput->data(), 0, mTPCRefitterShMap.data(), mTPCRefitterOccMap.data(), mTPCRefitterOccMap.size());
   }
 
   const size_t loopEnd = (nMaxTracks < 0) ? mTracks->size() : ((nMaxTracks > mTracks->size()) ? mTracks->size() : size_t(nMaxTracks));
@@ -310,11 +307,13 @@ void CalibPadGainTracks::dumpToFile(const char* outFileName, const char* outName
   fOut.Close();
 }
 
-void CalibPadGainTracks::setMembers(gsl::span<const o2::tpc::TrackTPC>* vTPCTracksArrayInp, gsl::span<const o2::tpc::TPCClRefElem>* tpcTrackClIdxVecInput, const o2::tpc::ClusterNativeAccess& clIndex)
+void CalibPadGainTracks::setMembers(gsl::span<const o2::tpc::TrackTPC>* vTPCTracksArrayInp, gsl::span<const o2::tpc::TPCClRefElem>* tpcTrackClIdxVecInput, const o2::tpc::ClusterNativeAccess& clIndex, gsl::span<const unsigned char> TPCRefitterShMap, gsl::span<const unsigned int> TPCRefitterOccMap)
 {
   mTracks = vTPCTracksArrayInp;
   mTPCTrackClIdxVecInput = tpcTrackClIdxVecInput;
   mClusterIndex = &clIndex;
+  mTPCRefitterShMap = TPCRefitterShMap;
+  mTPCRefitterOccMap = TPCRefitterOccMap;
 }
 
 void CalibPadGainTracks::setMomentumRange(const float momMin, const float momMax)
diff --git a/Detectors/TPC/calibration/src/VDriftHelper.cxx b/Detectors/TPC/calibration/src/VDriftHelper.cxx
index eca0a6c8e3..12b43c255d 100644
--- a/Detectors/TPC/calibration/src/VDriftHelper.cxx
+++ b/Detectors/TPC/calibration/src/VDriftHelper.cxx
@@ -69,6 +69,7 @@ void VDriftHelper::accountLaserCalibration(const LtrCalibData* calib, long fallB
     mVDLaser.refVDrift = ref;
     mVDLaser.corrFact = 1. / corr;
     mVDLaser.creationTime = calib->creationTime;
+    mVDLaser.refTimeOffset = calib->refTimeOffset;
     mUpdated = true;
     mSource = Source::Laser;
     if (mMayRenormSrc & (0x1U << Source::Laser)) { // this was 1st setting?
@@ -79,7 +80,7 @@ void VDriftHelper::accountLaserCalibration(const LtrCalibData* calib, long fallB
       mMayRenormSrc &= ~(0x1U << Source::Laser); // unset MayRenorm
     } else if (ref != prevRef) {                 // we want to keep the same reference over the run, this may happen if run-time laser calibration is supplied
       LOGP(warn, "VDriftHelper: renorming updated TPC refVDrift={}/correction={} previous refVDrift {}, source: {}", mVDLaser.refVDrift, mVDLaser.corrFact, prevRef, getSourceName(mSource));
-      mVDLaser.normalizeOffset(prevRef);
+      mVDLaser.normalize(prevRef);
     }
   }
 }
@@ -134,6 +135,8 @@ void VDriftHelper::extractCCDBInputs(ProcessingContext& pc, bool laser, bool its
     // prefer among laser and tgl VDrift the one with the latest update time
     auto saveVD = mVD;
     mVD = mVDTPCITSTgl.creationTime < mVDLaser.creationTime ? mVDLaser : mVDTPCITSTgl;
+    auto& loserVD = mVDTPCITSTgl.creationTime < mVDLaser.creationTime ? mVDTPCITSTgl : mVDLaser;
+
     if (mForceParamDrift) {
       mVD.refVDrift = saveVD.refVDrift;
       mVD.corrFact = saveVD.corrFact;
@@ -144,13 +147,19 @@ void VDriftHelper::extractCCDBInputs(ProcessingContext& pc, bool laser, bool its
       mVD.timeOffsetCorr = 0.f;
     }
     mSource = mVDTPCITSTgl.creationTime < mVDLaser.creationTime ? Source::Laser : Source::ITSTPCTgl;
-    LOGP(info, "Will prefer TPC Drift from {} with time {} to {} with time {}",
-         SourceNames[int(mSource)], mVD.creationTime,
-         mSource == Source::Laser ? SourceNames[int(Source::ITSTPCTgl)] : SourceNames[int(Source::Laser)],
-         mSource == Source::Laser ? mVDTPCITSTgl.creationTime : mVDLaser.creationTime);
+    auto loseCTime = loserVD.creationTime;
+    loserVD = mVD; // override alternative VD to avoid normalization problems later
+    std::string rep = fmt::format("Prefer TPC Drift from {} with time {} to {} with time {}",
+                                  SourceNames[int(mSource)], mVD.creationTime, mSource == Source::Laser ? SourceNames[int(Source::ITSTPCTgl)] : SourceNames[int(Source::Laser)],
+                                  mSource == Source::Laser ? mVDTPCITSTgl.creationTime : mVDLaser.creationTime);
     if (mForceParamDrift || mForceParamOffset) {
-      LOGP(info, "but {} is imposed from the command line", mForceParamDrift ? "VDrift" : "DriftTimeOffset");
+      std::string impos = mForceParamDrift ? "VDrift" : "";
+      if (mForceParamOffset) {
+        impos += mForceParamDrift ? " and DriftTimeOffset" : "DriftTimeOffset";
+      }
+      rep += fmt::format(" but {} imposed from command line", impos);
     }
+    LOGP(info, "{}", rep);
   }
 }
 
diff --git a/Detectors/TPC/qc/src/TrackClusters.cxx b/Detectors/TPC/qc/src/TrackClusters.cxx
index 2c039f070b..bcc071920e 100644
--- a/Detectors/TPC/qc/src/TrackClusters.cxx
+++ b/Detectors/TPC/qc/src/TrackClusters.cxx
@@ -64,7 +64,7 @@ bool TrackClusters::processTrackAndClusters(const std::vector<o2::tpc::TrackTPC>
   std::vector<unsigned char> mBufVec;
   mBufVec.resize(clusterIndex->nClustersTotal);
 
-  o2::gpu::GPUO2InterfaceRefit::fillSharedClustersMap(clusterIndex, *tracks, clusRefs->data(), mBufVec.data());
+  o2::gpu::GPUO2InterfaceRefit::fillSharedClustersAndOccupancyMap(clusterIndex, *tracks, clusRefs->data(), mBufVec.data());
 
   for (auto const& track : (*tracks)) {
     const auto dEdxTot = track.getdEdx().dEdxTotTPC;
diff --git a/Detectors/TPC/workflow/include/TPCWorkflow/ClusterSharingMapSpec.h b/Detectors/TPC/workflow/include/TPCWorkflow/ClusterSharingMapSpec.h
index 1bade0eec9..e6c6939a2c 100644
--- a/Detectors/TPC/workflow/include/TPCWorkflow/ClusterSharingMapSpec.h
+++ b/Detectors/TPC/workflow/include/TPCWorkflow/ClusterSharingMapSpec.h
@@ -18,6 +18,7 @@
 
 #include "Framework/DataProcessorSpec.h"
 #include "Framework/Task.h"
+#include "Framework/CCDBParamSpec.h"
 
 namespace o2
 {
@@ -39,7 +40,9 @@ o2::framework::DataProcessorSpec getClusterSharingMapSpec()
   inputs.emplace_back("trackTPC", "TPC", "TRACKS", 0, o2::framework::Lifetime::Timeframe);
   inputs.emplace_back("trackTPCClRefs", "TPC", "CLUSREFS", 0, o2::framework::Lifetime::Timeframe);
   inputs.emplace_back("clusTPC", o2::framework::ConcreteDataTypeMatcher{"TPC", "CLUSTERNATIVE"}, o2::framework::Lifetime::Timeframe);
+  inputs.emplace_back("grpecs", "GLO", "GRPECS", 0, o2::framework::Lifetime::Condition, o2::framework::ccdbParamSpec("GLO/Config/GRPECS", true));
   outputs.emplace_back("TPC", "CLSHAREDMAP", 0, o2::framework::Lifetime::Timeframe);
+  outputs.emplace_back("TPC", "TPCOCCUPANCYMAP", 0, o2::framework::Lifetime::Timeframe);
 
   return o2::framework::DataProcessorSpec{
     "tpc-clusters-sharing-map-producer",
diff --git a/Detectors/TPC/workflow/include/TPCWorkflow/TPCCalibPadGainTracksSpec.h b/Detectors/TPC/workflow/include/TPCWorkflow/TPCCalibPadGainTracksSpec.h
index da0a302125..7afc973d7a 100644
--- a/Detectors/TPC/workflow/include/TPCWorkflow/TPCCalibPadGainTracksSpec.h
+++ b/Detectors/TPC/workflow/include/TPCWorkflow/TPCCalibPadGainTracksSpec.h
@@ -30,7 +30,7 @@
 #include "TPCCalibration/CorrectionMapsLoader.h"
 #include "DetectorsBase/GRPGeomHelper.h"
 #include "GPUO2InterfaceUtils.h"
-
+#include "DataFormatsGlobalTracking/RecoContainer.h"
 #include <random>
 
 using namespace o2::framework;
@@ -45,7 +45,7 @@ namespace tpc
 class TPCCalibPadGainTracksDevice : public o2::framework::Task
 {
  public:
-  TPCCalibPadGainTracksDevice(std::shared_ptr<o2::base::GRPGeomRequest> req, const o2::tpc::CorrectionMapsLoaderGloOpts& sclOpts, const uint32_t publishAfterTFs, const bool debug, const bool useLastExtractedMapAsReference, const std::string polynomialsFile, const bool disablePolynomialsCCDB) : mPublishAfter(publishAfterTFs), mDebug(debug), mUseLastExtractedMapAsReference(useLastExtractedMapAsReference), mDisablePolynomialsCCDB(disablePolynomialsCCDB), mCCDBRequest(req)
+  TPCCalibPadGainTracksDevice(std::shared_ptr<o2::globaltracking::DataRequest> dr, std::shared_ptr<o2::base::GRPGeomRequest> req, const o2::tpc::CorrectionMapsLoaderGloOpts& sclOpts, const uint32_t publishAfterTFs, const bool debug, const bool useLastExtractedMapAsReference, const std::string polynomialsFile, const bool disablePolynomialsCCDB) : mDataRequest(dr), mPublishAfter(publishAfterTFs), mDebug(debug), mUseLastExtractedMapAsReference(useLastExtractedMapAsReference), mDisablePolynomialsCCDB(disablePolynomialsCCDB), mCCDBRequest(req)
   {
     if (!polynomialsFile.empty()) {
       LOGP(info, "Loading polynomials from file {}", polynomialsFile);
@@ -167,10 +167,12 @@ class TPCCalibPadGainTracksDevice : public o2::framework::Task
       return;
     }
     o2::base::GRPGeomHelper::instance().checkUpdates(pc);
+    o2::globaltracking::RecoContainer recoData;
+    recoData.collectData(pc, *mDataRequest.get());
 
-    auto tracks = pc.inputs().get<gsl::span<o2::tpc::TrackTPC>>("trackTPC");
-    auto clRefs = pc.inputs().get<gsl::span<o2::tpc::TPCClRefElem>>("trackTPCClRefs");
-    const auto& clusters = getWorkflowTPCInput(pc);
+    auto tracks = recoData.getTPCTracks();
+    auto clRefs = recoData.getTPCTracksClusterRefs();
+    const auto& clusters = recoData.inputsTPCclusters;
     const auto nTracks = tracks.size();
     if (nTracks == 0) {
       return;
@@ -206,7 +208,7 @@ class TPCCalibPadGainTracksDevice : public o2::framework::Task
       mTPCCorrMapsLoader.updateVDrift(mTPCVDriftHelper.getVDriftObject().corrFact, mTPCVDriftHelper.getVDriftObject().refVDrift, mTPCVDriftHelper.getVDriftObject().getTimeOffset());
     }
 
-    mPadGainTracks.setMembers(&tracks, &clRefs, clusters->clusterIndex);
+    mPadGainTracks.setMembers(&tracks, &clRefs, clusters->clusterIndex, recoData.clusterShMapTPC, recoData.occupancyMapTPC);
     mPadGainTracks.processTracks(mMaxTracksPerTF);
     ++mProcessedTFs;
     if ((mFirstTFSend == mProcessedTFs) || (mPublishAfter && (mProcessedTFs % mPublishAfter) == 0)) {
@@ -225,6 +227,7 @@ class TPCCalibPadGainTracksDevice : public o2::framework::Task
   const bool mDebug{false};                               ///< create debug output
   const bool mUseLastExtractedMapAsReference{false};      ///< using the last extracted gain map as the reference map which will be applied
   bool mDisablePolynomialsCCDB{false};                    ///< do not load the polynomials from the CCDB
+  std::shared_ptr<o2::globaltracking::DataRequest> mDataRequest; ///< reco container data request
   std::shared_ptr<o2::base::GRPGeomRequest> mCCDBRequest; ///< for accessing the b-field
   uint32_t mProcessedTFs{0};                              ///< counter to keep track of the processed TFs
   uint32_t mTFCounter{0};                                 ///< counter to keep track of the TFs
@@ -246,11 +249,12 @@ class TPCCalibPadGainTracksDevice : public o2::framework::Task
 DataProcessorSpec getTPCCalibPadGainTracksSpec(const uint32_t publishAfterTFs, const bool debug, const bool useLastExtractedMapAsReference, const std::string polynomialsFile, bool disablePolynomialsCCDB, const o2::tpc::CorrectionMapsLoaderGloOpts& sclOpts)
 {
   std::vector<InputSpec> inputs;
-  inputs.emplace_back("trackTPC", gDataOriginTPC, "TRACKS", 0, Lifetime::Timeframe);
-  inputs.emplace_back("trackTPCClRefs", gDataOriginTPC, "CLUSREFS", 0, Lifetime::Timeframe);
-  inputs.emplace_back("clusTPC", ConcreteDataTypeMatcher{gDataOriginTPC, "CLUSTERNATIVE"}, Lifetime::Timeframe);
+  auto dataRequest = std::make_shared<o2::globaltracking::DataRequest>();
+  dataRequest->requestTracks(o2::dataformats::GlobalTrackID::getSourceMask(o2::dataformats::GlobalTrackID::TPC), false);
+  dataRequest->requestClusters(o2::dataformats::GlobalTrackID::getSourceMask(o2::dataformats::GlobalTrackID::TPC), false);
+
   if (sclOpts.lumiType == 1) {
-    inputs.emplace_back("CTPLumi", "CTP", "LUMI", 0, Lifetime::Timeframe);
+    dataRequest->inputs.emplace_back("CTPLumi", "CTP", "LUMI", 0, Lifetime::Timeframe);
   }
 
   if (!polynomialsFile.empty()) {
@@ -258,14 +262,14 @@ DataProcessorSpec getTPCCalibPadGainTracksSpec(const uint32_t publishAfterTFs, c
   }
 
   if (!disablePolynomialsCCDB) {
-    inputs.emplace_back("tpctopologygain", gDataOriginTPC, "TOPOLOGYGAIN", 0, Lifetime::Condition, ccdbParamSpec(CDBTypeMap.at(CDBType::CalTopologyGain)));
+    dataRequest->inputs.emplace_back("tpctopologygain", gDataOriginTPC, "TOPOLOGYGAIN", 0, Lifetime::Condition, ccdbParamSpec(CDBTypeMap.at(CDBType::CalTopologyGain)));
   }
 
   if (useLastExtractedMapAsReference) {
-    inputs.emplace_back("tpcresidualgainmap", gDataOriginTPC, "RESIDUALGAINMAP", 0, Lifetime::Condition, ccdbParamSpec(CDBTypeMap.at(CDBType::CalPadGainResidual)));
+    dataRequest->inputs.emplace_back("tpcresidualgainmap", gDataOriginTPC, "RESIDUALGAINMAP", 0, Lifetime::Condition, ccdbParamSpec(CDBTypeMap.at(CDBType::CalPadGainResidual)));
   }
 
-  o2::tpc::VDriftHelper::requestCCDBInputs(inputs);
+  o2::tpc::VDriftHelper::requestCCDBInputs(dataRequest->inputs);
   Options opts{
     {"nBins", VariantType::Int, 20, {"Number of bins per histogram"}},
     {"reldEdxMin", VariantType::Int, 0, {"Minimum x coordinate of the histogram for Q/(dE/dx)"}},
@@ -288,7 +292,7 @@ DataProcessorSpec getTPCCalibPadGainTracksSpec(const uint32_t publishAfterTFs, c
     {"useEveryNthTF", VariantType::Int, 10, {"Using only a fraction of the data: 1: Use every TF, 10: Use only every tenth TF."}},
     {"maxTracksPerTF", VariantType::Int, 10000, {"Maximum number of processed tracks per TF (-1 for processing all tracks)"}},
   };
-  o2::tpc::CorrectionMapsLoader::requestCCDBInputs(inputs, opts, sclOpts);
+  o2::tpc::CorrectionMapsLoader::requestCCDBInputs(dataRequest->inputs, opts, sclOpts);
 
   auto ccdbRequest = std::make_shared<o2::base::GRPGeomRequest>(false,                          // orbitResetTime
                                                                 false,                          // GRPECS=true
@@ -296,16 +300,16 @@ DataProcessorSpec getTPCCalibPadGainTracksSpec(const uint32_t publishAfterTFs, c
                                                                 true,                           // GRPMagField
                                                                 true,                           // askMatLUT
                                                                 o2::base::GRPGeomRequest::None, // geometry
-                                                                inputs);
+                                                                dataRequest->inputs);
 
   std::vector<OutputSpec> outputs;
   outputs.emplace_back(gDataOriginTPC, "TRACKGAINHISTOS", 0, o2::framework::Lifetime::Sporadic);
 
   return DataProcessorSpec{
     "calib-tpc-gainmap-tracks",
-    inputs,
+    dataRequest->inputs,
     outputs,
-    AlgorithmSpec{adaptFromTask<TPCCalibPadGainTracksDevice>(ccdbRequest, sclOpts, publishAfterTFs, debug, useLastExtractedMapAsReference, polynomialsFile, disablePolynomialsCCDB)},
+    AlgorithmSpec{adaptFromTask<TPCCalibPadGainTracksDevice>(dataRequest, ccdbRequest, sclOpts, publishAfterTFs, debug, useLastExtractedMapAsReference, polynomialsFile, disablePolynomialsCCDB)},
     opts}; // end DataProcessorSpec
 }
 
diff --git a/Detectors/TPC/workflow/src/ClusterSharingMapSpec.cxx b/Detectors/TPC/workflow/src/ClusterSharingMapSpec.cxx
index 7b8259aa70..eef3061bc4 100644
--- a/Detectors/TPC/workflow/src/ClusterSharingMapSpec.cxx
+++ b/Detectors/TPC/workflow/src/ClusterSharingMapSpec.cxx
@@ -19,7 +19,9 @@
 #include "DataFormatsTPC/WorkflowHelper.h"
 #include "DataFormatsTPC/TrackTPC.h"
 #include "GPUO2InterfaceRefit.h"
+#include "GPUO2InterfaceUtils.h"
 #include "TPCWorkflow/ClusterSharingMapSpec.h"
+#include "DataFormatsParameters/GRPECSObject.h"
 
 using namespace o2::framework;
 using namespace o2::tpc;
@@ -27,13 +29,21 @@ using namespace o2::tpc;
 void ClusterSharingMapSpec::run(ProcessingContext& pc)
 {
   TStopwatch timer;
-
+  static int nHBPerTF = 0;
   const auto tracksTPC = pc.inputs().get<gsl::span<o2::tpc::TrackTPC>>("trackTPC");
   const auto tracksTPCClRefs = pc.inputs().get<gsl::span<o2::tpc::TPCClRefElem>>("trackTPCClRefs");
   const auto& clustersTPC = getWorkflowTPCInput(pc);
+  if (pc.services().get<o2::framework::TimingInfo>().globalRunNumberChanged) { // new run is starting
+    auto grp = pc.inputs().get<o2::parameters::GRPECSObject*>("grpecs");
+    nHBPerTF = grp->getNHBFPerTF();
+    LOGP(info, "Will use {} HB per TF from GRPECS", nHBPerTF);
+  }
 
-  auto& bufVec = pc.outputs().make<std::vector<unsigned char>>(Output{o2::header::gDataOriginTPC, "CLSHAREDMAP", 0}, clustersTPC->clusterIndex.nClustersTotal);
-  o2::gpu::GPUO2InterfaceRefit::fillSharedClustersMap(&clustersTPC->clusterIndex, tracksTPC, tracksTPCClRefs.data(), bufVec.data());
+  std::shared_ptr<o2::gpu::GPUParam> param = o2::gpu::GPUO2InterfaceUtils::getFullParamShared(0.f, nHBPerTF);
+  auto& bufVecSh = pc.outputs().make<std::vector<unsigned char>>(Output{o2::header::gDataOriginTPC, "CLSHAREDMAP", 0}, clustersTPC->clusterIndex.nClustersTotal);
+  size_t occupancyMapSize = o2::gpu::GPUO2InterfaceRefit::fillOccupancyMapGetSize(nHBPerTF, param.get());
+  auto& bufVecOcc = pc.outputs().make<std::vector<unsigned int>>(Output{o2::header::gDataOriginTPC, "TPCOCCUPANCYMAP", 0}, occupancyMapSize);
+  o2::gpu::GPUO2InterfaceRefit::fillSharedClustersAndOccupancyMap(&clustersTPC->clusterIndex, tracksTPC, tracksTPCClRefs.data(), bufVecSh.data(), bufVecOcc.data(), nHBPerTF, param.get());
 
   timer.Stop();
   LOGF(info, "Timing for TPC clusters sharing map creation: Cpu: %.3e Real: %.3e s", timer.CpuTime(), timer.RealTime());
diff --git a/Detectors/TPC/workflow/src/EntropyEncoderSpec.cxx b/Detectors/TPC/workflow/src/EntropyEncoderSpec.cxx
index ca024c1e26..fc707f433c 100644
--- a/Detectors/TPC/workflow/src/EntropyEncoderSpec.cxx
+++ b/Detectors/TPC/workflow/src/EntropyEncoderSpec.cxx
@@ -69,18 +69,9 @@ void EntropyEncoderSpec::init(o2::framework::InitContext& ic)
   mCTFCoder.init<CTF>(ic);
   mCTFCoder.setCombineColumns(!ic.options().get<bool>("no-ctf-columns-combining"));
 
-  mConfig.reset(new o2::gpu::GPUO2InterfaceConfiguration);
-  mConfig->configGRP.solenoidBzNominalGPU = 0;
-  mConfParam.reset(new o2::gpu::GPUSettingsO2(mConfig->ReadConfigurableParam()));
-  mAutoContinuousMaxTimeBin = mConfig->configGRP.continuousMaxTimeBin == -1;
-  if (mAutoContinuousMaxTimeBin) {
-    mConfig->configGRP.continuousMaxTimeBin = (256 * o2::constants::lhc::LHCMaxBunches + 2 * o2::tpc::constants::LHCBCPERTIMEBIN - 2) / o2::tpc::constants::LHCBCPERTIMEBIN;
-  }
-
   mFastTransform = std::move(TPCFastTransformHelperO2::instance()->create(0));
 
-  mParam.reset(new o2::gpu::GPUParam);
-  mParam->SetDefaults(&mConfig->configGRP, &mConfig->configReconstruction, &mConfig->configProcessing, nullptr);
+  mParam = GPUO2InterfaceUtils::getFullParam(0.f, 0, &mConfig, &mConfParam, &mAutoContinuousMaxTimeBin);
 
   if (mSelIR) {
     mTPCVDriftHelper.reset(new VDriftHelper);
diff --git a/Detectors/TPC/workflow/src/FileReaderWorkflow.cxx b/Detectors/TPC/workflow/src/FileReaderWorkflow.cxx
index 0d2b4a649d..a65b4ccdf3 100644
--- a/Detectors/TPC/workflow/src/FileReaderWorkflow.cxx
+++ b/Detectors/TPC/workflow/src/FileReaderWorkflow.cxx
@@ -14,9 +14,9 @@
 #include "TPCReaderWorkflow/ClusterReaderSpec.h"
 #include "TPCReaderWorkflow/TriggerReaderSpec.h"
 #include "TPCReaderWorkflow/TrackReaderSpec.h"
+#include "TPCWorkflow/ClusterSharingMapSpec.h"
 #include "DetectorsRaw/HBFUtilsInitializer.h"
 #include "Framework/CallbacksPolicy.h"
-
 #include "Algorithm/RangeTokenizer.h"
 
 #include "SimulationDataFormat/IOMCTruthContainerView.h"
@@ -85,6 +85,11 @@ WorkflowSpec defineDataProcessing(ConfigContext const& cfgc)
 
     specs.push_back(o2::tpc::getTPCTrackReaderSpec(doMC));
   }
+
+  if (isEnabled(InputType::Tracks) && isEnabled(InputType::Clusters)) { // create shared clusters and occupancy maps
+    specs.emplace_back(o2::tpc::getClusterSharingMapSpec());
+  }
+
   o2::raw::HBFUtilsInitializer hbfIni(cfgc, specs);
   return std::move(specs);
 }
diff --git a/Detectors/TPC/workflow/src/TPCRefitter.cxx b/Detectors/TPC/workflow/src/TPCRefitter.cxx
index bf32925585..6a41f487f4 100644
--- a/Detectors/TPC/workflow/src/TPCRefitter.cxx
+++ b/Detectors/TPC/workflow/src/TPCRefitter.cxx
@@ -92,6 +92,7 @@ class TPCRefitterSpec final : public Task
   gsl::span<const o2::tpc::TPCClRefElem> mTPCTrackClusIdx;            ///< input TPC track cluster indices span
   gsl::span<const o2::tpc::TrackTPC> mTPCTracksArray;                 ///< input TPC tracks span
   gsl::span<const unsigned char> mTPCRefitterShMap;                   ///< externally set TPC clusters sharing map
+  gsl::span<const unsigned int> mTPCRefitterOccMap;                   ///< externally set TPC clusters occupancy map
   const o2::tpc::ClusterNativeAccess* mTPCClusterIdxStruct = nullptr; ///< struct holding the TPC cluster indices
   gsl::span<const o2::MCCompLabel> mTPCTrkLabels;                     ///< input TPC Track MC labels
   std::unique_ptr<o2::gpu::GPUO2InterfaceRefit> mTPCRefitter;         ///< TPC refitter used for TPC tracks refit during the reconstruction
@@ -177,6 +178,7 @@ void TPCRefitterSpec::process(o2::globaltracking::RecoContainer& recoData)
   mTPCTrackClusIdx = recoData.getTPCTracksClusterRefs();
   mTPCClusterIdxStruct = &recoData.inputsTPCclusters->clusterIndex;
   mTPCRefitterShMap = recoData.clusterShMapTPC;
+  mTPCRefitterOccMap = recoData.occupancyMapTPC;
 
   std::vector<o2::InteractionTimeRecord> intRecs;
   if (mUseMC) { // extract MC tracks
@@ -189,7 +191,7 @@ void TPCRefitterSpec::process(o2::globaltracking::RecoContainer& recoData)
     mTPCTrkLabels = recoData.getTPCTracksMCLabels();
   }
 
-  mTPCRefitter = std::make_unique<o2::gpu::GPUO2InterfaceRefit>(mTPCClusterIdxStruct, &mTPCCorrMapsLoader, prop->getNominalBz(), mTPCTrackClusIdx.data(), mTPCRefitterShMap.data(), nullptr, prop);
+  mTPCRefitter = std::make_unique<o2::gpu::GPUO2InterfaceRefit>(mTPCClusterIdxStruct, &mTPCCorrMapsLoader, prop->getNominalBz(), mTPCTrackClusIdx.data(), 0, mTPCRefitterShMap.data(), mTPCRefitterOccMap.data(), mTPCRefitterOccMap.size(), nullptr, prop);
 
   float vdriftTB = mTPCVDriftHelper.getVDriftObject().getVDrift() * o2::tpc::ParameterElectronics::Instance().ZbinWidth; // VDrift expressed in cm/TimeBin
   float tpcTBBias = mTPCVDriftHelper.getVDriftObject().getTimeOffset() / (8 * o2::constants::lhc::LHCBunchSpacingMUS);
diff --git a/Detectors/TPC/workflow/src/TPCScalerSpec.cxx b/Detectors/TPC/workflow/src/TPCScalerSpec.cxx
index b184502dfc..6065079c05 100644
--- a/Detectors/TPC/workflow/src/TPCScalerSpec.cxx
+++ b/Detectors/TPC/workflow/src/TPCScalerSpec.cxx
@@ -85,10 +85,12 @@ class TPCScalerSpec : public Task
     const auto orbitResetTimeMS = o2::base::GRPGeomHelper::instance().getOrbitResetTimeMS();
     const auto firstTFOrbit = pc.services().get<o2::framework::TimingInfo>().firstTForbit;
     const double timestamp = orbitResetTimeMS + firstTFOrbit * o2::constants::lhc::LHCOrbitMUS * 0.001;
-
+    int currRun = pc.services().get<o2::framework::TimingInfo>().runNumber;
     if (mEnableMShape) {
-      if ((mMShapeTPCScaler.getRun() != -1) && pc.services().get<o2::framework::TimingInfo>().runNumber != mMShapeTPCScaler.getRun()) {
-        LOGP(error, "Run number {} of processed data and run number {} of loaded TPC M-shape scaler doesnt match!", pc.services().get<o2::framework::TimingInfo>().runNumber, mMShapeTPCScaler.getRun());
+      static int runWarningMS = -1;
+      if ((mMShapeTPCScaler.getRun() != -1) && currRun != mMShapeTPCScaler.getRun() && runWarningMS != currRun) {
+        LOGP(alarm, "Run number {} of processed data and run number {} of loaded TPC M-shape scaler doesnt match!", pc.services().get<o2::framework::TimingInfo>().runNumber, mMShapeTPCScaler.getRun());
+        runWarningMS = currRun;
       }
 
       const auto& boundaryPotential = mMShapeTPCScaler.getBoundaryPotential(timestamp);
@@ -139,8 +141,10 @@ class TPCScalerSpec : public Task
     }
 
     if (mEnableIDCs) {
-      if (pc.services().get<o2::framework::TimingInfo>().runNumber != mTPCScaler.getRun()) {
-        LOGP(error, "Run number {} of processed data and run number {} of loaded TPC scaler doesnt match!", pc.services().get<o2::framework::TimingInfo>().runNumber, mTPCScaler.getRun());
+      static int runWarningIDC = -1;
+      if (pc.services().get<o2::framework::TimingInfo>().runNumber != mTPCScaler.getRun() && runWarningIDC != currRun) {
+        LOGP(alarm, "Run number {} of processed data and run number {} of loaded TPC scaler doesnt match!", pc.services().get<o2::framework::TimingInfo>().runNumber, mTPCScaler.getRun());
+        runWarningIDC = currRun;
       }
       float scalerA = mTPCScaler.getMeanScaler(timestamp, o2::tpc::Side::A);
       float scalerC = mTPCScaler.getMeanScaler(timestamp, o2::tpc::Side::C);
diff --git a/Detectors/TRD/pid/CMakeLists.txt b/Detectors/TRD/pid/CMakeLists.txt
index 012fa642a3..8894c4384b 100644
--- a/Detectors/TRD/pid/CMakeLists.txt
+++ b/Detectors/TRD/pid/CMakeLists.txt
@@ -22,10 +22,11 @@ o2_add_library(TRDPID
                                       fmt::fmt
               TARGETVARNAME libname)
 
-if(ONNXRuntime_FOUND)
-  target_compile_definitions(${libname} PRIVATE TRDPID_WITH_ONNX)
-  target_link_libraries(${libname} ONNXRuntime::ONNXRuntime)
-  target_sources(${libname} src/ML.cxx)
+# if(onnxruntime_FOUND) # ONNXRuntime code in TRD currently disabled since it is not tested
+if(0)
+  target_compile_definitions(${libname} PUBLIC TRDPID_WITH_ONNX)
+  target_link_libraries(${libname} PRIVATE onnxruntime::onnxruntime)
+  target_sources(${libname} PRIVATE src/ML.cxx)
   o2_target_root_dictionary(TRDPID
                             HEADERS include/TRDPID/PIDBase.h
                                     include/TRDPID/PIDParameters.h
diff --git a/Detectors/TRD/pid/include/TRDPID/ML.h b/Detectors/TRD/pid/include/TRDPID/ML.h
index 0b8d8ea8ea..7c72edc30a 100644
--- a/Detectors/TRD/pid/include/TRDPID/ML.h
+++ b/Detectors/TRD/pid/include/TRDPID/ML.h
@@ -72,6 +72,7 @@ class ML : public PIDBase
   const OrtApi& mApi{Ort::GetApi()};                    ///< ONNX api
   std::unique_ptr<Ort::Experimental::Session> mSession; ///< ONNX session
   Ort::SessionOptions mSessionOptions;                  ///< ONNX session options
+  Ort::AllocatorWithDefaultOptions mAllocator;
 
   // Input/Output
   std::vector<std::string> mInputNames;            ///< model input names
diff --git a/Detectors/TRD/pid/src/ML.cxx b/Detectors/TRD/pid/src/ML.cxx
index 2ce3b6876a..488bf055a7 100644
--- a/Detectors/TRD/pid/src/ML.cxx
+++ b/Detectors/TRD/pid/src/ML.cxx
@@ -68,16 +68,25 @@ void ML::init(o2::framework::ProcessingContext& pc)
   LOG(info) << "ONNX runtime session created";
 
   // print name/shape of inputs
-  mInputNames = mSession->GetInputNames();
-  mInputShapes = mSession->GetInputShapes();
+  for (size_t i = 0; i < mSession->GetInputCount(); ++i) {
+    mInputNames.push_back(mSession->GetInputNameAllocated(i, mAllocator).get());
+  }
+  for (size_t i = 0; i < mSession->GetInputCount(); ++i) {
+    mInputShapes.emplace_back(mSession->GetInputTypeInfo(i).GetTensorTypeAndShapeInfo().GetShape());
+  }
+  for (size_t i = 0; i < mSession->GetOutputCount(); ++i) {
+    mOutputNames.push_back(mSession->GetOutputNameAllocated(i, mAllocator).get());
+  }
+  for (size_t i = 0; i < mSession->GetOutputCount(); ++i) {
+    mOutputShapes.emplace_back(mSession->GetOutputTypeInfo(i).GetTensorTypeAndShapeInfo().GetShape());
+  }
+
   LOG(info) << "Input Node Name/Shape (" << mInputNames.size() << "):";
   for (size_t i = 0; i < mInputNames.size(); i++) {
     LOG(info) << "\t" << mInputNames[i] << " : " << printShape(mInputShapes[i]);
   }
 
   // print name/shape of outputs
-  mOutputNames = mSession->GetOutputNames();
-  mOutputShapes = mSession->GetOutputShapes();
   LOG(info) << "Output Node Name/Shape (" << mOutputNames.size() << "):";
   for (size_t i = 0; i < mOutputNames.size(); i++) {
     LOG(info) << "\t" << mOutputNames[i] << " : " << printShape(mOutputShapes[i]);
diff --git a/Detectors/TRD/workflow/io/CMakeLists.txt b/Detectors/TRD/workflow/io/CMakeLists.txt
index 4405d12b4f..a3aea1ce87 100644
--- a/Detectors/TRD/workflow/io/CMakeLists.txt
+++ b/Detectors/TRD/workflow/io/CMakeLists.txt
@@ -34,6 +34,10 @@ o2_add_executable(track-reader
                  COMPONENT_NAME trd
                  SOURCES src/trd-track-reader-workflow.cxx
                  PUBLIC_LINK_LIBRARIES O2::TRDWorkflowIO)
+o2_add_executable(calib-reader-workflow
+                 COMPONENT_NAME trd
+                 SOURCES src/trd-calib-reader-workflow.cxx
+                 PUBLIC_LINK_LIBRARIES O2::TRDWorkflowIO)
 o2_add_executable(digittracklet-writer
                  COMPONENT_NAME trd
                  SOURCES src/trd-digittracklet-writer-workflow.cxx
diff --git a/Detectors/TRD/workflow/io/include/TRDWorkflowIO/TRDCalibReaderSpec.h b/Detectors/TRD/workflow/io/include/TRDWorkflowIO/TRDCalibReaderSpec.h
index afa6bec992..05d09b3d9c 100644
--- a/Detectors/TRD/workflow/io/include/TRDWorkflowIO/TRDCalibReaderSpec.h
+++ b/Detectors/TRD/workflow/io/include/TRDWorkflowIO/TRDCalibReaderSpec.h
@@ -20,6 +20,9 @@
 #include "Framework/DataProcessorSpec.h"
 #include "Framework/Task.h"
 #include "DataFormatsTRD/AngularResidHistos.h"
+#include "DataFormatsTRD/GainCalibHistos.h"
+#include "DataFormatsTRD/PHData.h"
+#include <vector>
 
 namespace o2
 {
@@ -41,6 +44,8 @@ class TRDCalibReader : public o2::framework::Task
   std::string mInFileName{"trdangreshistos.root"};
   std::string mInTreeName{"calibdata"};
   o2::trd::AngularResidHistos mAngResids, *mAngResidPtr = &mAngResids;
+  std::vector<o2::trd::PHData> mPHData, *mPHDataPtr = &mPHData;
+  std::vector<int> mGainData, *mGainDataPtr = &mGainData;
 };
 
 /// create a processor spec
diff --git a/Detectors/TRD/workflow/io/src/TRDCalibReaderSpec.cxx b/Detectors/TRD/workflow/io/src/TRDCalibReaderSpec.cxx
index cb76bb8bba..26445f3ef6 100644
--- a/Detectors/TRD/workflow/io/src/TRDCalibReaderSpec.cxx
+++ b/Detectors/TRD/workflow/io/src/TRDCalibReaderSpec.cxx
@@ -43,7 +43,17 @@ void TRDCalibReader::connectTree()
   assert(mFile && !mFile->IsZombie());
   mTree.reset((TTree*)mFile->Get(mInTreeName.c_str()));
   assert(mTree);
-  mTree->SetBranchAddress("AngularResids", &mAngResidPtr);
+  auto attachBranch = [this](const char* brName, void* add) {
+    auto br = this->mTree->GetBranch(brName);
+    if (!br) {
+      LOGP(warn, "Branch {} is absent, will send empty output", std::string(brName));
+      return;
+    }
+    br->SetAddress(add);
+  };
+  attachBranch("AngularResids", &mAngResidPtr);
+  attachBranch("PulseHeight", &mPHDataPtr);
+  attachBranch("calibdatagain", &mGainData);
   LOG(info) << "Loaded tree from " << mInFileName << " with " << mTree->GetEntries() << " entries";
 }
 
@@ -54,6 +64,8 @@ void TRDCalibReader::run(ProcessingContext& pc)
   mTree->GetEntry(currEntry);
   LOG(info) << "Pushing angular residual histograms filled with " << mAngResids.getNEntries() << " entries at tree entry " << currEntry;
   pc.outputs().snapshot(Output{o2::header::gDataOriginTRD, "ANGRESHISTS", 0}, mAngResids);
+  pc.outputs().snapshot(Output{o2::header::gDataOriginTRD, "PULSEHEIGHT", 0}, mPHData);
+  pc.outputs().snapshot(Output{o2::header::gDataOriginTRD, "GAINCALIBHISTS", 0}, mGainData);
 
   if (mTree->GetReadEntry() + 1 >= mTree->GetEntries()) {
     pc.services().get<ControlService>().endOfStream();
@@ -65,6 +77,8 @@ DataProcessorSpec getTRDCalibReaderSpec()
 {
   std::vector<OutputSpec> outputs;
   outputs.emplace_back(o2::header::gDataOriginTRD, "ANGRESHISTS", 0, Lifetime::Timeframe);
+  outputs.emplace_back(o2::header::gDataOriginTRD, "PULSEHEIGHT", 0, Lifetime::Timeframe);
+  outputs.emplace_back(o2::header::gDataOriginTRD, "GAINCALIBHISTS", 0, Lifetime::Timeframe);
 
   return DataProcessorSpec{
     "TRDCalibReader",
diff --git a/Detectors/TRD/workflow/io/src/trd-calib-reader-workflow.cxx b/Detectors/TRD/workflow/io/src/trd-calib-reader-workflow.cxx
new file mode 100644
index 0000000000..d45f840d76
--- /dev/null
+++ b/Detectors/TRD/workflow/io/src/trd-calib-reader-workflow.cxx
@@ -0,0 +1,49 @@
+// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
+// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
+// All rights not expressly granted are reserved.
+//
+// This software is distributed under the terms of the GNU General Public
+// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
+//
+// In applying this license CERN does not waive the privileges and immunities
+// granted to it by virtue of its status as an Intergovernmental Organization
+// or submit itself to any jurisdiction.
+
+#include "CommonUtils/ConfigurableParam.h"
+#include "Framework/CompletionPolicy.h"
+#include "Framework/ConfigParamSpec.h"
+#include "TRDWorkflowIO/TRDCalibReaderSpec.h"
+#include "DetectorsRaw/HBFUtilsInitializer.h"
+
+using namespace o2::framework;
+
+// ------------------------------------------------------------------
+
+void customize(std::vector<o2::framework::CallbacksPolicy>& policies)
+{
+  o2::raw::HBFUtilsInitializer::addNewTimeSliceCallback(policies);
+}
+
+// we need to add workflow options before including Framework/runDataProcessing
+void customize(std::vector<ConfigParamSpec>& workflowOptions)
+{
+  // option allowing to set parameters
+  std::vector<o2::framework::ConfigParamSpec> options{
+    {"configKeyValues", VariantType::String, "", {"Semicolon separated key=value strings ..."}}};
+  o2::raw::HBFUtilsInitializer::addConfigOption(options);
+  std::swap(workflowOptions, options);
+}
+
+// ------------------------------------------------------------------
+
+#include "Framework/runDataProcessing.h"
+
+WorkflowSpec defineDataProcessing(ConfigContext const& configcontext)
+{
+  // Update the (declared) parameters if changed from the command line
+  o2::conf::ConfigurableParam::updateFromString(configcontext.options().get<std::string>("configKeyValues"));
+
+  WorkflowSpec specs{{o2::trd::getTRDCalibReaderSpec()}};
+  o2::raw::HBFUtilsInitializer hbfIni(configcontext, specs);
+  return specs;
+}
diff --git a/Detectors/TRD/workflow/src/TRDGlobalTrackingSpec.cxx b/Detectors/TRD/workflow/src/TRDGlobalTrackingSpec.cxx
index 707cd2d961..2f365ebe49 100644
--- a/Detectors/TRD/workflow/src/TRDGlobalTrackingSpec.cxx
+++ b/Detectors/TRD/workflow/src/TRDGlobalTrackingSpec.cxx
@@ -275,7 +275,7 @@ void TRDGlobalTracking::run(ProcessingContext& pc)
   mChainTracking->ClearIOPointers();
 
   mTPCClusterIdxStruct = &inputTracks.inputsTPCclusters->clusterIndex;
-  mTPCRefitter = std::make_unique<o2::gpu::GPUO2InterfaceRefit>(mTPCClusterIdxStruct, &mTPCCorrMapsLoader, o2::base::Propagator::Instance()->getNominalBz(), inputTracks.getTPCTracksClusterRefs().data(), inputTracks.clusterShMapTPC.data(), nullptr, o2::base::Propagator::Instance());
+  mTPCRefitter = std::make_unique<o2::gpu::GPUO2InterfaceRefit>(mTPCClusterIdxStruct, &mTPCCorrMapsLoader, o2::base::Propagator::Instance()->getNominalBz(), inputTracks.getTPCTracksClusterRefs().data(), 0, inputTracks.clusterShMapTPC.data(), inputTracks.occupancyMapTPC.data(), inputTracks.occupancyMapTPC.size(), nullptr, o2::base::Propagator::Instance());
   auto tmpInputContainer = getRecoInputContainer(pc, &mChainTracking->mIOPtrs, &inputTracks, mUseMC);
   auto tmpContainer = GPUWorkflowHelper::fillIOPtr(mChainTracking->mIOPtrs, inputTracks, mUseMC, nullptr, GTrackID::getSourcesMask("TRD"), mTrkMask, GTrackID::mask_t{GTrackID::MASK_NONE});
   mTrackletsRaw = inputTracks.getTRDTracklets();
diff --git a/Detectors/Vertexing/include/DetectorsVertexing/SVertexer.h b/Detectors/Vertexing/include/DetectorsVertexing/SVertexer.h
index 0d7453d960..9d0823a04e 100644
--- a/Detectors/Vertexing/include/DetectorsVertexing/SVertexer.h
+++ b/Detectors/Vertexing/include/DetectorsVertexing/SVertexer.h
@@ -172,6 +172,7 @@ class SVertexer
   gsl::span<const o2::tpc::TrackTPC> mTPCTracksArray;                 ///< input TPC tracks span
   gsl::span<const o2::tpc::TPCClRefElem> mTPCTrackClusIdx;            ///< input TPC track cluster indices span
   gsl::span<const unsigned char> mTPCRefitterShMap;                   ///< externally set TPC clusters sharing map
+  gsl::span<const unsigned int> mTPCRefitterOccMap;                   ///< externally set TPC clusters occupancy map
   o2::gpu::CorrectionMapsHelper* mTPCCorrMapsHelper = nullptr;
   std::unique_ptr<o2::gpu::GPUO2InterfaceRefit> mTPCRefitter; ///< TPC refitter used for TPC tracks refit during the reconstruction
   o2::strangeness_tracking::StrangenessTracker* mStrTracker = nullptr;
diff --git a/Detectors/Vertexing/src/SVertexer.cxx b/Detectors/Vertexing/src/SVertexer.cxx
index 5da94b76f5..252d14c16c 100644
--- a/Detectors/Vertexing/src/SVertexer.cxx
+++ b/Detectors/Vertexing/src/SVertexer.cxx
@@ -448,7 +448,8 @@ void SVertexer::buildT2V(const o2::globaltracking::RecoContainer& recoData) // a
     mTPCTrackClusIdx = recoData.getTPCTracksClusterRefs();
     mTPCClusterIdxStruct = &recoData.inputsTPCclusters->clusterIndex;
     mTPCRefitterShMap = recoData.clusterShMapTPC;
-    mTPCRefitter = std::make_unique<o2::gpu::GPUO2InterfaceRefit>(mTPCClusterIdxStruct, mTPCCorrMapsHelper, o2::base::Propagator::Instance()->getNominalBz(), mTPCTrackClusIdx.data(), mTPCRefitterShMap.data(), nullptr, o2::base::Propagator::Instance());
+    mTPCRefitterOccMap = mRecoCont->occupancyMapTPC;
+    mTPCRefitter = std::make_unique<o2::gpu::GPUO2InterfaceRefit>(mTPCClusterIdxStruct, mTPCCorrMapsHelper, o2::base::Propagator::Instance()->getNominalBz(), mTPCTrackClusIdx.data(), 0, mTPCRefitterShMap.data(), mTPCRefitterOccMap.data(), mTPCRefitterOccMap.size(), nullptr, o2::base::Propagator::Instance());
   }
 
   std::unordered_map<GIndex, std::pair<int, int>> tmap;
diff --git a/Detectors/ZDC/CMakeLists.txt b/Detectors/ZDC/CMakeLists.txt
index c9f51fc56c..d3c6a661a8 100644
--- a/Detectors/ZDC/CMakeLists.txt
+++ b/Detectors/ZDC/CMakeLists.txt
@@ -9,7 +9,7 @@
 # granted to it by virtue of its status as an Intergovernmental Organization
 # or submit itself to any jurisdiction.
 
-if (ONNXRuntime::ONNXRuntime_FOUND)
+if (onnxruntime_FOUND)
     add_subdirectory(fastsimulation)
 endif()
 add_subdirectory(base)
diff --git a/Detectors/ZDC/fastsimulation/CMakeLists.txt b/Detectors/ZDC/fastsimulation/CMakeLists.txt
index c3ce25b9cc..527a7ca255 100644
--- a/Detectors/ZDC/fastsimulation/CMakeLists.txt
+++ b/Detectors/ZDC/fastsimulation/CMakeLists.txt
@@ -1,20 +1,20 @@
-#  Copyright 2019-2020 CERN and copyright holders of ALICE O2.
-#  See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
-#  All rights not expressly granted are reserved.
-
-#  This software is distributed under the terms of the GNU General Public
-#  License v3 (GPL Version 3), copied verbatim in the file "COPYING".
-
-#  In applying this license CERN does not waive the privileges and immunities
-#  granted to it by virtue of its status as an Intergovernmental Organization
-#  or submit itself to any jurisdiction.
+# Copyright 2019-2020 CERN and copyright holders of ALICE O2.
+# See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
+# All rights not expressly granted are reserved.
+#
+# This software is distributed under the terms of the GNU General Public
+# License v3 (GPL Version 3), copied verbatim in the file "COPYING".
+#
+# In applying this license CERN does not waive the privileges and immunities
+# granted to it by virtue of its status as an Intergovernmental Organization
+# or submit itself to any jurisdiction.
 
 #  @author SwirtaB
 
 
 o2_add_library(FASTSimulation
         SOURCES src/FastSimulations.cxx src/Processors.cxx src/Utils.cxx
-        PUBLIC_LINK_LIBRARIES ONNXRuntime::ONNXRuntime)
+        PUBLIC_LINK_LIBRARIES onnxruntime::onnxruntime)
 
 o2_data_file(COPY scales DESTINATION Detectors/ZDC/fastsimulation)
 
@@ -22,4 +22,3 @@ o2_add_executable(fastsim-example
         SOURCES tests/run-example.cxx
         PUBLIC_LINK_LIBRARIES O2::FASTSimulation
         COMPONENT_NAME zdc)
-
diff --git a/Detectors/ZDC/fastsimulation/include/FastSimulations.h b/Detectors/ZDC/fastsimulation/include/FastSimulations.h
index 9ac2216ba0..9244ceb894 100644
--- a/Detectors/ZDC/fastsimulation/include/FastSimulations.h
+++ b/Detectors/ZDC/fastsimulation/include/FastSimulations.h
@@ -78,8 +78,8 @@ class NeuralFastSimulation
   Ort::MemoryInfo mMemoryInfo;
 
   /// Input/Output names and input shape
-  std::vector<char*> mInputNames;
-  std::vector<char*> mOutputNames;
+  std::vector<std::string> mInputNames;
+  std::vector<std::string> mOutputNames;
   std::vector<std::vector<int64_t>> mInputShapes;
   /// If model has dynamic axis (for batch processing) this will tell ONNX expected size of those axis
   /// otherwise mBatchSize has no effect during runtime
diff --git a/Detectors/ZDC/fastsimulation/src/FastSimulations.cxx b/Detectors/ZDC/fastsimulation/src/FastSimulations.cxx
index 4d3a887ea4..5351eca66e 100644
--- a/Detectors/ZDC/fastsimulation/src/FastSimulations.cxx
+++ b/Detectors/ZDC/fastsimulation/src/FastSimulations.cxx
@@ -48,13 +48,13 @@ size_t NeuralFastSimulation::getBatchSize() const
 void NeuralFastSimulation::setInputOutputData()
 {
   for (size_t i = 0; i < mSession->GetInputCount(); ++i) {
-    mInputNames.push_back(mSession->GetInputName(i, mAllocator));
+    mInputNames.push_back(mSession->GetInputNameAllocated(i, mAllocator).get());
   }
   for (size_t i = 0; i < mSession->GetInputCount(); ++i) {
     mInputShapes.emplace_back(mSession->GetInputTypeInfo(i).GetTensorTypeAndShapeInfo().GetShape());
   }
   for (size_t i = 0; i < mSession->GetOutputCount(); ++i) {
-    mOutputNames.push_back(mSession->GetOutputName(i, mAllocator));
+    mOutputNames.push_back(mSession->GetOutputNameAllocated(i, mAllocator).get());
   }
 
   // Prevent negative values from being passed as tensor shape
@@ -96,11 +96,19 @@ bool ConditionalModelSimulation::setInput(std::vector<std::vector<float>>& input
 void ConditionalModelSimulation::run()
 {
   // Run simulation (single event) with default run options
+  std::vector<const char*> tmpInputs;
+  std::vector<const char*> tmpOutputs;
+  for (unsigned int i = 0; i < mInputNames.size(); i++) {
+    tmpInputs.emplace_back(mInputNames[i].c_str());
+  }
+  for (unsigned int i = 0; i < mOutputNames.size(); i++) {
+    tmpOutputs.emplace_back(mOutputNames[i].c_str());
+  }
   mModelOutput = mSession->Run(Ort::RunOptions{nullptr},
-                               mInputNames.data(),
+                               tmpInputs.data(),
                                mInputTensors.data(),
                                mInputTensors.size(),
-                               mOutputNames.data(),
+                               tmpOutputs.data(),
                                mOutputNames.size());
   mInputTensors.clear();
 }
diff --git a/Detectors/ZDC/simulation/CMakeLists.txt b/Detectors/ZDC/simulation/CMakeLists.txt
index 96eef618c7..dda2e019c0 100644
--- a/Detectors/ZDC/simulation/CMakeLists.txt
+++ b/Detectors/ZDC/simulation/CMakeLists.txt
@@ -17,16 +17,20 @@ list(APPEND LinkLibraries O2::SimulationDataFormat
                           O2::DetectorsRaw
                           O2::Headers)
 
-if (ONNXRuntime::ONNXRuntime_FOUND)
+if (onnxruntime_FOUND)
         list(APPEND LinkLibraries O2::FASTSimulation)
 endif()
 
 o2_add_library(ZDCSimulation
+               TARGETVARNAME targetName
                SOURCES src/Detector.cxx src/Digitizer.cxx src/SimCondition.cxx
                        src/ZDCSimParam.cxx src/SpatialPhotonResponse.cxx src/Digits2Raw.cxx
                        src/DigitizerTest.cxx
                PUBLIC_LINK_LIBRARIES ${LinkLibraries})
 
+if (onnxruntime_FOUND)
+        target_compile_definitions(${targetName} PUBLIC ZDC_FASTSIM_ONNX)
+endif()
 
 o2_target_root_dictionary(ZDCSimulation
                           HEADERS include/ZDCSimulation/Digitizer.h
diff --git a/Framework/Core/include/Framework/AnalysisDataModel.h b/Framework/Core/include/Framework/AnalysisDataModel.h
index a4a8b38b36..34fe8ddf5d 100644
--- a/Framework/Core/include/Framework/AnalysisDataModel.h
+++ b/Framework/Core/include/Framework/AnalysisDataModel.h
@@ -12,9 +12,12 @@
 #define O2_FRAMEWORK_ANALYSISDATAMODEL_H_
 
 #include "Framework/ASoA.h"
+
 #include <cmath>
 #include <bitset>
 #include <numeric>
+#include <utility> // std::move
+
 #include "Framework/DataTypes.h"
 #include "CommonConstants/MathConstants.h"
 #include "CommonConstants/PhysicsConstants.h"
@@ -153,22 +156,32 @@ DECLARE_SOA_DYNAMIC_COLUMN(Pz, pz, //! Momentum in z-direction in GeV/c
                              auto pt = 1.f / std::abs(signed1Pt);
                              return pt * tgl;
                            });
-
+DECLARE_SOA_DYNAMIC_COLUMN(PVector, pVector, //! Momentum vector in x,y,z-directions in GeV/c
+                           [](float signed1Pt, float snp, float alpha, float tgl) -> std::array<float, 3> {
+                             const auto pt = 1.f / std::abs(signed1Pt);
+                             // FIXME: GCC & clang should optimize to sincosf
+                             const float cs = cosf(alpha), sn = sinf(alpha);
+                             const auto r = std::sqrt((1.f - snp) * (1.f + snp));
+                             const auto px = pt * (r * cs - snp * sn);
+                             const auto py = pt * (snp * cs + r * sn);
+                             const auto pz = pt * tgl;
+                             return std::move(std::array<float, 3>{std::move(px), std::move(py), std::move(pz)});
+                           });
 DECLARE_SOA_EXPRESSION_COLUMN(P, p, float, //! Momentum in Gev/c
                               ifnode(nabs(aod::track::signed1Pt) <= o2::constants::math::Almost0, o2::constants::math::VeryBig, 0.5f * (ntan(o2::constants::math::PIQuarter - 0.5f * natan(aod::track::tgl)) + 1.f / ntan(o2::constants::math::PIQuarter - 0.5f * natan(aod::track::tgl))) / nabs(aod::track::signed1Pt)));
 DECLARE_SOA_DYNAMIC_COLUMN(Energy, energy, //! Track energy, computed under the mass assumption given as input
                            [](float signed1Pt, float tgl, float mass) -> float {
                              const auto pt = 1.f / std::abs(signed1Pt);
-                             const auto p = 0.5f * (tan(o2::constants::math::PIQuarter - 0.5f * atan(tgl)) + 1.f / tan(o2::constants::math::PIQuarter - 0.5f * atan(tgl))) * pt;
-                             return sqrt(p * p + mass * mass);
+                             const auto p = 0.5f * (std::tan(o2::constants::math::PIQuarter - 0.5f * std::atan(tgl)) + 1.f / std::tan(o2::constants::math::PIQuarter - 0.5f * std::atan(tgl))) * pt;
+                             return std::sqrt(p * p + mass * mass);
                            });
 DECLARE_SOA_DYNAMIC_COLUMN(Rapidity, rapidity, //! Track rapidity, computed under the mass assumption given as input
                            [](float signed1Pt, float tgl, float mass) -> float {
                              const auto pt = 1.f / std::abs(signed1Pt);
                              const auto pz = pt * tgl;
-                             const auto p = 0.5f * (tan(o2::constants::math::PIQuarter - 0.5f * atan(tgl)) + 1.f / tan(o2::constants::math::PIQuarter - 0.5f * atan(tgl))) * pt;
-                             const auto energy = sqrt(p * p + mass * mass);
-                             return 0.5f * log((energy + pz) / (energy - pz));
+                             const auto p = 0.5f * (std::tan(o2::constants::math::PIQuarter - 0.5f * std::atan(tgl)) + 1.f / std::tan(o2::constants::math::PIQuarter - 0.5f * std::atan(tgl))) * pt;
+                             const auto energy = std::sqrt(p * p + mass * mass);
+                             return 0.5f * std::log((energy + pz) / (energy - pz));
                            });
 
 // TRACKPARCOV TABLE definition
@@ -367,6 +380,7 @@ DECLARE_SOA_TABLE_FULL(StoredTracks, "Tracks", "AOD", "TRACK", //! On disk versi
                        track::Px<track::Signed1Pt, track::Snp, track::Alpha>,
                        track::Py<track::Signed1Pt, track::Snp, track::Alpha>,
                        track::Pz<track::Signed1Pt, track::Tgl>,
+                       track::PVector<track::Signed1Pt, track::Snp, track::Alpha, track::Tgl>,
                        track::Energy<track::Signed1Pt, track::Tgl>,
                        track::Rapidity<track::Signed1Pt, track::Tgl>,
                        track::Sign<track::Signed1Pt>,
@@ -386,6 +400,8 @@ DECLARE_SOA_TABLE_FULL(StoredTracksIU, "Tracks_IU", "AOD", "TRACK_IU", //! On di
                        track::Px<track::Signed1Pt, track::Snp, track::Alpha>,
                        track::Py<track::Signed1Pt, track::Snp, track::Alpha>,
                        track::Pz<track::Signed1Pt, track::Tgl>,
+                       track::PVector<track::Signed1Pt, track::Snp, track::Alpha, track::Tgl>,
+                       track::Energy<track::Signed1Pt, track::Tgl>,
                        track::Rapidity<track::Signed1Pt, track::Tgl>,
                        track::Sign<track::Signed1Pt>,
                        o2::soa::Marker<2>);
diff --git a/Framework/Core/include/Framework/AnalysisManagers.h b/Framework/Core/include/Framework/AnalysisManagers.h
index 36a5d78196..c8daac1c5e 100644
--- a/Framework/Core/include/Framework/AnalysisManagers.h
+++ b/Framework/Core/include/Framework/AnalysisManagers.h
@@ -532,6 +532,15 @@ struct OptionManager {
   {
     /// Recurse, in case we are brace constructible
     if constexpr (std::is_base_of_v<ConfigurableGroup, ANY>) {
+      if constexpr (requires { x.prefix; }) {
+        homogeneous_apply_refs<true>([prefix = x.prefix]<typename C>(C& y) { // apend group prefix if set
+          if constexpr (requires { y.name; }) {
+            y.name = prefix + "." + y.name;
+          }
+          return true;
+        },
+                                     x);
+      }
       homogeneous_apply_refs<true>([&options](auto& y) { return OptionManager<std::decay_t<decltype(y)>>::appendOption(options, y); }, x);
       return true;
     } else {
diff --git a/Framework/Core/include/Framework/DataTypes.h b/Framework/Core/include/Framework/DataTypes.h
index 423a05a221..011c71fa27 100644
--- a/Framework/Core/include/Framework/DataTypes.h
+++ b/Framework/Core/include/Framework/DataTypes.h
@@ -79,8 +79,9 @@ namespace o2::aod::mcparticle::enums
 {
 enum MCParticleFlags : uint8_t {
   ProducedByTransport = 0x1,
-  FromBackgroundEvent = 0x2, // Particle from background event (may have been used several times)
-  PhysicalPrimary = 0x4      // Particle is a physical primary according to ALICE definition
+  FromBackgroundEvent = 0x2,          // Particle from background event (may have been used several times)
+  PhysicalPrimary = 0x4,              // Particle is a physical primary according to ALICE definition
+  FromOutOfBunchPileUpCollision = 0x8 // Particle from out-of-bunch pile up collision (currently Run 2 only)
 };
 } // namespace o2::aod::mcparticle::enums
 
diff --git a/Framework/Core/include/Framework/Variant.h b/Framework/Core/include/Framework/Variant.h
index d9ef196f56..b8be3a7805 100644
--- a/Framework/Core/include/Framework/Variant.h
+++ b/Framework/Core/include/Framework/Variant.h
@@ -41,16 +41,16 @@ enum class VariantType : int { Int = 0,
                                Array2DInt,
                                Array2DFloat,
                                Array2DDouble,
-                               LabeledArrayInt,
-                               LabeledArrayFloat,
-                               LabeledArrayDouble,
+                               LabeledArrayInt,    // 2D array
+                               LabeledArrayFloat,  // 2D array
+                               LabeledArrayDouble, // 2D array
                                UInt8,
                                UInt16,
                                UInt32,
                                UInt64,
                                Int8,
                                Int16,
-                               LabeledArrayString,
+                               LabeledArrayString, // 2D array
                                Empty,
                                Dict,
                                Unknown };
diff --git a/Framework/Core/src/DataProcessingDevice.cxx b/Framework/Core/src/DataProcessingDevice.cxx
index 35cc2524ed..d5a07a1ebf 100644
--- a/Framework/Core/src/DataProcessingDevice.cxx
+++ b/Framework/Core/src/DataProcessingDevice.cxx
@@ -122,7 +122,7 @@ void on_transition_requested_expired(uv_timer_t* handle)
   auto* state = (DeviceState*)handle->data;
   state->loopReason |= DeviceState::TIMER_EXPIRED;
   O2_SIGNPOST_ID_FROM_POINTER(cid, device, handle);
-  O2_SIGNPOST_EVENT_EMIT_ERROR(device, cid, "callback", "Grace period for calibration expired. Exiting.");
+  O2_SIGNPOST_EVENT_EMIT_ERROR(device, cid, "callback", "Exit transition timer expired. Exiting.");
   state->transitionHandling = TransitionHandlingState::Expired;
 }
 
diff --git a/Framework/Core/test/test_AnalysisTask.cxx b/Framework/Core/test/test_AnalysisTask.cxx
index dc550ccf3b..87c8e655d1 100644
--- a/Framework/Core/test/test_AnalysisTask.cxx
+++ b/Framework/Core/test/test_AnalysisTask.cxx
@@ -132,9 +132,11 @@ struct TestCCDBObject {
 
 struct KTask {
   struct : public ConfigurableGroup {
+    std::string prefix = "foo";
     Configurable<int> anInt{"someConfigurable", {}, "Some Configurable Object"};
     Configurable<int> anotherInt{"someOtherConfigurable", {}, "Some Configurable Object"};
   } foo;
+
   Configurable<int> anThirdInt{"someThirdConfigurable", {}, "Some Configurable Object"};
   struct : public ConditionGroup {
     Condition<TestCCDBObject> test{"path"};
diff --git a/GPU/GPUTracking/Base/GPUConstantMem.h b/GPU/GPUTracking/Base/GPUConstantMem.h
index 3f74e4482f..17e6268764 100644
--- a/GPU/GPUTracking/Base/GPUConstantMem.h
+++ b/GPU/GPUTracking/Base/GPUConstantMem.h
@@ -21,11 +21,9 @@
 #include "GPUErrors.h"
 
 // Dummies for stuff not supported in legacy code (ROOT 5 / OPENCL1.2)
-#if defined(GPUCA_NOCOMPAT_ALLCINT) && (!defined(GPUCA_GPUCODE) || !defined(GPUCA_ALIROOT_LIB))
+#if defined(GPUCA_NOCOMPAT_ALLCINT)
 #include "GPUTPCGMMerger.h"
-#include "GPUTRDTracker.h"
 #else
-#include "GPUTRDDef.h"
 namespace GPUCA_NAMESPACE
 {
 namespace gpu
@@ -33,6 +31,17 @@ namespace gpu
 class GPUTPCGMMerger
 {
 };
+} // namespace gpu
+} // namespace GPUCA_NAMESPACE
+#endif
+#if defined(GPUCA_NOCOMPAT_ALLCINT) && (!defined(GPUCA_GPUCODE) || !defined(GPUCA_ALIROOT_LIB))
+#include "GPUTRDTracker.h"
+#else
+#include "GPUTRDDef.h"
+namespace GPUCA_NAMESPACE
+{
+namespace gpu
+{
 template <class T, class P>
 class GPUTRDTracker_t
 {
diff --git a/GPU/GPUTracking/Base/GPUParam.cxx b/GPU/GPUTracking/Base/GPUParam.cxx
index 97618b0a82..e7a1232e1c 100644
--- a/GPU/GPUTracking/Base/GPUParam.cxx
+++ b/GPU/GPUTracking/Base/GPUParam.cxx
@@ -91,9 +91,7 @@ void GPUParam::SetDefaults(float solenoidBz)
 #endif
 
   par.dAlpha = 0.349066f;
-  bzkG = solenoidBz;
-  bzCLight = bzkG * GPUCA_NAMESPACE::gpu::gpu_common_constants::kCLight;
-  qptB5Scaler = CAMath::Abs(bzkG) > 0.1f ? CAMath::Abs(bzkG) / 5.006680f : 1.f;
+  UpdateBzOnly(solenoidBz);
   par.dodEdx = 0;
 
   constexpr float plusZmin = 0.0529937;
@@ -125,29 +123,19 @@ void GPUParam::SetDefaults(float solenoidBz)
   par.debugLevel = 0;
   par.resetTimers = false;
   par.earlyTpcTransform = false;
-
-  polynomialField.Reset(); // set very wrong initial value in order to see if the field was not properly initialised
-  GPUTPCGMPolynomialFieldManager::GetPolynomialField(bzkG, polynomialField);
 }
 
 void GPUParam::UpdateSettings(const GPUSettingsGRP* g, const GPUSettingsProcessing* p, const GPURecoStepConfiguration* w)
 {
   if (g) {
-    bzkG = g->solenoidBzNominalGPU;
-    bzCLight = bzkG * GPUCA_NAMESPACE::gpu::gpu_common_constants::kCLight;
+    UpdateBzOnly(g->solenoidBzNominalGPU);
     par.assumeConstantBz = g->constBz;
     par.toyMCEventsFlag = g->homemadeEvents;
     par.continuousTracking = g->continuousMaxTimeBin != 0;
     par.continuousMaxTimeBin = g->continuousMaxTimeBin == -1 ? GPUSettings::TPC_MAX_TF_TIME_BIN : g->continuousMaxTimeBin;
-    polynomialField.Reset();
-    if (par.assumeConstantBz) {
-      GPUTPCGMPolynomialFieldManager::GetPolynomialField(GPUTPCGMPolynomialFieldManager::kUniform, bzkG, polynomialField);
-    } else {
-      GPUTPCGMPolynomialFieldManager::GetPolynomialField(bzkG, polynomialField);
-    }
   }
   par.earlyTpcTransform = rec.tpc.forceEarlyTransform == -1 ? (!par.continuousTracking) : rec.tpc.forceEarlyTransform;
-  qptB5Scaler = CAMath::Abs(bzkG) > 0.1f ? CAMath::Abs(bzkG) / 5.006680f : 1.f;
+  qptB5Scaler = CAMath::Abs(bzkG) > 0.1f ? CAMath::Abs(bzkG) / 5.006680f : 1.f; // Repeat here, since passing in g is optional
   if (p) {
     par.debugLevel = p->debugLevel;
     par.resetTimers = p->resetTimers;
@@ -161,6 +149,19 @@ void GPUParam::UpdateSettings(const GPUSettingsGRP* g, const GPUSettingsProcessi
   }
 }
 
+void GPUParam::UpdateBzOnly(float newSolenoidBz)
+{
+  bzkG = newSolenoidBz;
+  bzCLight = bzkG * GPUCA_NAMESPACE::gpu::gpu_common_constants::kCLight;
+  polynomialField.Reset();
+  if (par.assumeConstantBz) {
+    GPUTPCGMPolynomialFieldManager::GetPolynomialField(GPUTPCGMPolynomialFieldManager::kUniform, bzkG, polynomialField);
+  } else {
+    GPUTPCGMPolynomialFieldManager::GetPolynomialField(bzkG, polynomialField);
+  }
+  qptB5Scaler = CAMath::Abs(bzkG) > 0.1f ? CAMath::Abs(bzkG) / 5.006680f : 1.f;
+}
+
 void GPUParam::SetDefaults(const GPUSettingsGRP* g, const GPUSettingsRec* r, const GPUSettingsProcessing* p, const GPURecoStepConfiguration* w)
 {
   SetDefaults(g->solenoidBzNominalGPU);
@@ -183,7 +184,7 @@ void GPUParam::UpdateRun3ClusterErrors(const float* yErrorParam, const float* zE
       ParamErrors[yz][rowType][0] = param[0] * param[0];
       ParamErrors[yz][rowType][1] = param[1] * param[1] * tpcGeometry.PadHeightByRegion(regionMap[rowType]);
       ParamErrors[yz][rowType][2] = param[2] * param[2] / tpcGeometry.TPCLength() / tpcGeometry.PadHeightByRegion(regionMap[rowType]);
-      ParamErrors[yz][rowType][3] = param[3] * param[3];
+      ParamErrors[yz][rowType][3] = param[3] * param[3] * rec.tpc.clusterErrorOccupancyScaler * rec.tpc.clusterErrorOccupancyScaler;
     }
   }
 #endif
@@ -217,7 +218,7 @@ void GPUParam::LoadClusterErrors(bool Print)
   for (int i = 0; i < 2; i++) {
     for (int j = 0; j < 3; j++) {
       for (int k = 0; k < 4; k++) {
-        ParamErrorsSeeding0[i][j][k] = clparam->GetParamErrorsSeeding0(i, j, k);
+        ParamErrorsSeeding0[i][j][k] = clparam->GetParamRMS0(i, j, k);
       }
     }
   }
diff --git a/GPU/GPUTracking/Base/GPUParam.h b/GPU/GPUTracking/Base/GPUParam.h
index a6c61d4a1c..a8aed7111a 100644
--- a/GPU/GPUTracking/Base/GPUParam.h
+++ b/GPU/GPUTracking/Base/GPUParam.h
@@ -82,6 +82,7 @@ struct GPUParam : public internal::GPUParam_t<GPUSettingsRec, GPUSettingsParam>
   void SetDefaults(float solenoidBz);
   void SetDefaults(const GPUSettingsGRP* g, const GPUSettingsRec* r = nullptr, const GPUSettingsProcessing* p = nullptr, const GPURecoStepConfiguration* w = nullptr);
   void UpdateSettings(const GPUSettingsGRP* g, const GPUSettingsProcessing* p = nullptr, const GPURecoStepConfiguration* w = nullptr);
+  void UpdateBzOnly(float newSolenoidBz);
   void LoadClusterErrors(bool Print = 0);
   void UpdateRun3ClusterErrors(const float* yErrorParam, const float* zErrorParam);
 #endif
diff --git a/GPU/GPUTracking/Base/GPUParam.inc b/GPU/GPUTracking/Base/GPUParam.inc
index 0b31a224fc..886b4c8227 100644
--- a/GPU/GPUTracking/Base/GPUParam.inc
+++ b/GPU/GPUTracking/Base/GPUParam.inc
@@ -53,10 +53,10 @@ GPUdi() void MEM_LG(GPUParam)::GetClusterErrorsSeeding2(char sector, int iRow, f
 }
 
 MEM_CLASS_PRE()
-GPUdi() float MEM_LG(GPUParam)::GetClusterError2(int yz, int type, float zDiff, float angle2, float scaledMult, float scaledInvAvgCharge, float scaledInvCharge) const
+GPUdi() float MEM_LG(GPUParam)::GetClusterError2(int yz, int type, float zDiff, float angle2, float unscaledMult, float scaledInvAvgCharge, float scaledInvCharge) const
 {
   MakeType(const float*) c = ParamErrors[yz][type]; // Note: c[0] = p[0]^2, c[1] = p[1]^2 * padHeight, c[2] = p[2]^2 / tpcLength / padHeight, c[3] = p[3]^2
-  float v = c[0] + c[1] * angle2 * scaledInvAvgCharge + c[2] * zDiff * scaledInvCharge + c[3] * (scaledMult * scaledMult) * (scaledInvAvgCharge * scaledInvAvgCharge);
+  float v = c[0] + c[1] * angle2 * scaledInvAvgCharge + c[2] * zDiff * scaledInvCharge + c[3] * (unscaledMult * unscaledMult) * (scaledInvAvgCharge * scaledInvAvgCharge);
   v = CAMath::Abs(v);
   v *= yz ? rec.tpc.clusterError2CorrectionZ : rec.tpc.clusterError2CorrectionY;
   v += yz ? rec.tpc.clusterError2AdditionalZ : rec.tpc.clusterError2AdditionalY;
@@ -141,7 +141,7 @@ GPUdi() void MEM_LG(GPUParam)::GetClusterErrorsSeeding2(char sector, int iRow, f
 }
 
 MEM_CLASS_PRE()
-GPUdi() float MEM_LG(GPUParam)::GetClusterError2(int yz, int type, float zDiff, float angle2, float time, float avgInvCharge, float invCharge) const
+GPUdi() float MEM_LG(GPUParam)::GetClusterError2(int yz, int type, float zDiff, float angle2, float unscaledMult, float avgInvCharge, float invCharge) const
 {
   MakeType(const float*) c = ParamS0Par[yz][type];
   float v = c[0] + c[1] * zDiff + c[2] * angle2 + c[3] * zDiff * zDiff + c[4] * angle2 * angle2 + c[5] * zDiff * angle2;
@@ -161,7 +161,7 @@ GPUdi() float MEM_LG(GPUParam)::GetSystematicClusterErrorIFC2(float trackX, floa
 }
 
 MEM_CLASS_PRE()
-GPUd() float MEM_LG(GPUParam)::GetSystematicClusterErrorC122(float trackX, float trackY, char sector) const
+GPUdi() float MEM_LG(GPUParam)::GetSystematicClusterErrorC122(float trackX, float trackY, char sector) const
 {
   return 0;
 }
@@ -182,12 +182,12 @@ GPUdi() void MEM_LG(GPUParam)::GetClusterErrors2(char sector, int iRow, float z,
   const float angleY2 = s2 * sec2;          // dy/dx
   const float angleZ2 = DzDs * DzDs * sec2; // dz/dx
 
-  const float mult = time >= 0.f ? GetScaledMult(time) / tpcGeometry.Row2X(iRow) : 0.f;
+  const float unscaledMult = time >= 0.f ? GetScaledMult(time) / tpcGeometry.Row2X(iRow) : 0.f;
   const float scaledInvAvgCharge = avgInvCharge * rec.tpc.clusterErrorChargeScaler > 0.f ? avgInvCharge * rec.tpc.clusterErrorChargeScaler : 1.f;
   const float scaledInvCharge = invCharge * rec.tpc.clusterErrorChargeScaler > 0.f ? invCharge * rec.tpc.clusterErrorChargeScaler : 1.f;
 
-  ErrY2 = GetClusterError2(0, rowType, z, angleY2, mult, scaledInvAvgCharge, scaledInvCharge);
-  ErrZ2 = GetClusterError2(1, rowType, z, angleZ2, mult, scaledInvAvgCharge, scaledInvCharge);
+  ErrY2 = GetClusterError2(0, rowType, z, angleY2, unscaledMult, scaledInvAvgCharge, scaledInvCharge);
+  ErrZ2 = GetClusterError2(1, rowType, z, angleZ2, unscaledMult, scaledInvAvgCharge, scaledInvCharge);
 }
 
 MEM_CLASS_PRE()
@@ -219,7 +219,7 @@ GPUdi() float MEM_LG(GPUParam)::GetScaledMult(float time) const
     return 0.f;
   }
   const unsigned int bin = CAMath::Max(0.f, time / rec.tpc.occupancyMapTimeBins);
-  return occupancyMap[bin] * rec.tpc.clusterErrorOccupancyScaler;
+  return occupancyMap[bin];
 #else
   return 0.f;
 #endif
diff --git a/GPU/GPUTracking/Base/GPUReconstruction.cxx b/GPU/GPUTracking/Base/GPUReconstruction.cxx
index ce6592988e..9246fc5df3 100644
--- a/GPU/GPUTracking/Base/GPUReconstruction.cxx
+++ b/GPU/GPUTracking/Base/GPUReconstruction.cxx
@@ -1049,7 +1049,11 @@ int GPUReconstruction::EnqueuePipeline(bool terminate)
   if (q->retVal) {
     return q->retVal;
   }
-  return mChains[0]->FinalizePipelinedProcessing();
+  if (terminate) {
+    return 0;
+  } else {
+    return mChains[0]->FinalizePipelinedProcessing();
+  }
 }
 
 GPUChain* GPUReconstruction::GetNextChainInQueue()
diff --git a/GPU/GPUTracking/Base/cuda/CMakeLists.txt b/GPU/GPUTracking/Base/cuda/CMakeLists.txt
index f5d32ea6c1..395e69c434 100644
--- a/GPU/GPUTracking/Base/cuda/CMakeLists.txt
+++ b/GPU/GPUTracking/Base/cuda/CMakeLists.txt
@@ -99,7 +99,6 @@ if(ALIGPU_BUILD_TYPE STREQUAL "O2")
     TARGETVARNAME targetName)
 
   target_compile_definitions(${targetName} PUBLIC $<TARGET_PROPERTY:O2::GPUTracking,COMPILE_DEFINITIONS>)
-  set_target_properties(${targetName} PROPERTIES LINKER_LANGUAGE CXX)
 
   install(FILES ${HDRS} DESTINATION include/GPU)
 endif()
@@ -118,9 +117,6 @@ if(ALIGPU_BUILD_TYPE STREQUAL "ALIROOT")
   add_library_tested(${targetName} SHARED ${SRCS} G__${targetName}.cxx)
   target_link_libraries(${targetName} PUBLIC ${TMP_BASELIB})
 
-  # Additional compilation flags
-  set_target_properties(${targetName} PROPERTIES COMPILE_FLAGS "")
-
   # Installation
   install(TARGETS ${targetName} ARCHIVE DESTINATION lib LIBRARY DESTINATION lib)
 
@@ -197,10 +193,13 @@ else()
 endif()
 if(NOT GPUCA_CUDA_COMPILE_MODE STREQUAL "rdc")
   set_property(TARGET ${targetName} PROPERTY CUDA_SEPARABLE_COMPILATION OFF)
+  set_target_properties(${targetName} PROPERTIES LINKER_LANGUAGE CXX)
 endif()
 
-add_library(GPUTrackingCUDAExternalProvider OBJECT GPUReconstructionCUDAExternalProvider.cu)
-add_library(O2::GPUTrackingCUDAExternalProvider ALIAS GPUTrackingCUDAExternalProvider)
-set_property(TARGET GPUTrackingCUDAExternalProvider PROPERTY CUDA_SEPARABLE_COMPILATION ON)
-target_compile_definitions(GPUTrackingCUDAExternalProvider PRIVATE $<TARGET_PROPERTY:${targetName},COMPILE_DEFINITIONS>)
-target_include_directories(GPUTrackingCUDAExternalProvider PRIVATE $<TARGET_PROPERTY:${targetName},INCLUDE_DIRECTORIES>)
+if(NOT ALIGPU_BUILD_TYPE STREQUAL "ALIROOT")
+  add_library(GPUTrackingCUDAExternalProvider OBJECT GPUReconstructionCUDAExternalProvider.cu)
+  add_library(O2::GPUTrackingCUDAExternalProvider ALIAS GPUTrackingCUDAExternalProvider)
+  set_property(TARGET GPUTrackingCUDAExternalProvider PROPERTY CUDA_SEPARABLE_COMPILATION ON)
+  target_compile_definitions(GPUTrackingCUDAExternalProvider PRIVATE $<TARGET_PROPERTY:${targetName},COMPILE_DEFINITIONS>)
+  target_include_directories(GPUTrackingCUDAExternalProvider PRIVATE $<TARGET_PROPERTY:${targetName},INCLUDE_DIRECTORIES>)
+endif()
diff --git a/GPU/GPUTracking/Base/hip/CMakeLists.txt b/GPU/GPUTracking/Base/hip/CMakeLists.txt
index 4a2a98dbc2..7044a8f721 100644
--- a/GPU/GPUTracking/Base/hip/CMakeLists.txt
+++ b/GPU/GPUTracking/Base/hip/CMakeLists.txt
@@ -150,22 +150,20 @@ if(ALIGPU_BUILD_TYPE STREQUAL "ALIROOT")
 
   # Generate the dictionary
   get_directory_property(incdirs INCLUDE_DIRECTORIES)
-  generate_dictionary("${targetName}" "" "GPUReconstructionHIP.h" "${incdirs} .")
+  generate_dictionary("${targetName}" "" "${GPUCA_HIP_SOURCE_DIR}/GPUReconstructionHIP.h" "${incdirs} .")
 
   # Generate the ROOT map Dependecies
   generate_rootmap("${targetName}" "" "")
 
   # Add a library to the project using the specified source files
-  add_library_tested(${targetName} SHARED ${SRCS} G__${targetName}.cxx)
+  add_library_tested(${targetName} SHARED ${SRCS})
+  set(SRCS_CXX ${SRCS_CXX} G__${targetName}.cxx) # CMake HIP language feature will parse hip flags to everything that is linked to hip libraries, so add the ROOT dictionary file here
   target_link_libraries(${targetName} PUBLIC ${TMP_BASELIB})
 
   # ROOT Cannot load this library, so we have to remove it from the list
   list(REMOVE_ITEM ALILIBSTESTED ${targetName})
   set(ALILIBSTESTED ${ALILIBSTESTED} CACHE INTERNAL "ALILIBSTESTED")
 
-  # Additional compilation flags
-  set_target_properties(${targetName} PROPERTIES COMPILE_FLAGS "")
-
   # Installation
   install(TARGETS ${targetName} ARCHIVE DESTINATION lib LIBRARY DESTINATION lib)
 
@@ -182,7 +180,7 @@ if(ALIGPU_BUILD_TYPE STREQUAL "Standalone")
   include_directories(${GPUCA_HIP_SOURCE_DIR})
 endif()
 
-add_library(${MODULE}_CXX OBJECT ${SRCS_CXX})
+add_library(${MODULE}_CXX OBJECT ${SRCS_CXX}) # Adding a C++ library for the .cxx code of the HIP library, such that it does not link to HIP libraries, and CMake HIP Language doesn't add HIP compile flags.
 target_compile_definitions(${MODULE}_CXX PRIVATE $<TARGET_PROPERTY:${TMP_BASELIB},COMPILE_DEFINITIONS>)
 target_include_directories(${MODULE}_CXX PRIVATE $<TARGET_PROPERTY:${TMP_BASELIB},INCLUDE_DIRECTORIES>)
 target_link_libraries(${targetName} PRIVATE ${MODULE}_CXX)
@@ -216,8 +214,8 @@ if(GPUCA_HIP_COMPILE_MODE STREQUAL "onefile")
 elseif(GPUCA_HIP_COMPILE_MODE STREQUAL "perkernel")
   add_library(GPUTrackingHIPKernels OBJECT $<JOIN:$<LIST:TRANSFORM,$<LIST:TRANSFORM,$<LIST:TRANSFORM,$<TARGET_PROPERTY:O2_GPU_KERNELS,O2_GPU_KERNEL_NAMES>,REPLACE,[^A-Za-z0-9]+,_>,PREPEND,${O2_GPU_KERNEL_WRAPPER_FOLDER}/krnl_>,APPEND,.cu>, >)
   set_property(TARGET GPUTrackingHIPKernels PROPERTY HIP_FATBIN_COMPILATION ON)
-  target_compile_options(GPUTrackingHIPKernels PRIVATE "-fno-gpu-rdc")
-  target_link_options(GPUTrackingHIPKernels PRIVATE "-fno-gpu-rdc")
+  target_compile_options(GPUTrackingHIPKernels PRIVATE $<$<COMPILE_LANGUAGE:HIP>:-fno-gpu-rdc>)
+  target_link_options(GPUTrackingHIPKernels PRIVATE $<$<COMPILE_LANGUAGE:HIP>:-fno-gpu-rdc>)
   target_compile_definitions(${targetName} PRIVATE GPUCA_KERNEL_COMPILE_MODE=1)
   target_compile_definitions(GPUTrackingHIPKernels PRIVATE $<TARGET_PROPERTY:${targetName},COMPILE_DEFINITIONS>)
   target_include_directories(GPUTrackingHIPKernels PRIVATE $<TARGET_PROPERTY:${targetName},INCLUDE_DIRECTORIES>)
@@ -246,20 +244,22 @@ elseif(GPUCA_HIP_COMPILE_MODE STREQUAL "perkernel")
 elseif(GPUCA_HIP_COMPILE_MODE STREQUAL "rdc")
   message(FATAL_ERROR "HIP RDC compilation of GPUReconstruction ios not yet working!")
   target_compile_definitions(${targetName} PRIVATE GPUCA_KERNEL_COMPILE_MODE=2)
-  target_compile_options(${targetName} PRIVATE "-fgpu-rdc")
-  target_link_options(${targetName} PRIVATE "-fgpu-rdc")
+  target_compile_options(${targetName} PRIVATE $<$<COMPILE_LANGUAGE:HIP>:-fgpu-rdc>)
+  target_link_options(${targetName} PRIVATE $<$<COMPILE_LANGUAGE:HIP>:-fgpu-rdc>)
   target_sources(${targetName} PRIVATE $<JOIN:$<LIST:TRANSFORM,$<LIST:TRANSFORM,$<LIST:TRANSFORM,$<TARGET_PROPERTY:O2_GPU_KERNELS,O2_GPU_KERNEL_NAMES>,REPLACE,[^A-Za-z0-9]+,_>,PREPEND,${O2_GPU_KERNEL_WRAPPER_FOLDER}/krnl_>,APPEND,.hip>, >)
 else()
   message(FATAL_ERROR "Invalid compile mode")
 endif()
 if(NOT GPUCA_HIP_COMPILE_MODE STREQUAL "rdc")
-  target_compile_options(${targetName} PRIVATE "-fno-gpu-rdc")
-  target_link_options(${targetName} PRIVATE "-fno-gpu-rdc")
+  target_compile_options(${targetName} PRIVATE $<$<COMPILE_LANGUAGE:HIP>:-fno-gpu-rdc>)
+  target_link_options(${targetName} PRIVATE $<$<COMPILE_LANGUAGE:HIP>:-fno-gpu-rdc>)
 endif()
 
-add_library(GPUTrackingHIPExternalProvider OBJECT ${GPUCA_HIP_SOURCE_DIR}/GPUReconstructionHIPExternalProvider.hip)
-add_library(O2::GPUTrackingHIPExternalProvider ALIAS GPUTrackingHIPExternalProvider)
-target_compile_options(GPUTrackingHIPExternalProvider PRIVATE "-fgpu-rdc")
-target_link_options(GPUTrackingHIPExternalProvider PRIVATE "-fgpu-rdc")
-target_compile_definitions(GPUTrackingHIPExternalProvider PRIVATE $<TARGET_PROPERTY:${targetName},COMPILE_DEFINITIONS>)
-target_include_directories(GPUTrackingHIPExternalProvider PRIVATE $<TARGET_PROPERTY:${targetName},INCLUDE_DIRECTORIES>)
+if(NOT ALIGPU_BUILD_TYPE STREQUAL "ALIROOT")
+  add_library(GPUTrackingHIPExternalProvider OBJECT ${GPUCA_HIP_SOURCE_DIR}/GPUReconstructionHIPExternalProvider.hip)
+  add_library(O2::GPUTrackingHIPExternalProvider ALIAS GPUTrackingHIPExternalProvider)
+  target_compile_options(GPUTrackingHIPExternalProvider PRIVATE $<$<COMPILE_LANGUAGE:HIP>:-fgpu-rdc>)
+  target_link_options(GPUTrackingHIPExternalProvider PRIVATE $<$<COMPILE_LANGUAGE:HIP>:-fgpu-rdc>)
+  target_compile_definitions(GPUTrackingHIPExternalProvider PRIVATE $<TARGET_PROPERTY:${targetName},COMPILE_DEFINITIONS>)
+  target_include_directories(GPUTrackingHIPExternalProvider PRIVATE $<TARGET_PROPERTY:${targetName},INCLUDE_DIRECTORIES>)
+endif()
diff --git a/GPU/GPUTracking/CMakeLists.txt b/GPU/GPUTracking/CMakeLists.txt
index 81832fe00e..6266d4962b 100644
--- a/GPU/GPUTracking/CMakeLists.txt
+++ b/GPU/GPUTracking/CMakeLists.txt
@@ -10,10 +10,11 @@
 # or submit itself to any jurisdiction.
 
 set(MODULE GPUTracking)
+cmake_minimum_required(VERSION 3.27 FATAL_ERROR)
 
 # set(CMAKE_CXX_FLAGS_${CMAKE_BUILD_TYPE_UPPER} "${CMAKE_CXX_FLAGS_${CMAKE_BUILD_TYPE_UPPER}} -O0") # to uncomment if needed, tired of typing this...
 
-if(NOT ${GPUCA_NO_FAST_MATH} AND NOT CMAKE_BUILD_TYPE_UPPER STREQUAL "DEBUG")
+if(NOT "${GPUCA_NO_FAST_MATH}" AND NOT CMAKE_BUILD_TYPE_UPPER STREQUAL "DEBUG")
   set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -ffast-math")
 endif()
 
@@ -21,9 +22,10 @@ include(cmake/helpers.cmake)
 
 if(ALIGPU_BUILD_TYPE STREQUAL "ALIROOT")
   if(ENABLE_CUDA OR ENABLE_OPENCL1 OR ENABLE_OPENCL2 OR ENABLE_HIP)
-    cmake_minimum_required(VERSION 3.13 FATAL_ERROR)
     include(FeatureSummary)
     find_package(O2GPU)
+  else()
+    include("cmake/kernel_helpers.cmake")
   endif()
 else()
   if((ALIGPU_BUILD_TYPE STREQUAL "Standalone" AND BUILD_EVENT_DISPLAY) OR (ALIGPU_BUILD_TYPE STREQUAL "O2" AND NOT CMAKE_SYSTEM_NAME STREQUAL "Darwin" AND TARGET AliceO2::DebugGUI AND OPENGL_FOUND AND GLFW_FOUND))
@@ -453,6 +455,7 @@ if(ALIGPU_BUILD_TYPE STREQUAL "ALIROOT")
                      ${SRCS_NO_CINT}
                      ${SRCS_NO_H}
                      ${SRCS_DATATYPES}
+                     ${SRCS_DATATYPE_HEADERS}
                      G__Ali${MODULE}.cxx)
   target_link_libraries(Ali${MODULE} ${LIBDEPS})
 
@@ -479,7 +482,7 @@ endif()
 
 # Main CMake part for Standalone
 if(ALIGPU_BUILD_TYPE STREQUAL "Standalone")
-  add_library(${MODULE} SHARED ${SRCS} ${SRCS_NO_CINT} ${SRCS_NO_H} ${SRCS_DATATYPES})
+  add_library(${MODULE} SHARED ${SRCS} ${SRCS_NO_CINT} ${SRCS_NO_H} ${SRCS_DATATYPES} ${SRCS_DATATYPE_HEADERS})
   set(targetName ${MODULE})
   add_library(O2::${MODULE} ALIAS ${MODULE})
   install(TARGETS ${MODULE})
diff --git a/GPU/GPUTracking/DataCompression/AliHLTTPCClusterStatComponent.cxx b/GPU/GPUTracking/DataCompression/AliHLTTPCClusterStatComponent.cxx
index 54d6db3768..3891e72a97 100644
--- a/GPU/GPUTracking/DataCompression/AliHLTTPCClusterStatComponent.cxx
+++ b/GPU/GPUTracking/DataCompression/AliHLTTPCClusterStatComponent.cxx
@@ -467,7 +467,7 @@ int AliHLTTPCClusterStatComponent::DoEvent(const AliHLTComponentEventData& evtDa
 
         if (ip != 0) {
           int rowType = padrow < 64 ? 0 : (padrow < 128 ? 2 : 1);
-          prop.Update(xyz[1], xyz[2], rowType, *mSliceParam, 0, 0, nullptr, false);
+          prop.Update(xyz[1], xyz[2], rowType, *mSliceParam, 0, 0, nullptr, false, slice > 18, -1.f, 0.f, 0.f);
         }
       }
       if (hitsUsed) {
diff --git a/GPU/GPUTracking/DataTypes/GPUO2FakeClasses.h b/GPU/GPUTracking/DataTypes/GPUO2FakeClasses.h
index 9a1db75b11..073d5e74c2 100644
--- a/GPU/GPUTracking/DataTypes/GPUO2FakeClasses.h
+++ b/GPU/GPUTracking/DataTypes/GPUO2FakeClasses.h
@@ -38,6 +38,8 @@ class TrackTPC
 };
 class CalibdEdxContainer
 {
+ public:
+  static bool isDead(int slice, int row, int pad) { return false; }
 };
 struct ClusterNative {
   GPUd() static float getTime() { return 0.f; }
diff --git a/GPU/GPUTracking/DataTypes/GPUTPCClusterOccupancyMap.cxx b/GPU/GPUTracking/DataTypes/GPUTPCClusterOccupancyMap.cxx
index b0ea414f9f..96c288d86b 100644
--- a/GPU/GPUTracking/DataTypes/GPUTPCClusterOccupancyMap.cxx
+++ b/GPU/GPUTracking/DataTypes/GPUTPCClusterOccupancyMap.cxx
@@ -19,6 +19,9 @@ using namespace GPUCA_NAMESPACE::gpu;
 
 GPUd() unsigned int GPUTPCClusterOccupancyMapBin::getNBins(const GPUParam& param)
 {
+  if (param.rec.tpc.occupancyMapTimeBins == 0) {
+    return 0;
+  }
   unsigned int maxTimeBin = param.par.continuousTracking ? param.par.continuousMaxTimeBin : TPC_MAX_TIME_BIN_TRIGGERED;
   return (maxTimeBin + param.rec.tpc.occupancyMapTimeBins) / param.rec.tpc.occupancyMapTimeBins; // Not -1, since maxTimeBin is allowed
 }
diff --git a/GPU/GPUTracking/Definitions/GPUSettingsList.h b/GPU/GPUTracking/Definitions/GPUSettingsList.h
index 92ead6858c..fb92d92716 100644
--- a/GPU/GPUTracking/Definitions/GPUSettingsList.h
+++ b/GPU/GPUTracking/Definitions/GPUSettingsList.h
@@ -46,18 +46,18 @@ AddOptionRTC(clusterError2AdditionalY, float, 0.f, "", 0, "correction (additive)
 AddOptionRTC(clusterError2AdditionalZ, float, 0.f, "", 0, "correction (additive) for the squared cluster error during tracking")
 AddOptionRTC(clusterRejectChi2TolleranceY, float, 1.f, "", 0, "Multiplicative factor multiplied onto chi2 in Y direction for cluster rejection check during track fit")
 AddOptionRTC(clusterRejectChi2TolleranceZ, float, 1.f, "", 0, "Multiplicative factor multiplied onto chi2 in Z direction for cluster rejection check during track fit")
-AddOptionRTC(clusterErrorOccupancyScaler, float, 0.f, "", 0, "Scaling factor applied to occupancy histogram bin in cluster error estimation")
-AddOptionRTC(clusterErrorChargeScaler, float, 0.f, "", 0, "Scaling factor applied to cluster charge bin in cluster error estimation")
+AddOptionRTC(clusterErrorOccupancyScaler, float, 9.95e-04f, "", 0, "Scaling factor applied to occupancy histogram bin in cluster error estimation")
+AddOptionRTC(clusterErrorChargeScaler, float, 20.f, "", 0, "Scaling factor applied to cluster charge in cluster error estimation")
 AddOptionRTC(sysClusErrorNormIFCCE, float, 1.f, "", 0, "Systematic cluster error parameterization IFCCE clInner[0]")
 AddOptionRTC(sysClusErrorSlopeIFCCE, float, 1.f / 5.f, "", 0, "Systematic cluster error parameterization IFCCE clInner[1]")
 AddOptionRTC(sysClusErrorIFCCEZRegion, float, -5.f, "", 0, "Systematic cluster error parameterization IFCCE z Region")
 AddOptionRTC(sysClusErrorslopeIFCCEZ, float, 1.f / 2.0f, "", 0, "Systematic cluster error parameterization IFCCE z Region Sigma Inverse")
-AddOptionRTC(sysClusErrorNormIFC, float, 0.f, "", 0, "Systematic cluster error parameterization IFC normalization")
-AddOptionRTC(sysClusErrorSlopeIFC, float, 0.f, "", 0, "Systematic cluster error parameterization IFC slope")
+AddOptionRTC(sysClusErrorNormIFC, float, 0.5f, "", 0, "Systematic cluster error parameterization IFC normalization")
+AddOptionRTC(sysClusErrorSlopeIFC, float, 0.2f, "", 0, "Systematic cluster error parameterization IFC slope")
 AddOptionRTC(sysClusErrorMinDist, float, 2.f, "", 0, "Systematic cluster error parameterization IFC Minimum Distance")
 AddOptionRTC(sysClusErrorMaskError, float, 5.f, "", 0, "Systematic cluster error parameterization IFC Large Error for masking")
-AddOptionRTC(sysClusErrorC12Norm, float, 0.f, "", 0, "Systematic cluster for Sector C1/2 normalization")
-AddOptionRTC(sysClusErrorC12Box, float, 0.f, "", 0, "Systematic cluster for Sector C1/2 box size")
+AddOptionRTC(sysClusErrorC12Norm, float, 5.3333333e-06f, "", 0, "Systematic cluster for Sector C1/2 normalization")
+AddOptionRTC(sysClusErrorC12Box, float, 1.1e-05f, "", 0, "Systematic cluster for Sector C1/2 box size")
 AddOptionRTC(minNClustersTrackSeed, int, -1, "", 0, "required min number of clusters on the track after track following (before merging)")
 AddOptionRTC(minNClustersFinalTrack, int, -1, "", 0, "required min number of clusters on the final track")
 AddOptionRTC(searchWindowDZDR, float, 2.5f, "", 0, "Use DZDR window for seeding instead of neighboursSearchArea")
@@ -81,8 +81,8 @@ AddOptionRTC(minTrackdEdxMax, float, 20.0f, "", 0, "min accepted dEdxMaxTPC of t
 AddOptionRTC(minTrackdEdxMax2Tot, float, 0.67f, "", 0, "min accepted dEdxMaxTPC/dEdxTotTPC of the track")
 AddOptionRTC(extraClusterErrorEdgeY2, float, 0.35f, "", 0, "Additive extra cluster error for Y2 if edge flag set")
 AddOptionRTC(extraClusterErrorEdgeZ2, float, 0.15f, "", 0, "Additive extra cluster error for Z2 if edge flag set")
-AddOptionRTC(extraClusterErrorSingleY2, float, 0.2f, "", 0, "Additive extra cluster error for Y2 if edge single set")
-AddOptionRTC(extraClusterErrorSingleZ2, float, 0.2f, "", 0, "Additive extra cluster error for Z2 if edge single set")
+AddOptionRTC(extraClusterErrorSingleY2, float, 0.04f, "", 0, "Additive extra cluster error for Y2 if single set")
+AddOptionRTC(extraClusterErrorSingleZ2, float, 0.04f, "", 0, "Additive extra cluster error for Z2 if single set")
 AddOptionRTC(extraClusterErrorSplitPadSharedSingleY2, float, 0.03f, "", 0, "Additive extra cluster error for Y2 if splitpad, shared, or single set")
 AddOptionRTC(extraClusterErrorFactorSplitPadSharedSingleY2, float, 3.0f, "", 0, "Multiplicative extra cluster error for Y2 if splitpad, shared, or single set")
 AddOptionRTC(extraClusterErrorSplitTimeSharedSingleZ2, float, 0.03f, "", 0, "Additive extra cluster error for Z2 if splittime, shared, or single set")
@@ -100,8 +100,8 @@ AddOptionRTC(rejectEdgeClustersSigmaMargin, float, 0.f, "", 0, "Margin factor fo
 AddOptionRTC(maxTimeBinAboveThresholdIn1000Bin, unsigned short, 500, "", 0, "Except pad from cluster finding if total number of charges in a fragment is above this baseline (disable = 0)")
 AddOptionRTC(maxConsecTimeBinAboveThreshold, unsigned short, 200, "", 0, "Except pad from cluster finding if number of consecutive charges in a fragment is above this baseline (disable = 0)")
 AddOptionRTC(noisyPadSaturationThreshold, unsigned short, 700, "", 0, "Threshold where a timebin is considered saturated, disabling the noisy pad check for that pad")
-AddOptionRTC(occupancyMapTimeBins, unsigned short, 100, "", 0, "Number of timebins per histogram bin of occupancy map (0 = disable occupancy map)")
-AddOptionRTC(occupancyMapTimeBinsAverage, unsigned short, 2, "", 0, "Number of timebins +/- to use for the averaging")
+AddOptionRTC(occupancyMapTimeBins, unsigned short, 16, "", 0, "Number of timebins per histogram bin of occupancy map (0 = disable occupancy map)")
+AddOptionRTC(occupancyMapTimeBinsAverage, unsigned short, 0, "", 0, "Number of timebins +/- to use for the averaging")
 AddOptionRTC(trackFitCovLimit, unsigned short, 1000, "", 0, "Abort fit when y/z cov exceed the limit")
 AddOptionRTC(addErrorsCECrossing, unsigned char, 0, "", 0, "Add additional custom track errors when crossing CE, 0 = no custom errors but att 0.5 to sigma_z^2, 1 = only to cov diagonal, 2 = preserve correlations")
 AddOptionRTC(trackMergerMinPartHits, unsigned char, 10, "", 0, "Minimum hits of track part during track merging")
@@ -179,7 +179,7 @@ AddOptionRTC(maxTrackQPtB5, float, 1.f / GPUCA_MIN_TRACK_PTB5_DEFAULT, "", 0, "r
 AddOptionRTC(nonConsecutiveIDs, char, false, "", 0, "Non-consecutive cluster IDs as in HLT, disables features that need access to slice data in TPC merger")
 AddOptionRTC(fwdTPCDigitsAsClusters, unsigned char, 0, "", 0, "Forward TPC digits as clusters (if they pass the ZS threshold)")
 AddOptionRTC(bz0Pt10MeV, unsigned char, 60, "", 0, "Nominal Pt to set when bz = 0 (in 10 MeV)")
-AddOptionRTC(fitInProjections, char, -1, "", 0, "Fit in projection, -1 to enable for all but passes but the first one")
+AddOptionRTC(fitInProjections, char, -1, "", 0, "Fit in projection, -1 to enable full fit for all but passes but the first one")
 AddOptionRTC(fitPropagateBzOnly, char, -1, "", 0, "Propagate using Bz only for n passes")
 AddOptionRTC(useMatLUT, char, 0, "", 0, "Use material lookup table for TPC refit")
 AddOptionRTC(trackingRefitGPUModel, char, 1, "", 0, "Use GPU track model for the Global Track Refit")
diff --git a/GPU/GPUTracking/Global/GPUChainITS.cxx b/GPU/GPUTracking/Global/GPUChainITS.cxx
index 127bef6d92..9e62b480bc 100644
--- a/GPU/GPUTracking/Global/GPUChainITS.cxx
+++ b/GPU/GPUTracking/Global/GPUChainITS.cxx
@@ -90,7 +90,6 @@ o2::its::TimeFrame* GPUChainITS::GetITSTimeframe()
     mFrameworkAllocator.reset(new o2::its::GPUFrameworkExternalAllocator);
     mFrameworkAllocator->setReconstructionFramework(rec());
     mITSTimeFrame->setExternalAllocator(mFrameworkAllocator.get());
-    LOGP(info, "GPUChainITS is giving me allocator: {}", (void*)mFrameworkAllocator.get());
   }
 #endif
   return mITSTimeFrame.get();
diff --git a/GPU/GPUTracking/Global/GPUChainTracking.cxx b/GPU/GPUTracking/Global/GPUChainTracking.cxx
index 1ee030f241..bd1cd9859c 100644
--- a/GPU/GPUTracking/Global/GPUChainTracking.cxx
+++ b/GPU/GPUTracking/Global/GPUChainTracking.cxx
@@ -643,9 +643,11 @@ int GPUChainTracking::DoQueuedUpdates(int stream, bool updateSlave)
     retVal = 1;
   }
   if (mUpdateNewCalibObjects) {
+#ifdef GPUCA_HAVE_O2HEADERS
     if (mNewCalibObjects->o2Propagator && ((mNewCalibObjects->o2Propagator->getGPUField() != nullptr) ^ GetProcessingSettings().o2PropagatorUseGPUField)) {
       GPUFatal("GPU magnetic field for propagator requested, but received an O2 propagator without GPU field");
     }
+#endif
     void* const* pSrc = (void* const*)mNewCalibObjects.get();
     void** pDst = (void**)&processors()->calibObjects;
     for (unsigned int i = 0; i < sizeof(processors()->calibObjects) / sizeof(void*); i++) {
@@ -768,9 +770,11 @@ int GPUChainTracking::RunChain()
     }
   }
 
+#ifdef GPUCA_HAVE_O2HEADERS
   if (GetProcessingSettings().trdTrackModelO2 ? runRecoStep(RecoStep::TRDTracking, &GPUChainTracking::RunTRDTracking<GPUTRDTrackerKernels::o2Version>) : runRecoStep(RecoStep::TRDTracking, &GPUChainTracking::RunTRDTracking<GPUTRDTrackerKernels::gpuVersion>)) {
     return 1;
   }
+#endif
 
   if (runRecoStep(RecoStep::Refit, &GPUChainTracking::RunRefit)) {
     return 1;
@@ -1010,7 +1014,9 @@ const o2::base::Propagator* GPUChainTracking::GetDeviceO2Propagator()
 void GPUChainTracking::SetO2Propagator(const o2::base::Propagator* prop)
 {
   processors()->calibObjects.o2Propagator = prop;
+#ifdef GPUCA_HAVE_O2HEADERS
   if ((prop->getGPUField() != nullptr) ^ GetProcessingSettings().o2PropagatorUseGPUField) {
     GPUFatal("GPU magnetic field for propagator requested, but received an O2 propagator without GPU field");
   }
+#endif
 }
diff --git a/GPU/GPUTracking/Global/GPUChainTrackingSliceTracker.cxx b/GPU/GPUTracking/Global/GPUChainTrackingSliceTracker.cxx
index ca6d0dd970..221d722878 100644
--- a/GPU/GPUTracking/Global/GPUChainTrackingSliceTracker.cxx
+++ b/GPU/GPUTracking/Global/GPUChainTrackingSliceTracker.cxx
@@ -146,23 +146,27 @@ int GPUChainTracking::RunTPCTrackingSlices_internal()
   }
 
   int streamOccMap = mRec->NStreams() - 1;
-  if (param().rec.tpc.occupancyMapTimeBins) {
+  if (param().rec.tpc.occupancyMapTimeBins || param().rec.tpc.sysClusErrorC12Norm) {
     AllocateRegisteredMemory(mInputsHost->mResourceOccupancyMap, mSubOutputControls[GPUTrackingOutputs::getIndex(&GPUTrackingOutputs::tpcOccupancyMap)]);
+  }
+  if (param().rec.tpc.occupancyMapTimeBins) {
     ReleaseEvent(mEvents->init);
-    auto* ptr = doGPU ? mInputsShadow->mTPCClusterOccupancyMap : mInputsHost->mTPCClusterOccupancyMap;
+    unsigned int* ptr = doGPU ? mInputsShadow->mTPCClusterOccupancyMap : mInputsHost->mTPCClusterOccupancyMap;
     auto* ptrTmp = (GPUTPCClusterOccupancyMapBin*)mRec->AllocateVolatileMemory(GPUTPCClusterOccupancyMapBin::getTotalSize(param()), doGPU);
     runKernel<GPUMemClean16>(GetGridAutoStep(streamOccMap, RecoStep::TPCSliceTracking), ptrTmp, GPUTPCClusterOccupancyMapBin::getTotalSize(param()));
     runKernel<GPUTPCCreateOccupancyMap, GPUTPCCreateOccupancyMap::fill>(GetGridBlk(GPUCA_NSLICES * GPUCA_ROW_COUNT, streamOccMap), ptrTmp);
-    runKernel<GPUTPCCreateOccupancyMap, GPUTPCCreateOccupancyMap::fold>(GetGridBlk(GPUTPCClusterOccupancyMapBin::getNBins(param()), streamOccMap), ptrTmp, ptr);
+    runKernel<GPUTPCCreateOccupancyMap, GPUTPCCreateOccupancyMap::fold>(GetGridBlk(GPUTPCClusterOccupancyMapBin::getNBins(param()), streamOccMap), ptrTmp, ptr + 2);
     mRec->ReturnVolatileMemory();
+    mInputsHost->mTPCClusterOccupancyMap[1] = param().rec.tpc.occupancyMapTimeBins * 0x10000 + param().rec.tpc.occupancyMapTimeBinsAverage;
     if (doGPU) {
-      TransferMemoryResourceLinkToHost(RecoStep::TPCSliceTracking, mInputsHost->mResourceOccupancyMap, streamOccMap, &mEvents->init);
+      GPUMemCpy(RecoStep::TPCSliceTracking, mInputsHost->mTPCClusterOccupancyMap + 2, mInputsShadow->mTPCClusterOccupancyMap + 2, sizeof(*ptr) * GPUTPCClusterOccupancyMapBin::getNBins(mRec->GetParam()), streamOccMap, false, &mEvents->init);
     } else {
       TransferMemoryResourceLinkToGPU(RecoStep::TPCSliceTracking, mInputsHost->mResourceOccupancyMap, streamOccMap, &mEvents->init);
     }
   }
-  unsigned int occupancyTotal = CAMath::Float2UIntRn(mRec->MemoryScalers()->nTPCHits / (mIOPtrs.settingsTF && mIOPtrs.settingsTF->hasNHBFPerTF ? mIOPtrs.settingsTF->nHBFPerTF : 128));
-  mRec->UpdateParamOccupancyMap(param().rec.tpc.occupancyMapTimeBins ? mInputsHost->mTPCClusterOccupancyMap : nullptr, param().rec.tpc.occupancyMapTimeBins ? mInputsShadow->mTPCClusterOccupancyMap : nullptr, occupancyTotal, streamOccMap);
+  unsigned int& occupancyTotal = *mInputsHost->mTPCClusterOccupancyMap;
+  occupancyTotal = CAMath::Float2UIntRn(mRec->MemoryScalers()->nTPCHits / (mIOPtrs.settingsTF && mIOPtrs.settingsTF->hasNHBFPerTF ? mIOPtrs.settingsTF->nHBFPerTF : 128));
+  mRec->UpdateParamOccupancyMap(param().rec.tpc.occupancyMapTimeBins ? mInputsHost->mTPCClusterOccupancyMap + 2 : nullptr, param().rec.tpc.occupancyMapTimeBins ? mInputsShadow->mTPCClusterOccupancyMap + 2 : nullptr, occupancyTotal, streamOccMap);
 
   int streamMap[NSLICES];
 
diff --git a/GPU/GPUTracking/Global/GPUChainTrackingTRD.cxx b/GPU/GPUTracking/Global/GPUChainTrackingTRD.cxx
index cf4fa40aff..8e27de9511 100644
--- a/GPU/GPUTracking/Global/GPUChainTrackingTRD.cxx
+++ b/GPU/GPUTracking/Global/GPUChainTrackingTRD.cxx
@@ -20,6 +20,7 @@
 #include "GPUTRDTrack.h"
 #include "GPUTRDTracker.h"
 #include "GPUTrackingInputProvider.h"
+#include "GPUTRDTrackerKernels.h"
 #include "utils/strtag.h"
 
 using namespace GPUCA_NAMESPACE::gpu;
@@ -28,6 +29,7 @@ using namespace o2::trd;
 template <int I>
 int GPUChainTracking::RunTRDTracking()
 {
+#ifndef GPUCA_ALIROOT_LIB
   if (!processors()->trdTrackerGPU.IsInitialized()) {
     return 1;
   }
@@ -127,6 +129,7 @@ int GPUChainTracking::RunTRDTracking()
   }
   mRec->PopNonPersistentMemory(RecoStep::TRDTracking, qStr2Tag("TRDTRACK"));
 
+#endif // GPUCA_ALIROOT_LIB
   return 0;
 }
 
@@ -195,8 +198,8 @@ int GPUChainTracking::DoTRDGPUTracking(T* externalInstance)
 }
 
 template int GPUChainTracking::RunTRDTracking<GPUTRDTrackerKernels::gpuVersion>();
-template int GPUChainTracking::RunTRDTracking<GPUTRDTrackerKernels::o2Version>();
 template int GPUChainTracking::DoTRDGPUTracking<GPUTRDTrackerKernels::gpuVersion>(GPUTRDTrackerGPU*);
 template int GPUChainTracking::DoTRDGPUTracking<GPUTRDTrackerKernels::gpuVersion>(GPUTRDTracker*);
+template int GPUChainTracking::RunTRDTracking<GPUTRDTrackerKernels::o2Version>();
 template int GPUChainTracking::DoTRDGPUTracking<GPUTRDTrackerKernels::o2Version>(GPUTRDTracker*);
 template int GPUChainTracking::DoTRDGPUTracking<GPUTRDTrackerKernels::o2Version>(GPUTRDTrackerGPU*);
diff --git a/GPU/GPUTracking/Global/GPUTrackingInputProvider.cxx b/GPU/GPUTracking/Global/GPUTrackingInputProvider.cxx
index bd066ce100..bf6cd029a9 100644
--- a/GPU/GPUTracking/Global/GPUTrackingInputProvider.cxx
+++ b/GPU/GPUTracking/Global/GPUTrackingInputProvider.cxx
@@ -79,7 +79,7 @@ void* GPUTrackingInputProvider::SetPointersInputTRD(void* mem)
 void* GPUTrackingInputProvider::SetPointersTPCOccupancyMap(void* mem)
 {
   if (mHoldTPCOccupancyMap) {
-    computePointerWithAlignment(mem, mTPCClusterOccupancyMap, GPUTPCClusterOccupancyMapBin::getNBins(mRec->GetParam()));
+    computePointerWithAlignment(mem, mTPCClusterOccupancyMap, (mRec->GetParam().rec.tpc.occupancyMapTimeBins ? GPUTPCClusterOccupancyMapBin::getNBins(mRec->GetParam()) + 1 : 0) + 1); // +1 for total occupancy estimator, +1 for sanity check information
   }
   return mem;
 }
@@ -99,6 +99,6 @@ void GPUTrackingInputProvider::SetMaxData(const GPUTrackingInOutPointers& io)
 {
   mHoldTPCZS = io.tpcZS && (mRec->GetRecoStepsGPU() & GPUDataTypes::RecoStep::TPCClusterFinding);
   mHoldTPCClusterNative = (io.tpcZS || io.tpcPackedDigits || io.clustersNative || io.tpcCompressedClusters) && (mRec->IsGPU() || io.tpcCompressedClusters);
-  mHoldTPCOccupancyMap = (io.tpcZS || io.tpcPackedDigits || io.clustersNative || io.tpcCompressedClusters) && mRec->GetParam().rec.tpc.occupancyMapTimeBins;
+  mHoldTPCOccupancyMap = (io.tpcZS || io.tpcPackedDigits || io.clustersNative || io.tpcCompressedClusters) && (mRec->GetParam().rec.tpc.occupancyMapTimeBins || mRec->GetParam().rec.tpc.sysClusErrorC12Norm);
   mHoldTPCClusterNativeOutput = io.tpcZS || io.tpcPackedDigits || io.tpcCompressedClusters;
 }
diff --git a/GPU/GPUTracking/Interface/GPUO2InterfaceRefit.cxx b/GPU/GPUTracking/Interface/GPUO2InterfaceRefit.cxx
index 5f1edc1a30..f81da3b52a 100644
--- a/GPU/GPUTracking/Interface/GPUO2InterfaceRefit.cxx
+++ b/GPU/GPUTracking/Interface/GPUO2InterfaceRefit.cxx
@@ -13,20 +13,30 @@
 /// \author David Rohr
 
 #include "GPUO2InterfaceRefit.h"
+#include "GPUO2InterfaceUtils.h"
 #include "DataFormatsTPC/ClusterNative.h"
 #include "DataFormatsTPC/TrackTPC.h"
 #include "GPUParam.h"
 #include "GPUTPCGMMergedTrackHit.h"
 #include "GPUTrackingRefit.h"
 #include "CorrectionMapsHelper.h"
+#include "GPUTPCClusterOccupancyMap.h"
 
 using namespace o2::gpu;
 using namespace o2::tpc;
 
-void GPUO2InterfaceRefit::fillSharedClustersMap(const ClusterNativeAccess* cl, const gsl::span<const TrackTPC> trks, const TPCClRefElem* trackRef, unsigned char* shmap)
+void GPUO2InterfaceRefit::fillSharedClustersAndOccupancyMap(const ClusterNativeAccess* cl, const gsl::span<const TrackTPC> trks, const TPCClRefElem* trackRef, unsigned char* shmap, unsigned int* ocmap, unsigned int nHbfPerTf, const GPUParam* param)
 {
   if (!cl || (!shmap && cl->nClustersTotal > 0)) {
-    throw std::runtime_error("Must provide clusters access and preallocated recepient for shared map");
+    throw std::runtime_error("Must provide clusters access and preallocated buffer for shared map");
+  }
+  std::unique_ptr<GPUParam> tmpParam;
+  if (param == nullptr) {
+    tmpParam = GPUO2InterfaceUtils::getFullParam(0.f, nHbfPerTf);
+    param = tmpParam.get();
+  }
+  if ((param->rec.tpc.occupancyMapTimeBins || param->rec.tpc.sysClusErrorC12Norm) && ocmap && !nHbfPerTf) {
+    throw std::runtime_error("Must provide nHbfPerTf for occupancy map");
   }
   memset(shmap, 0, sizeof(char) * cl->nClustersTotal);
   for (unsigned int i = 0; i < trks.size(); i++) {
@@ -35,25 +45,89 @@ void GPUO2InterfaceRefit::fillSharedClustersMap(const ClusterNativeAccess* cl, c
       shmap[idx] = shmap[idx] ? 2 : 1;
     }
   }
+  std::vector<unsigned int> tmp;
+  unsigned int* binmap = nullptr;
+  if (ocmap && nHbfPerTf) {
+    tmp.resize(param->rec.tpc.occupancyMapTimeBinsAverage ? GPUTPCClusterOccupancyMapBin::getNBins(*param) : 0, 0);
+    binmap = param->rec.tpc.occupancyMapTimeBinsAverage ? tmp.data() : (ocmap + 2);
+    *ocmap = cl->nClustersTotal / nHbfPerTf;
+    if (param->rec.tpc.occupancyMapTimeBins) {
+      ocmap[1] = param->rec.tpc.occupancyMapTimeBins * 0x10000 + param->rec.tpc.occupancyMapTimeBinsAverage;
+    }
+  }
+
   for (unsigned int i = 0; i < cl->nClustersTotal; i++) {
     shmap[i] = (shmap[i] > 1 ? GPUTPCGMMergedTrackHit::flagShared : 0) | cl->clustersLinear[i].getFlags();
+    if (binmap) {
+      binmap[(unsigned int)(cl->clustersLinear[i].getTime() / param->rec.tpc.occupancyMapTimeBins)]++;
+    }
+  }
+
+  if (ocmap && nHbfPerTf && param->rec.tpc.occupancyMapTimeBinsAverage) {
+    for (unsigned int bin = 0; bin < GPUTPCClusterOccupancyMapBin::getNBins(*param); bin++) {
+      int binmin = CAMath::Max<int>(0, bin - param->rec.tpc.occupancyMapTimeBinsAverage);
+      int binmax = CAMath::Min<int>(GPUTPCClusterOccupancyMapBin::getNBins(*param), bin + param->rec.tpc.occupancyMapTimeBinsAverage + 1);
+      unsigned int sum = 0;
+      for (int i = binmin; i < binmax; i++) {
+        sum += binmap[i];
+      }
+      sum /= binmax - binmin;
+      ocmap[2 + bin] = sum;
+    }
   }
 }
 
-GPUO2InterfaceRefit::GPUO2InterfaceRefit(const ClusterNativeAccess* cl, const CorrectionMapsHelper* trans, float bzNominalGPU, const TPCClRefElem* trackRef, const unsigned char* sharedmap, const std::vector<TrackTPC>* trks, o2::base::Propagator* p) : mParam(new GPUParam)
+size_t GPUO2InterfaceRefit::fillOccupancyMapGetSize(unsigned int nHbfPerTf, const GPUParam* param)
 {
+  std::unique_ptr<GPUParam> tmpParam;
+  if (param == nullptr) {
+    tmpParam = GPUO2InterfaceUtils::getFullParam(0.f, nHbfPerTf);
+    param = tmpParam.get();
+  }
+  if ((param->rec.tpc.occupancyMapTimeBins || param->rec.tpc.sysClusErrorC12Norm) && !nHbfPerTf) {
+    throw std::runtime_error("nHbfPerTf must not be zero for creation of the occupancy map");
+  }
+  if (param->rec.tpc.occupancyMapTimeBins) {
+    return (GPUTPCClusterOccupancyMapBin::getNBins(*param) + 2) * sizeof(unsigned int);
+  } else if (param->rec.tpc.sysClusErrorC12Norm) {
+    return sizeof(unsigned int);
+  } else {
+    return 0;
+  }
+}
+
+GPUO2InterfaceRefit::GPUO2InterfaceRefit(const ClusterNativeAccess* cl, const CorrectionMapsHelper* trans, float bzNominalGPU, const TPCClRefElem* trackRef, unsigned int nHbfPerTf, const unsigned char* sharedmap, const unsigned int* occupancymap, int occupancyMapSize, const std::vector<TrackTPC>* trks, o2::base::Propagator* p)
+{
+  mParam = GPUO2InterfaceUtils::getFullParam(bzNominalGPU, nHbfPerTf);
+  size_t expectedSharedMapSize = nHbfPerTf ? fillOccupancyMapGetSize(nHbfPerTf, mParam.get()) : 0;
   if (cl->nClustersTotal) {
     if (sharedmap == nullptr && trks == nullptr) {
       throw std::runtime_error("Must provide either shared cluster map or vector of tpc tracks to build the map");
     }
+    if ((sharedmap == nullptr) ^ (expectedSharedMapSize && occupancymap == nullptr)) {
+      throw std::runtime_error("Must provide either both shared cluster map and occupancy map or none of them");
+    }
     if (sharedmap == nullptr) {
       mSharedMap.resize(cl->nClustersTotal);
       sharedmap = mSharedMap.data();
-      fillSharedClustersMap(cl, *trks, trackRef, mSharedMap.data());
+      mOccupancyMap.resize(expectedSharedMapSize / sizeof(*mOccupancyMap.data()));
+      occupancymap = mOccupancyMap.data();
+      fillSharedClustersAndOccupancyMap(cl, *trks, trackRef, mSharedMap.data(), mOccupancyMap.data(), nHbfPerTf, mParam.get());
     }
   }
+  if (occupancymap && occupancyMapSize > sizeof(*occupancymap) && occupancymap[1] != (mParam->rec.tpc.occupancyMapTimeBins * 0x10000 + mParam->rec.tpc.occupancyMapTimeBinsAverage)) {
+    throw std::runtime_error("Occupancy map has invalid paramters occupancyMapTimeBins and occupancyMapTimeBinsAverage");
+  }
+  if (occupancyMapSize != -1 && nHbfPerTf && (size_t)occupancyMapSize != expectedSharedMapSize) {
+    throw std::runtime_error("Received occupancy map of wrong size, most likely --configKeyValues or HBperTF of map creator and map consumer are different");
+  }
   mRefit = std::make_unique<GPUTrackingRefit>();
-  mParam->SetDefaults(bzNominalGPU);
+  if (occupancymap) {
+    mParam->occupancyTotal = *occupancymap;
+    if (mParam->rec.tpc.occupancyMapTimeBins) {
+      mParam->occupancyMap = occupancymap + 2;
+    }
+  }
   mRefit->SetGPUParam(mParam.get());
   mRefit->SetClusterStateArray(sharedmap);
   mRefit->SetPropagator(p);
@@ -64,8 +138,7 @@ GPUO2InterfaceRefit::GPUO2InterfaceRefit(const ClusterNativeAccess* cl, const Co
 
 void GPUO2InterfaceRefit::updateCalib(const CorrectionMapsHelper* trans, float bzNominalGPU)
 {
-  mParam->SetDefaults(bzNominalGPU);
-  mRefit->SetGPUParam(mParam.get());
+  mParam->UpdateBzOnly(bzNominalGPU);
   mRefit->SetFastTransformHelper(trans);
 }
 
@@ -74,7 +147,6 @@ int GPUO2InterfaceRefit::RefitTrackAsTrackParCov(o2::tpc::TrackTPC& trk, bool ou
 int GPUO2InterfaceRefit::RefitTrackAsGPU(o2::track::TrackParCov& trk, const o2::tpc::TrackTPCClusRef& clusRef, float time0, float* chi2, bool outward, bool resetCov) { return mRefit->RefitTrackAsGPU(trk, clusRef, time0, chi2, outward, resetCov); }
 int GPUO2InterfaceRefit::RefitTrackAsTrackParCov(o2::track::TrackParCov& trk, const o2::tpc::TrackTPCClusRef& clusRef, float time0, float* chi2, bool outward, bool resetCov) { return mRefit->RefitTrackAsTrackParCov(trk, clusRef, time0, chi2, outward, resetCov); }
 void GPUO2InterfaceRefit::setIgnoreErrorsAtTrackEnds(bool v) { mRefit->mIgnoreErrorsOnTrackEnds = v; }
-void GPUO2InterfaceRefit::setGPUTrackFitInProjections(bool v) { mParam->rec.fitInProjections = v; }
 void GPUO2InterfaceRefit::setTrackReferenceX(float v) { mParam->rec.tpc.trackReferenceX = v; }
 
 GPUO2InterfaceRefit::~GPUO2InterfaceRefit() = default;
diff --git a/GPU/GPUTracking/Interface/GPUO2InterfaceRefit.h b/GPU/GPUTracking/Interface/GPUO2InterfaceRefit.h
index e6805ade13..5803dfbd68 100644
--- a/GPU/GPUTracking/Interface/GPUO2InterfaceRefit.h
+++ b/GPU/GPUTracking/Interface/GPUO2InterfaceRefit.h
@@ -68,25 +68,32 @@ class GPUO2InterfaceRefit
   // - In any case: Cluster Native access structure (cl), TPC Fast Transformation helper instance (trans), solenoid field (bz), TPC Track hit references (trackRef)
   // - Either the shared cluster map (sharedmap) or the vector of tpc tracks (trks) to build the shared cluster map internally
   // - o2::base::Propagator (p) in case RefitTrackAsTrackParCov is to be used
+  // - In case the --configKeyValues defining GPUParam settings require an occupancy map for TPC error estimation, the map must either be provided as occupancymap, or nHbfPerTf must be set non-zero
 
-  GPUO2InterfaceRefit(const o2::tpc::ClusterNativeAccess* cl, const o2::gpu::CorrectionMapsHelper* trans, float bzNominalGPU, const o2::tpc::TPCClRefElem* trackRef, const unsigned char* sharedmap = nullptr, const std::vector<o2::tpc::TrackTPC>* trks = nullptr, o2::base::Propagator* p = nullptr);
+  GPUO2InterfaceRefit(const o2::tpc::ClusterNativeAccess* cl, const o2::gpu::CorrectionMapsHelper* trans, float bzNominalGPU, const o2::tpc::TPCClRefElem* trackRef, unsigned int nHbfPerTf = 0, const unsigned char* sharedmap = nullptr, const unsigned int* occupancymap = nullptr, int occupancyMapSize = -1, const std::vector<o2::tpc::TrackTPC>* trks = nullptr, o2::base::Propagator* p = nullptr);
   ~GPUO2InterfaceRefit();
 
   int RefitTrackAsGPU(o2::tpc::TrackTPC& trk, bool outward = false, bool resetCov = false);
   int RefitTrackAsTrackParCov(o2::tpc::TrackTPC& trk, bool outward = false, bool resetCov = false);
   int RefitTrackAsGPU(o2::track::TrackParCov& trk, const o2::tpc::TrackTPCClusRef& clusRef, float time0, float* chi2 = nullptr, bool outward = false, bool resetCov = false);
   int RefitTrackAsTrackParCov(o2::track::TrackParCov& trk, const o2::tpc::TrackTPCClusRef& clusRef, float time0, float* chi2 = nullptr, bool outward = false, bool resetCov = false);
-  void setGPUTrackFitInProjections(bool v = true);
   void setTrackReferenceX(float v);
   void setIgnoreErrorsAtTrackEnds(bool v);
   void updateCalib(const o2::gpu::CorrectionMapsHelper* trans, float bzNominalGPU);
 
-  static void fillSharedClustersMap(const o2::tpc::ClusterNativeAccess* cl, const gsl::span<const o2::tpc::TrackTPC> trks, const o2::tpc::TPCClRefElem* trackRef, unsigned char* shmap);
+  // To create shared cluster maps and occupancy maps.
+  // param is an optional parameter to override the param object, by default a default object from --configKeyValues is used.
+  // If the param object / default object requires an occupancy map, an occupancy map ptr and nHbfPerTf value must be provided.
+  // You can use the function fillOccupancyMapGetSize(...) to get the required size of the occupancy map. If 0 is returned, no map is required.
+  // Providing only the shmap ptr but no ocmap ptr will create only the shared map, but no occupancy map.
+  static void fillSharedClustersAndOccupancyMap(const o2::tpc::ClusterNativeAccess* cl, const gsl::span<const o2::tpc::TrackTPC> trks, const o2::tpc::TPCClRefElem* trackRef, unsigned char* shmap, unsigned int* ocmap = nullptr, unsigned int nHbfPerTf = 0, const GPUParam* param = nullptr);
+  static size_t fillOccupancyMapGetSize(unsigned int nHbfPerTf, const GPUParam* param = nullptr);
 
  private:
   std::unique_ptr<GPUTrackingRefit> mRefit;
   std::unique_ptr<GPUParam> mParam;
   std::vector<unsigned char> mSharedMap;
+  std::vector<unsigned int> mOccupancyMap;
 };
 } // namespace o2::gpu
 
diff --git a/GPU/GPUTracking/Interface/GPUO2InterfaceUtils.cxx b/GPU/GPUTracking/Interface/GPUO2InterfaceUtils.cxx
index e974704ea9..cc4254f715 100644
--- a/GPU/GPUTracking/Interface/GPUO2InterfaceUtils.cxx
+++ b/GPU/GPUTracking/Interface/GPUO2InterfaceUtils.cxx
@@ -77,3 +77,39 @@ void GPUO2InterfaceUtils::GPUReconstructionZSDecoder::DecodePage(std::vector<o2:
   }
   mDecoders[hdr->version](outputBuffer, page, tfFirstOrbit, triggerBC);
 }
+
+std::unique_ptr<GPUParam> GPUO2InterfaceUtils::getFullParam(float solenoidBz, unsigned int nHbfPerTf, std::unique_ptr<GPUO2InterfaceConfiguration>* pConfiguration, std::unique_ptr<GPUSettingsO2>* pO2Settings, bool* autoMaxTimeBin)
+{
+  std::unique_ptr<GPUParam> retVal = std::make_unique<GPUParam>();
+  std::unique_ptr<GPUO2InterfaceConfiguration> tmpConfig;
+  if (!pConfiguration) {
+    tmpConfig = std::make_unique<GPUO2InterfaceConfiguration>();
+    pConfiguration = &tmpConfig;
+  } else if (!*pConfiguration) {
+    *pConfiguration = std::make_unique<GPUO2InterfaceConfiguration>();
+  }
+  (*pConfiguration)->configGRP.solenoidBzNominalGPU = solenoidBz;
+  if (pO2Settings && *pO2Settings) {
+    **pO2Settings = (*pConfiguration)->ReadConfigurableParam();
+  } else if (pO2Settings) {
+    *pO2Settings = std::make_unique<GPUSettingsO2>((*pConfiguration)->ReadConfigurableParam());
+  } else {
+    (*pConfiguration)->ReadConfigurableParam();
+  }
+  if (nHbfPerTf == 0) {
+    nHbfPerTf = 256;
+  }
+  if (autoMaxTimeBin) {
+    *autoMaxTimeBin = (*pConfiguration)->configGRP.continuousMaxTimeBin == -1;
+  }
+  if ((*pConfiguration)->configGRP.continuousMaxTimeBin == -1) {
+    (*pConfiguration)->configGRP.continuousMaxTimeBin = (nHbfPerTf * o2::constants::lhc::LHCMaxBunches + 2 * o2::tpc::constants::LHCBCPERTIMEBIN - 2) / o2::tpc::constants::LHCBCPERTIMEBIN;
+  }
+  retVal->SetDefaults(&(*pConfiguration)->configGRP, &(*pConfiguration)->configReconstruction, &(*pConfiguration)->configProcessing, nullptr);
+  return retVal;
+}
+
+std::shared_ptr<GPUParam> GPUO2InterfaceUtils::getFullParamShared(float solenoidBz, unsigned int nHbfPerTf, std::unique_ptr<GPUO2InterfaceConfiguration>* pConfiguration, std::unique_ptr<GPUSettingsO2>* pO2Settings, bool* autoMaxTimeBin)
+{
+  return std::move(getFullParam(solenoidBz, nHbfPerTf, pConfiguration, pO2Settings, autoMaxTimeBin));
+}
diff --git a/GPU/GPUTracking/Interface/GPUO2InterfaceUtils.h b/GPU/GPUTracking/Interface/GPUO2InterfaceUtils.h
index f5be1f2d99..c375f4d646 100644
--- a/GPU/GPUTracking/Interface/GPUO2InterfaceUtils.h
+++ b/GPU/GPUTracking/Interface/GPUO2InterfaceUtils.h
@@ -38,6 +38,7 @@ namespace o2::gpu
 {
 struct GPUParam;
 struct GPUO2InterfaceConfiguration;
+struct GPUSettingsO2;
 struct TPCPadGainCalib;
 class GPUO2InterfaceUtils
 {
@@ -54,6 +55,8 @@ class GPUO2InterfaceUtils
   {
     return (5.00668f / 30000.f) * src.getL3Current();
   }
+  static std::unique_ptr<GPUParam> getFullParam(float solenoidBz, unsigned int nHbfPerTf = 0, std::unique_ptr<GPUO2InterfaceConfiguration>* pConfiguration = nullptr, std::unique_ptr<GPUSettingsO2>* pO2Settings = nullptr, bool* autoMaxTimeBin = nullptr);
+  static std::shared_ptr<GPUParam> getFullParamShared(float solenoidBz, unsigned int nHbfPerTf = 0, std::unique_ptr<GPUO2InterfaceConfiguration>* pConfiguration = nullptr, std::unique_ptr<GPUSettingsO2>* pO2Settings = nullptr, bool* autoMaxTimeBin = nullptr); // Return owning pointer
 
   class GPUReconstructionZSDecoder
   {
diff --git a/GPU/GPUTracking/Merger/GPUTPCGMMergerGPU.cxx b/GPU/GPUTracking/Merger/GPUTPCGMMergerGPU.cxx
index ec26f92780..1a9f9c5365 100644
--- a/GPU/GPUTracking/Merger/GPUTPCGMMergerGPU.cxx
+++ b/GPU/GPUTracking/Merger/GPUTPCGMMergerGPU.cxx
@@ -12,6 +12,7 @@
 /// \file GPUTPCGMMergerGPU.cxx
 /// \author David Rohr
 
+#if !defined(GPUCA_GPUCODE) || !defined(GPUCA_ALIROOT_LIB) // GPU Merger was not available for Run 2
 #include "GPUTPCGMMergerGPU.h"
 #include "GPUCommonAlgorithm.h"
 #if defined(WITH_OPENMP) && !defined(GPUCA_GPUCODE)
@@ -217,3 +218,4 @@ GPUdii() void GPUTPCGMMergerMergeLoopers::Thread<2>(int nBlocks, int nThreads, i
 {
   merger.MergeLoopersMain(nBlocks, nThreads, iBlock, iThread);
 }
+#endif // !defined(GPUCA_GPUCODE) || !defined(GPUCA_ALIROOT_LIB)
diff --git a/GPU/GPUTracking/Refit/GPUTrackingRefit.cxx b/GPU/GPUTracking/Refit/GPUTrackingRefit.cxx
index 9cb0a485f9..6f8450385e 100644
--- a/GPU/GPUTracking/Refit/GPUTrackingRefit.cxx
+++ b/GPU/GPUTracking/Refit/GPUTrackingRefit.cxx
@@ -249,8 +249,12 @@ GPUd() int GPUTrackingRefit::RefitTrack(T& trkX, bool outward, bool resetCov)
   int lastSector = -1, currentSector = -1, currentRow = -1;
   short clusterState = 0, nextState = 0;
   int nFitted = 0;
+  float sumInvSqrtCharge = 0.f;
+  int nAvgCharge = 0;
+
   for (int i = start; i != stop; i += cl ? 0 : direction) {
     float x = 0, y = 0, z = 0, charge = 0; // FIXME: initialization unneeded, but GCC incorrectly produces uninitialized warnings otherwise
+    float time = 0.f, invCharge = 0.f, invSqrtCharge = 0.f; // Same here...
     int clusters = 0;
     while (true) {
       if (!cl) {
@@ -292,6 +296,9 @@ GPUd() int GPUTrackingRefit::RefitTrack(T& trkX, bool outward, bool resetCov)
           currentSector = sector;
           charge = cl->qTot;
           clusterState = nextState;
+          time = cl->getTime();
+          invSqrtCharge = CAMath::InvSqrt(cl->qMax);
+          invCharge = (1.f / cl->qMax);
         } else {
           float xx, yy, zz;
           mPfastTransformHelper->Transform(sector, row, cl->getPad(), cl->getTime(), xx, yy, zz, tOffset);
@@ -320,6 +327,9 @@ GPUd() int GPUTrackingRefit::RefitTrack(T& trkX, bool outward, bool resetCov)
       CADEBUG(printf("\tMerged Hit  Row %3d: Cluster Alpha %8.3f %3d, X %8.3f - Y %8.3f, Z %8.3f - State %d\n", row, mPparam->Alpha(sector), (int)sector, x, y, z, (int)clusterState));
     }
 
+    float invAvgCharge = (sumInvSqrtCharge += invSqrtCharge) / ++nAvgCharge;
+    invAvgCharge *= invAvgCharge;
+
     if constexpr (std::is_same_v<S, GPUTPCGMTrackParam>) {
       if (prop.PropagateToXAlpha(x, mPparam->Alpha(currentSector), !outward)) {
         IgnoreErrors(trk.GetSinPhi());
@@ -341,7 +351,7 @@ GPUd() int GPUTrackingRefit::RefitTrack(T& trkX, bool outward, bool resetCov)
       }
       CADEBUG(printf("\t%21sPropaga Alpha %8.3f    , X %8.3f - Y %8.3f, Z %8.3f   -   QPt %7.2f (%7.2f), SP %5.2f (%5.2f)   ---   Res %8.3f %8.3f   ---   Cov sY %8.3f sZ %8.3f sSP %8.3f sPt %8.3f   -   YPt %8.3f\n", "", prop.GetAlpha(), x, trk.Par()[0], trk.Par()[1], trk.Par()[4], prop.GetQPt0(), trk.Par()[2], prop.GetSinPhi0(), trk.Par()[0] - y, trk.Par()[1] - z, sqrtf(trk.Cov()[0]), sqrtf(trk.Cov()[2]), sqrtf(trk.Cov()[5]), sqrtf(trk.Cov()[14]), trk.Cov()[10]));
       lastSector = sector;
-      if (prop.Update(y, z, row, *mPparam, clusterState, 0, nullptr, true, sector, -1.f, 0.f, 0.f)) { // TODO: Use correct time, avgCharge
+      if (prop.Update(y, z, row, *mPparam, clusterState, 0, nullptr, true, sector, time, invAvgCharge, invCharge)) {
         IgnoreErrors(trk.GetSinPhi());
         return -3;
       }
@@ -374,7 +384,7 @@ GPUd() int GPUTrackingRefit::RefitTrack(T& trkX, bool outward, bool resetCov)
       CADEBUG(printf("\t%21sPropaga Alpha %8.3f    , X %8.3f - Y %8.3f, Z %8.3f   -   QPt %7.2f (%7.2f), SP %5.2f (%5.2f)   ---   Res %8.3f %8.3f   ---   Cov sY %8.3f sZ %8.3f sSP %8.3f sPt %8.3f   -   YPt %8.3f\n", "", trk.getAlpha(), x, trk.getParams()[0], trk.getParams()[1], trk.getParams()[4], trk.getParams()[4], trk.getParams()[2], trk.getParams()[2], trk.getParams()[0] - y, trk.getParams()[1] - z, sqrtf(trk.getCov()[0]), sqrtf(trk.getCov()[2]), sqrtf(trk.getCov()[5]), sqrtf(trk.getCov()[14]), trk.getCov()[10]));
       gpu::gpustd::array<float, 2> p = {y, z};
       gpu::gpustd::array<float, 3> c = {0, 0, 0};
-      GPUTPCGMPropagator::GetErr2(c[0], c[2], *mPparam, getPar(trk)[2], getPar(trk)[3], z, x, y, currentRow, clusterState, sector, -1.f, 0.f, 0.f, false); // Use correct time / avergage cluster charge
+      GPUTPCGMPropagator::GetErr2(c[0], c[2], *mPparam, getPar(trk)[2], getPar(trk)[3], z, x, y, currentRow, clusterState, sector, time, invAvgCharge, invCharge, false);
       TrackParCovChi2 += trk.getPredictedChi2(p, c);
       if (!trk.update(p, c)) {
         IgnoreErrors(trk.getSnp());
diff --git a/GPU/GPUTracking/TPCClusterFinder/GPUTPCCFStreamCompaction.cxx b/GPU/GPUTracking/TPCClusterFinder/GPUTPCCFStreamCompaction.cxx
index 2477593600..f4489146f5 100644
--- a/GPU/GPUTracking/TPCClusterFinder/GPUTPCCFStreamCompaction.cxx
+++ b/GPU/GPUTracking/TPCClusterFinder/GPUTPCCFStreamCompaction.cxx
@@ -24,106 +24,101 @@ using namespace GPUCA_NAMESPACE::gpu::tpccf;
 template <>
 GPUdii() void GPUTPCCFStreamCompaction::Thread<GPUTPCCFStreamCompaction::scanStart>(int nBlocks, int nThreads, int iBlock, int iThread, GPUSharedMemory& smem, processorType& clusterer, int iBuf, int stage)
 {
-  int nElems = compactionElems(clusterer, stage);
-  nativeScanUpStartImpl(get_num_groups(0), get_local_size(0), get_group_id(0), get_local_id(0), smem, clusterer.mPisPeak, clusterer.mPbuf + (iBuf - 1) * clusterer.mBufSize, clusterer.mPbuf + iBuf * clusterer.mBufSize, nElems);
-}
+  int nElems = CompactionElems(clusterer, stage);
 
-GPUdii() void GPUTPCCFStreamCompaction::nativeScanUpStartImpl(int nBlocks, int nThreads, int iBlock, int iThread, GPUSharedMemory& smem,
-                                                              const uchar* predicate,
-                                                              int* sums,
-                                                              int* incr, int nElems)
-{
-  int idx = get_global_id(0);
+  const auto* predicate = clusterer.mPisPeak;
+  auto* scanOffset = clusterer.GetScanBuffer(iBuf);
+
+  int iThreadGlobal = get_global_id(0);
   int pred = 0;
-  if (idx < nElems) {
-    pred = predicate[idx];
+  if (iThreadGlobal < nElems) {
+    pred = predicate[iThreadGlobal];
   }
 
-  int scanRes = CfUtils::blockPredicateSum<GPUCA_THREAD_COUNT_SCAN>(smem, pred);
+  int nElemsInBlock = CfUtils::blockPredicateSum<GPUCA_THREAD_COUNT_SCAN>(smem, pred);
 
-  int lid = get_local_id(0);
-  int lastItem = get_local_size(0) - 1;
-  int gid = get_group_id(0);
-
-  if (lid == lastItem) {
-    incr[gid] = scanRes;
+  int lastThread = nThreads - 1;
+  if (iThread == lastThread) {
+    scanOffset[iBlock] = nElemsInBlock;
   }
 }
 
 template <>
 GPUdii() void GPUTPCCFStreamCompaction::Thread<GPUTPCCFStreamCompaction::scanUp>(int nBlocks, int nThreads, int iBlock, int iThread, GPUSharedMemory& smem, processorType& clusterer, int iBuf, int nElems)
 {
-  nativeScanUpImpl(get_num_groups(0), get_local_size(0), get_group_id(0), get_local_id(0), smem, clusterer.mPbuf + (iBuf - 1) * clusterer.mBufSize, clusterer.mPbuf + iBuf * clusterer.mBufSize, nElems);
-}
-
-GPUdii() void GPUTPCCFStreamCompaction::nativeScanUpImpl(int nBlocks, int nThreads, int iBlock, int iThread, GPUSharedMemory& smem,
-                                                         int* sums,
-                                                         int* incr, int nElems)
-{
-  int idx = get_global_id(0);
-  int scanRes = work_group_scan_inclusive_add((idx < nElems) ? sums[idx] : 0);
-
-  /* DBGPR_2("ScanUp: idx = %d, res = %d", idx, scanRes); */
-
-  sums[idx] = scanRes;
+  auto* scanOffset = clusterer.GetScanBuffer(iBuf - 1);
+  auto* scanOffsetNext = clusterer.GetScanBuffer(iBuf);
 
-  int lid = get_local_id(0);
-  int lastItem = get_local_size(0) - 1;
-  int gid = get_group_id(0);
+  int iThreadGlobal = get_global_id(0);
+  int offsetInBlock = work_group_scan_inclusive_add((iThreadGlobal < nElems) ? scanOffset[iThreadGlobal] : 0);
 
-  /* DBGPR_1("ScanUp: idx = %d", idx); */
+  // TODO: This write isn't needed??
+  scanOffset[iThreadGlobal] = offsetInBlock;
 
-  if (lid == lastItem) {
-    incr[gid] = scanRes;
+  int lastThread = nThreads - 1;
+  if (iThread == lastThread) {
+    scanOffsetNext[iBlock] = offsetInBlock;
   }
 }
 
 template <>
 GPUdii() void GPUTPCCFStreamCompaction::Thread<GPUTPCCFStreamCompaction::scanTop>(int nBlocks, int nThreads, int iBlock, int iThread, GPUSharedMemory& smem, processorType& clusterer, int iBuf, int nElems)
 {
-  nativeScanTopImpl(get_num_groups(0), get_local_size(0), get_group_id(0), get_local_id(0), smem, clusterer.mPbuf + (iBuf - 1) * clusterer.mBufSize, nElems);
-}
+  int iThreadGlobal = get_global_id(0);
+  int* scanOffset = clusterer.GetScanBuffer(iBuf - 1);
 
-GPUdii() void GPUTPCCFStreamCompaction::nativeScanTopImpl(int nBlocks, int nThreads, int iBlock, int iThread, GPUSharedMemory& smem, int* incr, int nElems)
-{
-  int idx = get_global_id(0);
+  bool inBounds = (iThreadGlobal < nElems);
 
-  /* DBGPR_1("ScanTop: idx = %d", idx); */
+  int offsetInBlock = work_group_scan_inclusive_add(inBounds ? scanOffset[iThreadGlobal] : 0);
 
-  int scanRes = work_group_scan_inclusive_add((idx < nElems) ? incr[idx] : 0);
-  incr[idx] = scanRes;
+  if (inBounds) {
+    scanOffset[iThreadGlobal] = offsetInBlock;
+  }
 }
 
 template <>
-GPUdii() void GPUTPCCFStreamCompaction::Thread<GPUTPCCFStreamCompaction::scanDown>(int nBlocks, int nThreads, int iBlock, int iThread, GPUSharedMemory& smem, processorType& clusterer, int iBuf, unsigned int offset, int nElems)
+GPUdii() void GPUTPCCFStreamCompaction::Thread<GPUTPCCFStreamCompaction::scanDown>(int nBlocks, int nThreads, int iBlock, int iThread, GPUSharedMemory& /*smem*/, processorType& clusterer, int iBuf, unsigned int offset, int nElems)
 {
-  nativeScanDownImpl(get_num_groups(0), get_local_size(0), get_group_id(0), get_local_id(0), smem, clusterer.mPbuf + (iBuf - 1) * clusterer.mBufSize, clusterer.mPbuf + iBuf * clusterer.mBufSize, offset, nElems);
-}
+  int iThreadGlobal = get_global_id(0) + offset;
 
-GPUdii() void GPUTPCCFStreamCompaction::nativeScanDownImpl(int nBlocks, int nThreads, int iBlock, int iThread, GPUSharedMemory& smem,
-                                                           int* sums,
-                                                           const int* incr,
-                                                           unsigned int offset, int nElems)
-{
-  int gid = get_group_id(0);
-  int idx = get_global_id(0) + offset;
+  int* scanOffsetPrev = clusterer.GetScanBuffer(iBuf - 1);
+  const int* scanOffset = clusterer.GetScanBuffer(iBuf);
 
-  int shift = incr[gid];
+  int shift = scanOffset[iBlock];
 
-  if (idx < nElems) {
-    sums[idx] += shift;
+  if (iThreadGlobal < nElems) {
+    scanOffsetPrev[iThreadGlobal] += shift;
   }
 }
 
 template <>
 GPUdii() void GPUTPCCFStreamCompaction::Thread<GPUTPCCFStreamCompaction::compactDigits>(int nBlocks, int nThreads, int iBlock, int iThread, GPUSharedMemory& smem, processorType& clusterer, int iBuf, int stage, ChargePos* in, ChargePos* out)
 {
-  unsigned int nElems = compactionElems(clusterer, stage);
+  unsigned int nElems = CompactionElems(clusterer, stage);
   SizeT bufferSize = (stage) ? clusterer.mNMaxClusters : clusterer.mNMaxPeaks;
-  compactImpl(get_num_groups(0), get_local_size(0), get_group_id(0), get_local_id(0), smem, in, out, clusterer.mPisPeak, clusterer.mPbuf + (iBuf - 1) * clusterer.mBufSize, clusterer.mPbuf + iBuf * clusterer.mBufSize, nElems, bufferSize);
+
+  unsigned int iThreadGlobal = get_global_id(0);
+
+  const auto* predicate = clusterer.mPisPeak;
+  const auto* scanOffset = clusterer.GetScanBuffer(iBuf);
+
+  bool iAmDummy = (iThreadGlobal >= nElems);
+
+  int pred = (iAmDummy) ? 0 : predicate[iThreadGlobal];
+  int offsetInBlock = CfUtils::blockPredicateScan<GPUCA_THREAD_COUNT_SCAN>(smem, pred);
+
+  SizeT globalOffsetOut = offsetInBlock;
+  if (iBlock > 0) {
+    globalOffsetOut += scanOffset[iBlock - 1];
+  }
+
+  if (pred && globalOffsetOut < bufferSize) {
+    out[globalOffsetOut] = in[iThreadGlobal];
+  }
+
   unsigned int lastId = get_global_size(0) - 1;
-  if ((unsigned int)get_global_id(0) == lastId) {
-    SizeT nFinal = clusterer.mPbuf[lastId];
+  if (iThreadGlobal == lastId) {
+    SizeT nFinal = globalOffsetOut + pred;
     if (nFinal > bufferSize) {
       clusterer.raiseError(stage ? GPUErrors::ERROR_CF_CLUSTER_OVERFLOW : GPUErrors::ERROR_CF_PEAK_OVERFLOW, clusterer.mISlice, nFinal, bufferSize);
       nFinal = bufferSize;
@@ -136,42 +131,7 @@ GPUdii() void GPUTPCCFStreamCompaction::Thread<GPUTPCCFStreamCompaction::compact
   }
 }
 
-GPUdii() void GPUTPCCFStreamCompaction::compactImpl(int nBlocks, int nThreads, int iBlock, int iThread, GPUSharedMemory& smem,
-                                                    const ChargePos* in,
-                                                    ChargePos* out,
-                                                    const uchar* predicate,
-                                                    int* newIdx,
-                                                    const int* incr,
-                                                    int nElems,
-                                                    SizeT bufferSize)
-{
-  int gid = get_group_id(0);
-  int idx = get_global_id(0);
-
-  int lastItem = get_global_size(0) - 1;
-
-  bool iAmDummy = (idx >= nElems);
-
-  int pred = (iAmDummy) ? 0 : predicate[idx];
-  int scanRes = CfUtils::blockPredicateScan<GPUCA_THREAD_COUNT_SCAN>(smem, pred);
-
-  SizeT compIdx = scanRes;
-  if (gid) {
-    compIdx += incr[gid - 1];
-  }
-
-  // SizeT tgtIdx = compIdx - 1;
-  SizeT tgtIdx = compIdx;
-  if (pred && tgtIdx < bufferSize) {
-    out[tgtIdx] = in[idx];
-  }
-
-  if (idx == lastItem) {
-    newIdx[idx] = compIdx; // TODO: Eventually, we can just return the last value, no need to store to memory
-  }
-}
-
-GPUdii() int GPUTPCCFStreamCompaction::compactionElems(processorType& clusterer, int stage)
+GPUdii() int GPUTPCCFStreamCompaction::CompactionElems(processorType& clusterer, int stage)
 {
   return (stage) ? clusterer.mPmemory->counters.nPeaks : clusterer.mPmemory->counters.nPositions;
 }
diff --git a/GPU/GPUTracking/TPCClusterFinder/GPUTPCCFStreamCompaction.h b/GPU/GPUTracking/TPCClusterFinder/GPUTPCCFStreamCompaction.h
index 8a2d3034db..207c9075ba 100644
--- a/GPU/GPUTracking/TPCClusterFinder/GPUTPCCFStreamCompaction.h
+++ b/GPU/GPUTracking/TPCClusterFinder/GPUTPCCFStreamCompaction.h
@@ -55,24 +55,7 @@ class GPUTPCCFStreamCompaction : public GPUKernelTemplate
   GPUd() static void Thread(int nBlocks, int nThreads, int iBlock, int iThread, GPUSharedMemory& smem, processorType& clusterer, Args... args);
 
  private:
-  static GPUd() void nativeScanUpStartImpl(int, int, int, int, GPUSharedMemory&,
-                                           const uchar*, int*, int*,
-                                           int);
-
-  static GPUd() void nativeScanUpImpl(int, int, int, int, GPUSharedMemory&,
-                                      int*, int*, int);
-
-  static GPUd() void nativeScanTopImpl(int, int, int, int, GPUSharedMemory&,
-                                       int*, int);
-
-  static GPUd() void nativeScanDownImpl(int, int, int, int, GPUSharedMemory&,
-                                        int*, const int*, unsigned int, int);
-
-  static GPUd() void compactImpl(int, int, int, int, GPUSharedMemory&,
-                                 const ChargePos*, ChargePos*,
-                                 const uchar*, int*, const int*,
-                                 int, tpccf::SizeT);
-  static GPUd() int compactionElems(processorType& clusterer, int stage);
+  static GPUd() int CompactionElems(processorType& clusterer, int stage);
 };
 
 } // namespace GPUCA_NAMESPACE::gpu
diff --git a/GPU/GPUTracking/TPCClusterFinder/GPUTPCClusterFinder.h b/GPU/GPUTracking/TPCClusterFinder/GPUTPCClusterFinder.h
index 4cdd058026..4488d7cd1a 100644
--- a/GPU/GPUTracking/TPCClusterFinder/GPUTPCClusterFinder.h
+++ b/GPU/GPUTracking/TPCClusterFinder/GPUTPCClusterFinder.h
@@ -116,6 +116,8 @@ class GPUTPCClusterFinder : public GPUProcessor
   int* mPbuf = nullptr;
   Memory* mPmemory = nullptr;
 
+  GPUdi() int* GetScanBuffer(int iBuf) const { return mPbuf + iBuf * mBufSize; }
+
   o2::dataformats::ConstMCTruthContainerView<o2::MCCompLabel> const* mPinputLabels = nullptr;
   unsigned int* mPlabelsInRow = nullptr;
   unsigned int mPlabelsHeaderGlobalOffset = 0;
diff --git a/GPU/GPUTracking/TRDTracking/GPUTRDInterfaces.h b/GPU/GPUTracking/TRDTracking/GPUTRDInterfaces.h
index f8a3cf6236..8915408c63 100644
--- a/GPU/GPUTracking/TRDTracking/GPUTRDInterfaces.h
+++ b/GPU/GPUTracking/TRDTracking/GPUTRDInterfaces.h
@@ -49,19 +49,19 @@ class trackInterface<AliExternalTrackParam> : public AliExternalTrackParam
 {
 
  public:
-  trackInterface<AliExternalTrackParam>() : AliExternalTrackParam(){};
-  trackInterface<AliExternalTrackParam>(const trackInterface<AliExternalTrackParam>& param) : AliExternalTrackParam(param){};
-  trackInterface<AliExternalTrackParam>(const AliExternalTrackParam& param) CON_DELETE;
-  trackInterface<AliExternalTrackParam>(const AliHLTExternalTrackParam& param) : AliExternalTrackParam()
+  trackInterface() : AliExternalTrackParam(){};
+  trackInterface(const trackInterface<AliExternalTrackParam>& param) : AliExternalTrackParam(param){};
+  trackInterface(const AliExternalTrackParam& param) CON_DELETE;
+  trackInterface(const AliHLTExternalTrackParam& param) : AliExternalTrackParam()
   {
     float paramTmp[5] = {param.fY, param.fZ, param.fSinPhi, param.fTgl, param.fq1Pt};
     Set(param.fX, param.fAlpha, paramTmp, param.fC);
   }
-  trackInterface<AliExternalTrackParam>(const GPUTPCGMMergedTrack& trk) : AliExternalTrackParam()
+  trackInterface(const GPUTPCGMMergedTrack& trk) : AliExternalTrackParam()
   {
     Set(trk.GetParam().GetX(), trk.GetAlpha(), trk.GetParam().GetPar(), trk.GetParam().GetCov());
   }
-  trackInterface<AliExternalTrackParam>(const gputpcgmmergertypes::GPUTPCOuterParam& param) : AliExternalTrackParam()
+  trackInterface(const gputpcgmmergertypes::GPUTPCOuterParam& param) : AliExternalTrackParam()
   {
     Set(param.X, param.alpha, param.P, param.C);
   }
diff --git a/GPU/GPUTracking/cmake/kernel_helpers.cmake b/GPU/GPUTracking/cmake/kernel_helpers.cmake
index 46fe975988..571303df4c 100644
--- a/GPU/GPUTracking/cmake/kernel_helpers.cmake
+++ b/GPU/GPUTracking/cmake/kernel_helpers.cmake
@@ -105,7 +105,9 @@ function(o2_gpu_kernel_file_list list)
   define_property(TARGET PROPERTY O2_GPU_KERNELS_FILE_LIST_${list})
   list(LENGTH ARGV n)
   if(2 GREATER ${n})
-    message(FATAL_ERROR "File list must contain at least one file")
+    set_property(TARGET O2_GPU_KERNELS PROPERTY O2_GPU_KERNELS_FILE_LIST_${list} "-")
+    return()
+    # message(FATAL_ERROR "File list must contain at least one file")
   endif()
   if(list MATCHES "[^A-Z0-9_]")
     message(FATAL_ERROR "Invalid character in file list name ${list}")
@@ -117,7 +119,9 @@ function(o2_gpu_kernel_file_list list)
       if(NOT TMP_SUB_FILE_LIST)
         message(FATAL_ERROR "Invalid file list ${ARGV${i}}")
       endif()
-      list(APPEND TMP_FILE_LIST ${TMP_SUB_FILE_LIST})
+      if(NOT TMP_SUB_FILE_LIST STREQUAL "-")
+        list(APPEND TMP_FILE_LIST ${TMP_SUB_FILE_LIST})
+      endif()
     else()
       list(APPEND TMP_FILE_LIST ${ARGV${i}})
       set_property(TARGET O2_GPU_KERNELS APPEND PROPERTY O2_GPU_KERNEL_FILES "${ARGV${i}}")
diff --git a/GPU/GPUTracking/kernels.cmake b/GPU/GPUTracking/kernels.cmake
index 8bdb543230..d4f5ca93e9 100644
--- a/GPU/GPUTracking/kernels.cmake
+++ b/GPU/GPUTracking/kernels.cmake
@@ -17,15 +17,21 @@ o2_gpu_kernel_file_list(TPCTRACKER ERRORS GPUTPCTrackParam.cxx GPUTPCTrack.cxx G
 o2_gpu_kernel_file_list(TPCTRACKLETCONS GPUTPCTrackletConstructor.cxx)
 o2_gpu_kernel_file_list(TPCSLICEDATA TPCTRACKER GPUTPCSliceData.cxx)
 o2_gpu_kernel_file_list(TPCOCCUPANCY GPUTPCClusterOccupancyMap.cxx)
+if(ALIGPU_BUILD_TYPE STREQUAL "O2" OR CONFIG_O2_EXTENSIONS)
 o2_gpu_kernel_file_list(TPCDEDX GPUdEdx.cxx)
-o2_gpu_kernel_file_list(TPCMERGER ERRORS GPUTPCGMMerger.cxx GPUTPCGMSliceTrack.cxx GPUTPCGMTrackParam.cxx GPUTPCGMPhysicalTrackModel.cxx GPUTPCGMPropagator.cxx)
 o2_gpu_kernel_file_list(MATLUT MatLayerCylSet.cxx MatLayerCyl.cxx Ray.cxx)
+o2_gpu_kernel_file_list(TPCMERGER ERRORS GPUTPCGMMerger.cxx GPUTPCGMSliceTrack.cxx GPUTPCGMTrackParam.cxx GPUTPCGMPhysicalTrackModel.cxx GPUTPCGMPropagator.cxx)
 o2_gpu_kernel_file_list(O2PROPAGATOR TrackParametrization.cxx TrackParametrizationWithError.cxx Propagator.cxx TrackLTIntegral.cxx)
 o2_gpu_kernel_file_list(TPCCOMPRESSION GPUTPCCompressionTrackModel.cxx)
 o2_gpu_kernel_file_list(TPCDECOMPRESSION GPUTPCCompressionTrackModel.cxx ERRORS)
 o2_gpu_kernel_file_list(TPCCLUSTERFINDER ERRORS ClusterAccumulator.cxx)
 o2_gpu_kernel_file_list(TRDTRACKER GPUTRDTrack.cxx GPUTRDTracker.cxx GPUTRDTrackletWord.cxx GeometryBase.cxx)
 o2_gpu_kernel_file_list(GLOBALREFIT TPCMERGER O2PROPAGATOR MATLUT GPUTrackingRefit.cxx)
+else()
+o2_gpu_kernel_file_list(TPCDEDX)
+o2_gpu_kernel_file_list(MATLUT)
+o2_gpu_kernel_file_list(TPCMERGER)
+endif()
 
 o2_gpu_add_kernel("GPUTPCNeighboursFinder"                            "= TPCTRACKER"                                          LB_OCL1 single)
 o2_gpu_add_kernel("GPUTPCNeighboursCleaner"                           "= TPCTRACKER"                                          LB_OCL1 single)
diff --git a/GPU/GPUTracking/qa/GPUQA.h b/GPU/GPUTracking/qa/GPUQA.h
index d5fef788c0..79580a737c 100644
--- a/GPU/GPUTracking/qa/GPUQA.h
+++ b/GPU/GPUTracking/qa/GPUQA.h
@@ -57,6 +57,7 @@ class GPUQA
   void* AllocateScratchBuffer(size_t nBytes) { return nullptr; }
   static bool QAAvailable() { return false; }
   static bool IsInitialized() { return false; }
+  void UpdateChain(GPUChainTracking* chain) {}
 };
 } // namespace gpu
 } // namespace GPUCA_NAMESPACE
diff --git a/GPU/Workflow/CMakeLists.txt b/GPU/Workflow/CMakeLists.txt
index 51494b1a17..aa725168b9 100644
--- a/GPU/Workflow/CMakeLists.txt
+++ b/GPU/Workflow/CMakeLists.txt
@@ -26,7 +26,8 @@ o2_add_library(GPUWorkflow
                                      O2::TPCReaderWorkflow
                                      O2::DataFormatsGlobalTracking
                                      O2::DataFormatsTRD
-               PRIVATE_LINK_LIBRARIES O2::GPUTracking)
+               PRIVATE_LINK_LIBRARIES O2::GPUTracking
+                                      O2::ITSTrackingInterface)
 
 o2_add_executable(reco-workflow
        COMPONENT_NAME gpu
diff --git a/GPU/Workflow/include/GPUWorkflow/GPUWorkflowSpec.h b/GPU/Workflow/include/GPUWorkflow/GPUWorkflowSpec.h
index 60567adc73..65940b764f 100644
--- a/GPU/Workflow/include/GPUWorkflow/GPUWorkflowSpec.h
+++ b/GPU/Workflow/include/GPUWorkflow/GPUWorkflowSpec.h
@@ -58,9 +58,8 @@ class GeometryFlat;
 
 namespace its
 {
-class Tracker;
-class Vertexer;
 class TimeFrame;
+class ITSTrackingInterface;
 } // namespace its
 
 namespace itsmft
@@ -211,8 +210,7 @@ class GPURecoWorkflowSpec : public o2::framework::Task
   std::unique_ptr<GPUO2InterfaceQA> mQA;
   std::vector<int> mClusterOutputIds;
   std::vector<int> mTPCSectors;
-  std::unique_ptr<o2::its::Tracker> mITSTracker;
-  std::unique_ptr<o2::its::Vertexer> mITSVertexer;
+  std::unique_ptr<o2::its::ITSTrackingInterface> mITSTrackingInterface;
   std::unique_ptr<gpurecoworkflow_internals::GPURecoWorkflowSpec_PipelineInternals> mPipeline;
   o2::its::TimeFrame* mITSTimeFrame = nullptr;
   std::vector<fair::mq::RegionInfo> mRegionInfos;
@@ -235,8 +233,6 @@ class GPURecoWorkflowSpec : public o2::framework::Task
   bool mITSGeometryCreated = false;
   bool mTRDGeometryCreated = false;
   bool mPropagatorInstanceCreated = false;
-  bool mITSRunVertexer = false;
-  bool mITSCosmicsProcessing = false;
 };
 
 } // end namespace gpu
diff --git a/GPU/Workflow/src/GPUWorkflowITS.cxx b/GPU/Workflow/src/GPUWorkflowITS.cxx
index 8d3270eafd..72f466591d 100644
--- a/GPU/Workflow/src/GPUWorkflowITS.cxx
+++ b/GPU/Workflow/src/GPUWorkflowITS.cxx
@@ -10,397 +10,48 @@
 // or submit itself to any jurisdiction.
 
 /// @file   GPUWorkflowITS.cxx
-/// @author David Rohr
+/// @author David Rohr, Matteo Concas
 
 #include "GPUWorkflow/GPUWorkflowSpec.h"
-#include "Headers/DataHeader.h"
 #include "Framework/WorkflowSpec.h" // o2::framework::mergeInputs
-#include "Framework/DataRefUtils.h"
-#include "Framework/DataSpecUtils.h"
-#include "Framework/DeviceSpec.h"
 #include "Framework/ControlService.h"
 #include "Framework/ConfigParamRegistry.h"
-#include "Framework/InputRecordWalker.h"
-#include "Framework/SerializationMethods.h"
-#include "Framework/Logger.h"
-#include "Framework/CallbackService.h"
 #include "Framework/CCDBParamSpec.h"
-#include "DataFormatsTPC/TPCSectorHeader.h"
-#include "DataFormatsTPC/ClusterNative.h"
-#include "DataFormatsTPC/CompressedClusters.h"
-#include "DataFormatsTPC/Helpers.h"
-#include "DataFormatsTPC/ZeroSuppression.h"
-#include "DataFormatsTPC/RawDataTypes.h"
-#include "DataFormatsTPC/WorkflowHelper.h"
-#include "DataFormatsGlobalTracking/TrackTuneParams.h"
-#include "TPCReconstruction/TPCTrackingDigitsPreCheck.h"
-#include "TPCReconstruction/TPCFastTransformHelperO2.h"
-#include "DataFormatsTPC/Digit.h"
-#include "TPCFastTransform.h"
-#include "DetectorsBase/MatLayerCylSet.h"
-#include "DetectorsBase/Propagator.h"
-#include "DetectorsBase/GeometryManager.h"
-#include "DetectorsRaw/HBFUtils.h"
-#include "DetectorsBase/GRPGeomHelper.h"
-#include "CommonUtils/NameConf.h"
-#include "TPCBase/RDHUtils.h"
-#include "GPUO2InterfaceConfiguration.h"
-#include "GPUO2InterfaceQA.h"
-#include "GPUO2Interface.h"
-#include "CalibdEdxContainer.h"
-#include "GPUNewCalibValues.h"
-#include "TPCPadGainCalib.h"
-#include "TPCZSLinkMapping.h"
-#include "display/GPUDisplayInterface.h"
-#include "TPCBase/Sector.h"
-#include "TPCBase/Utils.h"
-#include "TPCBase/CDBInterface.h"
-#include "TPCCalibration/VDriftHelper.h"
-#include "CorrectionMapsHelper.h"
-#include "TPCCalibration/CorrectionMapsLoader.h"
-#include "SimulationDataFormat/ConstMCTruthContainer.h"
-#include "SimulationDataFormat/MCCompLabel.h"
-#include "Algorithm/Parser.h"
-#include "DataFormatsGlobalTracking/RecoContainer.h"
-#include "DataFormatsTRD/RecoInputContainer.h"
-#include "TRDBase/Geometry.h"
-#include "TRDBase/GeometryFlat.h"
-#include "ITSBase/GeometryTGeo.h"
-#include "CommonUtils/VerbosityConfig.h"
-#include "CommonUtils/DebugStreamer.h"
-#include <filesystem>
-#include <memory> // for make_shared
-#include <vector>
-#include <iomanip>
-#include <stdexcept>
-#include <regex>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <fcntl.h>
-#include <chrono>
-#include "GPUReconstructionConvert.h"
-#include "DetectorsRaw/RDHUtils.h"
-#include <TStopwatch.h>
-#include <TObjArray.h>
-#include <TH1F.h>
-#include <TH2F.h>
-#include <TH1D.h>
-#include <TGraphAsymmErrors.h>
 
-#include "ITStracking/TimeFrame.h"
-#include "ITStracking/Tracker.h"
-#include "ITStracking/TrackerTraits.h"
-#include "ITStracking/Vertexer.h"
-#include "ITStracking/VertexerTraits.h"
-#include "DataFormatsITSMFT/TopologyDictionary.h"
-#include "ITSMFTBase/DPLAlpideParam.h"
-#include "DataFormatsCalibration/MeanVertexObject.h"
-#include "DataFormatsITSMFT/ROFRecord.h"
-#include "DataFormatsITSMFT/PhysTrigger.h"
-#include "CommonDataFormat/IRFrame.h"
-#include "ITSReconstruction/FastMultEst.h"
-#include "ITSReconstruction/FastMultEstConfig.h"
-
-using namespace o2::framework;
-using namespace o2::header;
-using namespace o2::gpu;
-using namespace o2::base;
-using namespace o2::dataformats;
+#include "ITStracking/TrackingInterface.h"
 
 namespace o2::gpu
 {
 
 int GPURecoWorkflowSpec::runITSTracking(o2::framework::ProcessingContext& pc)
 {
-  using Vertex = o2::dataformats::Vertex<o2::dataformats::TimeStamp<int>>;
-
   mITSTimeFrame->setDevicePropagator(mGPUReco->GetDeviceO2Propagator());
-  LOGP(info, "GPUChainITS is giving me device propagator: {}", (void*)mGPUReco->GetDeviceO2Propagator());
-
-  auto compClusters = pc.inputs().get<gsl::span<o2::itsmft::CompClusterExt>>("compClusters");
-  gsl::span<const unsigned char> patterns = pc.inputs().get<gsl::span<unsigned char>>("patterns");
-  gsl::span<const o2::itsmft::PhysTrigger> physTriggers;
-  std::vector<o2::itsmft::PhysTrigger> fromTRD;
-  if (mSpecConfig.itsTriggerType == 2) { // use TRD triggers
-    o2::InteractionRecord ir{0, pc.services().get<o2::framework::TimingInfo>().firstTForbit};
-    auto trdTriggers = pc.inputs().get<gsl::span<o2::trd::TriggerRecord>>("phystrig");
-    for (const auto& trig : trdTriggers) {
-      if (trig.getBCData() >= ir && trig.getNumberOfTracklets()) {
-        ir = trig.getBCData();
-        fromTRD.emplace_back(o2::itsmft::PhysTrigger{ir, 0});
-      }
-    }
-    physTriggers = gsl::span<const o2::itsmft::PhysTrigger>(fromTRD.data(), fromTRD.size());
-  } else if (mSpecConfig.itsTriggerType == 1) { // use Phys triggers from ITS stream
-    physTriggers = pc.inputs().get<gsl::span<o2::itsmft::PhysTrigger>>("phystrig");
-  }
-
-  auto rofsinput = pc.inputs().get<gsl::span<o2::itsmft::ROFRecord>>("ROframes");
-
-  auto& rofs = pc.outputs().make<std::vector<o2::itsmft::ROFRecord>>(Output{"ITS", "ITSTrackROF", 0}, rofsinput.begin(), rofsinput.end());
-  auto& irFrames = pc.outputs().make<std::vector<o2::dataformats::IRFrame>>(Output{"ITS", "IRFRAMES", 0});
-  irFrames.reserve(rofs.size());
-
-  const auto& alpParams = o2::itsmft::DPLAlpideParam<o2::detectors::DetID::ITS>::Instance(); // RS: this should come from CCDB
-  int nBCPerTF = alpParams.roFrameLengthInBC;
-
-  LOG(info) << "ITSTracker pulled " << compClusters.size() << " clusters, " << rofs.size() << " RO frames";
-
-  const dataformats::MCTruthContainer<MCCompLabel>* labels = nullptr;
-  gsl::span<itsmft::MC2ROFRecord const> mc2rofs;
-  if (mSpecConfig.processMC) {
-    labels = pc.inputs().get<const dataformats::MCTruthContainer<MCCompLabel>*>("itsmclabels").release();
-    // get the array as read-only span, a snapshot is sent forward
-    pc.outputs().snapshot(Output{"ITS", "ITSTrackMC2ROF", 0}, pc.inputs().get<gsl::span<itsmft::MC2ROFRecord>>("ITSMC2ROframes"));
-    LOG(info) << labels->getIndexedSize() << " MC label objects , in " << mc2rofs.size() << " MC events";
-  }
-
-  auto& allClusIdx = pc.outputs().make<std::vector<int>>(Output{"ITS", "TRACKCLSID", 0});
-  auto& allTracks = pc.outputs().make<std::vector<o2::its::TrackITS>>(Output{"ITS", "TRACKS", 0});
-  auto& vertROFvec = pc.outputs().make<std::vector<o2::itsmft::ROFRecord>>(Output{"ITS", "VERTICESROF", 0});
-  auto& vertices = pc.outputs().make<std::vector<Vertex>>(Output{"ITS", "VERTICES", 0});
-
-  // MC
-  static pmr::vector<o2::MCCompLabel> dummyMCLabTracks, dummyMCLabVerts;
-  auto& allTrackLabels = mSpecConfig.processMC ? pc.outputs().make<std::vector<o2::MCCompLabel>>(Output{"ITS", "TRACKSMCTR", 0}) : dummyMCLabTracks;
-  auto& allVerticesLabels = mSpecConfig.processMC ? pc.outputs().make<std::vector<o2::MCCompLabel>>(Output{"ITS", "VERTICESMCTR", 0}) : dummyMCLabVerts;
-
-  std::uint32_t roFrame = 0;
-
-  bool continuous = o2::base::GRPGeomHelper::instance().getGRPECS()->isDetContinuousReadOut(o2::detectors::DetID::ITS);
-  LOG(info) << "ITSTracker RO: continuous=" << continuous;
-
-  if (mSpecConfig.itsOverrBeamEst) {
-    mITSTimeFrame->setBeamPosition(mMeanVertex->getX(),
-                                   mMeanVertex->getY(),
-                                   mMeanVertex->getSigmaY2(),
-                                   mITSTracker->getParameters()[0].LayerResolution[0],
-                                   mITSTracker->getParameters()[0].SystErrorY2[0]);
-  }
-
-  mITSTracker->setBz(o2::base::Propagator::Instance()->getNominalBz());
-
-  gsl::span<const unsigned char>::iterator pattIt = patterns.begin();
-
-  gsl::span<itsmft::ROFRecord> rofspan(rofs);
-  mITSTimeFrame->loadROFrameData(rofspan, compClusters, pattIt, mITSDict, labels);
-  pattIt = patterns.begin();
-  std::vector<int> savedROF;
-  auto logger = [&](std::string s) { LOG(info) << s; };
-  auto fatalLogger = [&](std::string s) { LOG(fatal) << s; };
-  auto errorLogger = [&](std::string s) { LOG(error) << s; };
-
-  o2::its::FastMultEst multEst; // mult estimator
-  std::vector<bool> processingMask;
-  int cutVertexMult{0}, cutRandomMult = int(rofs.size()) - multEst.selectROFs(rofs, compClusters, physTriggers, processingMask);
-  mITSTimeFrame->setMultiplicityCutMask(processingMask);
-  float vertexerElapsedTime{0.f};
-  if (mITSRunVertexer) {
-    // Run seeding vertexer
-    vertROFvec.reserve(rofs.size());
-    vertexerElapsedTime = mITSVertexer->clustersToVerticesHybrid(logger);
-  } else { // cosmics
-    mITSTimeFrame->resetRofPV();
-  }
-  const auto& multEstConf = o2::its::FastMultEstConfig::Instance(); // parameters for mult estimation and cuts
-  for (auto iRof{0}; iRof < rofspan.size(); ++iRof) {
-    std::vector<Vertex> vtxVecLoc;
-    auto& vtxROF = vertROFvec.emplace_back(rofspan[iRof]);
-    vtxROF.setFirstEntry(vertices.size());
-    if (mITSRunVertexer) {
-      auto vtxSpan = mITSTimeFrame->getPrimaryVertices(iRof);
-      vtxROF.setNEntries(vtxSpan.size());
-      bool selROF = vtxSpan.size() == 0;
-      for (auto iV{0}; iV < vtxSpan.size(); ++iV) {
-        auto& v = vtxSpan[iV];
-        if (multEstConf.isVtxMultCutRequested() && !multEstConf.isPassingVtxMultCut(v.getNContributors())) {
-          continue; // skip vertex of unwanted multiplicity
-        }
-        selROF = true;
-        vertices.push_back(v);
-        if (mSpecConfig.processMC) {
-          auto vLabels = mITSTimeFrame->getPrimaryVerticesLabels(iRof)[iV];
-          allVerticesLabels.reserve(allVerticesLabels.size() + vLabels.size());
-          std::copy(vLabels.begin(), vLabels.end(), std::back_inserter(allVerticesLabels));
-        }
-      }
-      if (processingMask[iRof] && !selROF) { // passed selection in clusters and not in vertex multiplicity
-        LOG(debug) << fmt::format("ROF {} rejected by the vertex multiplicity selection [{},{}]",
-                                  iRof,
-                                  multEstConf.cutMultVtxLow,
-                                  multEstConf.cutMultVtxHigh);
-        processingMask[iRof] = selROF;
-        cutVertexMult++;
-      }
-    } else { // cosmics
-      vtxVecLoc.emplace_back(Vertex());
-      vtxVecLoc.back().setNContributors(1);
-      vtxROF.setNEntries(vtxVecLoc.size());
-      for (auto& v : vtxVecLoc) {
-        vertices.push_back(v);
-      }
-      mITSTimeFrame->addPrimaryVertices(vtxVecLoc);
-    }
-  }
-  LOG(info) << fmt::format(" - rejected {}/{} ROFs: random/mult.sel:{} (seed {}), vtx.sel:{}", cutRandomMult + cutVertexMult, rofspan.size(), cutRandomMult, multEst.lastRandomSeed, cutVertexMult);
-  LOG(info) << fmt::format(" - Vertex seeding total elapsed time: {} ms for {} vertices found in {} ROFs", vertexerElapsedTime, mITSTimeFrame->getPrimaryVerticesNum(), rofspan.size());
-
-  if (mSpecConfig.itsOverrBeamEst) {
-    LOG(info) << fmt::format(" - Beam position set to: {}, {} from meanvertex object", mITSTimeFrame->getBeamX(), mITSTimeFrame->getBeamY());
-  } else {
-    LOG(info) << fmt::format(" - Beam position computed for the TF: {}, {}", mITSTimeFrame->getBeamX(), mITSTimeFrame->getBeamY());
-  }
-  if (mITSCosmicsProcessing && compClusters.size() > 1500 * rofspan.size()) {
-    LOG(error) << "Cosmics processing was requested with an average detector occupancy exceeding 1.e-7, skipping TF processing.";
-  } else {
-
-    mITSTimeFrame->setMultiplicityCutMask(processingMask);
-    // Run CA tracker
-    if (!mSpecConfig.itsTrackingMode) {
-      mITSTracker->clustersToTracksHybrid(logger, errorLogger);
-    } else {
-      mITSTracker->clustersToTracksHybrid(logger, fatalLogger);
-    }
-    size_t totTracks{mITSTimeFrame->getNumberOfTracks()}, totClusIDs{mITSTimeFrame->getNumberOfUsedClusters()};
-    allTracks.reserve(totTracks);
-    allClusIdx.reserve(totClusIDs);
-
-    if (mITSTimeFrame->hasBogusClusters()) {
-      LOG(warning) << fmt::format(" - The processed timeframe had {} clusters with wild z coordinates, check the dictionaries", mITSTimeFrame->hasBogusClusters());
-    }
-
-    for (unsigned int iROF{0}; iROF < rofs.size(); ++iROF) {
-      auto& rof{rofs[iROF]};
-      auto& tracks = mITSTimeFrame->getTracks(iROF);
-      auto number{tracks.size()};
-      auto first{allTracks.size()};
-      int offset = -rof.getFirstEntry(); // cluster entry!!!
-      rof.setFirstEntry(first);
-      rof.setNEntries(number);
-
-      if (processingMask[iROF]) {
-        irFrames.emplace_back(rof.getBCData(), rof.getBCData() + nBCPerTF - 1).info = tracks.size();
-      }
-
-      allTrackLabels.reserve(mITSTimeFrame->getTracksLabel(iROF).size()); // should be 0 if not MC
-      std::copy(mITSTimeFrame->getTracksLabel(iROF).begin(), mITSTimeFrame->getTracksLabel(iROF).end(), std::back_inserter(allTrackLabels));
-      // Some conversions that needs to be moved in the tracker internals
-      for (unsigned int iTrk{0}; iTrk < tracks.size(); ++iTrk) {
-        auto& trc{tracks[iTrk]};
-        trc.setFirstClusterEntry(allClusIdx.size()); // before adding tracks, create final cluster indices
-        int ncl = trc.getNumberOfClusters(), nclf = 0;
-        for (int ic = o2::its::TrackITSExt::MaxClusters; ic--;) { // track internally keeps in->out cluster indices, but we want to store the references as out->in!!!
-          auto clid = trc.getClusterIndex(ic);
-          if (clid >= 0) {
-            allClusIdx.push_back(clid);
-            nclf++;
-          }
-        }
-        assert(ncl == nclf);
-        allTracks.emplace_back(trc);
-      }
-    }
-    LOGP(info, "ITSTracker pushed {} tracks and {} vertices", allTracks.size(), vertices.size());
-    if (mSpecConfig.processMC) {
-      LOGP(info, "ITSTracker pushed {} track labels", allTrackLabels.size());
-      LOGP(info, "ITSTracker pushed {} vertex labels", allVerticesLabels.size());
-    }
-  }
+  LOGP(debug, "GPUChainITS is giving me device propagator: {}", (void*)mGPUReco->GetDeviceO2Propagator());
+  mITSTrackingInterface->run<true>(pc);
   return 0;
 }
 
-void GPURecoWorkflowSpec::initFunctionITS(InitContext& ic)
+void GPURecoWorkflowSpec::initFunctionITS(o2::framework::InitContext& ic)
 {
   o2::its::VertexerTraits* vtxTraits = nullptr;
   o2::its::TrackerTraits* trkTraits = nullptr;
+  mITSTrackingInterface = std::make_unique<o2::its::ITSTrackingInterface>(mSpecConfig.processMC,
+                                                                          mSpecConfig.itsTriggerType,
+                                                                          static_cast<o2::its::TrackingMode>(mSpecConfig.itsTrackingMode),
+                                                                          mSpecConfig.itsOverrBeamEst);
   mGPUReco->GetITSTraits(trkTraits, vtxTraits, mITSTimeFrame);
-  mITSVertexer = std::make_unique<o2::its::Vertexer>(vtxTraits);
-  mITSTracker = std::make_unique<o2::its::Tracker>(trkTraits);
-  mITSVertexer->adoptTimeFrame(*mITSTimeFrame);
-  mITSTracker->adoptTimeFrame(*mITSTimeFrame);
-  mITSRunVertexer = true;
-  mITSCosmicsProcessing = false;
-  std::vector<o2::its::TrackingParameters> trackParams;
-
-  if (mSpecConfig.itsTrackingMode == 1) {
-    trackParams.resize(3);
-    for (auto& param : trackParams) {
-      param.ZBins = 64;
-      param.PhiBins = 32;
-      param.CellsPerClusterLimit = 1.e3f;
-      param.TrackletsPerClusterLimit = 1.e3f;
-    }
-    trackParams[1].TrackletMinPt = 0.2f;
-    trackParams[1].CellDeltaTanLambdaSigma *= 2.;
-    trackParams[2].TrackletMinPt = 0.1f;
-    trackParams[2].CellDeltaTanLambdaSigma *= 4.;
-    trackParams[2].MinTrackLength = 4;
-    LOG(info) << "Initializing tracker in async. phase reconstruction with " << trackParams.size() << " passes";
-  } else if (mSpecConfig.itsTrackingMode == 0) {
-    trackParams.resize(1);
-    trackParams[0].ZBins = 64;
-    trackParams[0].PhiBins = 32;
-    trackParams[0].MinTrackLength = 4;
-    LOG(info) << "Initializing tracker in sync. phase reconstruction with " << trackParams.size() << " passes";
-  } else if (mSpecConfig.itsTrackingMode == 2) {
-    mITSCosmicsProcessing = true;
-    mITSRunVertexer = false;
-    trackParams.resize(1);
-    trackParams[0].MinTrackLength = 4;
-    trackParams[0].CellDeltaTanLambdaSigma *= 10;
-    trackParams[0].PhiBins = 4;
-    trackParams[0].ZBins = 16;
-    trackParams[0].PVres = 1.e5f;
-    trackParams[0].MaxChi2ClusterAttachment = 60.;
-    trackParams[0].MaxChi2NDF = 40.;
-    trackParams[0].TrackletsPerClusterLimit = 100.;
-    trackParams[0].CellsPerClusterLimit = 100.;
-    LOG(info) << "Initializing tracker in reconstruction for cosmics with " << trackParams.size() << " passes";
-  }
-
-  for (auto& params : trackParams) {
-    params.CorrType = o2::base::PropagatorImpl<float>::MatCorrType::USEMatCorrLUT;
-  }
-  mITSTracker->setParameters(trackParams);
+  mITSTrackingInterface->setTraitsFromProvider(vtxTraits, trkTraits, mITSTimeFrame);
+  mITSTrackingInterface->initialise();
 }
 
-void GPURecoWorkflowSpec::finaliseCCDBITS(ConcreteDataMatcher& matcher, void* obj)
+void GPURecoWorkflowSpec::finaliseCCDBITS(o2::framework::ConcreteDataMatcher& matcher, void* obj)
 {
-  if (matcher == ConcreteDataMatcher("ITS", "CLUSDICT", 0)) {
-    LOG(info) << "cluster dictionary updated";
-    mITSDict = (const o2::itsmft::TopologyDictionary*)obj;
-    return;
-  }
-  // Note: strictly speaking, for Configurable params we don't need finaliseCCDB check, the singletons are updated at the CCDB fetcher level
-  if (matcher == ConcreteDataMatcher("ITS", "ALPIDEPARAM", 0)) {
-    LOG(info) << "Alpide param updated";
-    const auto& par = o2::itsmft::DPLAlpideParam<o2::detectors::DetID::ITS>::Instance();
-    par.printKeyValues();
-    return;
-  }
-  if (matcher == ConcreteDataMatcher("GLO", "MEANVERTEX", 0)) {
-    LOGP(info, "mean vertex acquired");
-    if (obj) {
-      mMeanVertex = (const o2::dataformats::MeanVertexObject*)obj;
-    }
-    return;
-  }
+  mITSTrackingInterface->finaliseCCDB(matcher, obj);
 }
 
-bool GPURecoWorkflowSpec::fetchCalibsCCDBITS(ProcessingContext& pc)
+bool GPURecoWorkflowSpec::fetchCalibsCCDBITS(o2::framework::ProcessingContext& pc)
 {
-  static bool initOnceDone = false;
-  if (!initOnceDone) { // this params need to be queried only once
-    initOnceDone = true;
-    pc.inputs().get<o2::itsmft::TopologyDictionary*>("itscldict"); // just to trigger the finaliseCCDB
-    pc.inputs().get<o2::itsmft::DPLAlpideParam<o2::detectors::DetID::ITS>*>("itsalppar");
-    mITSVertexer->getGlobalConfiguration();
-    mITSTracker->getGlobalConfiguration();
-    if (mSpecConfig.itsOverrBeamEst) {
-      pc.inputs().get<o2::dataformats::MeanVertexObject*>("meanvtx");
-    }
-  }
+  mITSTrackingInterface->updateTimeDependentParams(pc);
   return false;
 }
-
 } // namespace o2::gpu
diff --git a/GPU/Workflow/src/GPUWorkflowSpec.cxx b/GPU/Workflow/src/GPUWorkflowSpec.cxx
index 5b219da31f..36ce6da419 100644
--- a/GPU/Workflow/src/GPUWorkflowSpec.cxx
+++ b/GPU/Workflow/src/GPUWorkflowSpec.cxx
@@ -76,8 +76,7 @@
 #include "CommonUtils/DebugStreamer.h"
 #include "GPUReconstructionConvert.h"
 #include "DetectorsRaw/RDHUtils.h"
-#include "ITStracking/Tracker.h"
-#include "ITStracking/Vertexer.h"
+#include "ITStracking/TrackingInterface.h"
 #include "GPUWorkflowInternal.h"
 // #include "Framework/ThreadPool.h"
 
@@ -98,6 +97,7 @@
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <chrono>
+#include <unordered_set>
 
 using namespace o2::framework;
 using namespace o2::header;
@@ -375,11 +375,6 @@ void GPURecoWorkflowSpec::finaliseCCDB(o2::framework::ConcreteDataMatcher& match
     mGRPGeomUpdated = true;
     return;
   }
-  if (matcher == ConcreteDataMatcher("ITS", "GEOMTGEO", 0)) {
-    LOG(info) << "ITS GeomtetryTGeo loaded from ccdb";
-    o2::its::GeometryTGeo::adopt((o2::its::GeometryTGeo*)obj);
-    return;
-  }
 }
 
 template <class D, class E, class F, class G, class H, class I, class J, class K>
@@ -684,21 +679,23 @@ void GPURecoWorkflowSpec::run(ProcessingContext& pc)
   using outputBufferUninitializedVector = std::decay_t<decltype(pc.outputs().make<DataAllocator::UninitializedVector<outputDataType>>(Output{"", "", 0}))>;
   using outputBufferType = std::pair<std::optional<std::reference_wrapper<outputBufferUninitializedVector>>, outputDataType*>;
   std::vector<outputBufferType> outputBuffers(GPUInterfaceOutputs::count(), {std::nullopt, nullptr});
+  std::unordered_set<std::string> outputsCreated;
 
-  auto setOutputAllocator = [this, &outputBuffers, &outputRegions, &pc](const char* name, bool condition, GPUOutputControl& region, auto&& outputSpec, size_t offset = 0) {
+  auto setOutputAllocator = [this, &outputBuffers, &outputRegions, &pc, &outputsCreated](const char* name, bool condition, GPUOutputControl& region, auto&& outputSpec, size_t offset = 0) {
     if (condition) {
       auto& buffer = outputBuffers[outputRegions.getIndex(region)];
       if (mConfParam->allocateOutputOnTheFly) {
-        region.allocator = [this, name, &buffer, &pc, outputSpec = std::move(outputSpec), offset](size_t size) -> void* {
+        region.allocator = [this, name, &buffer, &pc, outputSpec = std::move(outputSpec), offset, &outputsCreated](size_t size) -> void* {
           size += offset;
           if (mVerbosity) {
-            LOG(info) << "ALLOCATING " << size << " bytes for " << std::get<DataOrigin>(outputSpec).template as<std::string>() << "/" << std::get<DataDescription>(outputSpec).template as<std::string>() << "/" << std::get<2>(outputSpec);
+            LOG(info) << "ALLOCATING " << size << " bytes for " << name << ": " << std::get<DataOrigin>(outputSpec).template as<std::string>() << "/" << std::get<DataDescription>(outputSpec).template as<std::string>() << "/" << std::get<2>(outputSpec);
           }
           std::chrono::time_point<std::chrono::high_resolution_clock> start, end;
           if (mVerbosity) {
             start = std::chrono::high_resolution_clock::now();
           }
           buffer.first.emplace(pc.outputs().make<DataAllocator::UninitializedVector<outputDataType>>(std::make_from_tuple<Output>(outputSpec), size));
+          outputsCreated.insert(name);
           if (mVerbosity) {
             end = std::chrono::high_resolution_clock::now();
             std::chrono::duration<double> elapsed_seconds = end - start;
@@ -711,6 +708,7 @@ void GPURecoWorkflowSpec::run(ProcessingContext& pc)
         buffer.first.emplace(pc.outputs().make<DataAllocator::UninitializedVector<outputDataType>>(std::make_from_tuple<Output>(outputSpec), mConfParam->outputBufferSize));
         region.ptrBase = (buffer.second = buffer.first->get().data()) + offset;
         region.size = buffer.first->get().size() - offset;
+        outputsCreated.insert(name);
       }
     }
   };
@@ -848,10 +846,6 @@ void GPURecoWorkflowSpec::run(ProcessingContext& pc)
     }
   }
 
-  if (mConfig->configReconstruction.tpc.occupancyMapTimeBins == 0) {
-    pc.outputs().make<DataAllocator::UninitializedVector<outputDataType>>({gDataOriginTPC, "TPCOCCUPANCYMAP", 0}, 0u);
-  }
-
   std::unique_ptr<o2::tpc::ClusterNativeAccess> tmpEmptyClNative;
   if (createEmptyOutput) {
     memset(&ptrs, 0, sizeof(ptrs));
@@ -977,7 +971,10 @@ void GPURecoWorkflowSpec::run(ProcessingContext& pc)
     pc.outputs().snapshot({gDataOriginGPU, "ERRORQA", 0}, mErrorQA);
     mErrorQA.clear(); // FIXME: This is a race condition once we run multi-threaded!
   }
-  if (mSpecConfig.tpcTriggerHandling && !mSpecConfig.caClusterer) {
+  if (mSpecConfig.outputSharedClusterMap && !outputsCreated.contains("TPCOCCUPANCYMAP")) {
+    pc.outputs().make<DataAllocator::UninitializedVector<outputDataType>>({gDataOriginTPC, "TPCOCCUPANCYMAP", 0}, 0u);
+  }
+  if (mSpecConfig.tpcTriggerHandling && !outputsCreated.contains("TRIGGERWORDS")) {
     pc.outputs().make<DataAllocator::UninitializedVector<outputDataType>>(Output{gDataOriginTPC, "TRIGGERWORDS", 0}, 0u);
   }
   mTimer->Stop();
diff --git a/Generators/CMakeLists.txt b/Generators/CMakeLists.txt
index ec9e7af075..3f6509b7db 100644
--- a/Generators/CMakeLists.txt
+++ b/Generators/CMakeLists.txt
@@ -32,6 +32,7 @@ o2_add_library(Generators
                        src/TriggerExternalParam.cxx
                        src/TriggerParticleParam.cxx
                        src/BoxGunParam.cxx
+                       src/BoxGenerator.cxx
                        src/QEDGenParam.cxx
                        src/GenCosmicsParam.cxx
                        src/GeneratorFactory.cxx
@@ -80,6 +81,7 @@ set(headers
     include/Generators/GeneratorTParticle.h
     include/Generators/GeneratorTParticleParam.h
     include/Generators/GeneratorService.h
+    include/Generators/BoxGenerator.h
     )
 
 if(pythia_FOUND)
diff --git a/Generators/include/Generators/BoxGenerator.h b/Generators/include/Generators/BoxGenerator.h
new file mode 100644
index 0000000000..4198a1ac4c
--- /dev/null
+++ b/Generators/include/Generators/BoxGenerator.h
@@ -0,0 +1,113 @@
+// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
+// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
+// All rights not expressly granted are reserved.
+//
+// This software is distributed under the terms of the GNU General Public
+// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
+//
+// In applying this license CERN does not waive the privileges and immunities
+// granted to it by virtue of its status as an Intergovernmental Organization
+// or submit itself to any jurisdiction.
+
+/// \author Sandro Wenzel - April 2024
+
+#ifndef ALICEO2_EVENTGEN_BOX
+#define ALICEO2_EVENTGEN_BOX
+
+#include "Generators/Generator.h"
+#include "TParticle.h"
+#include <vector>
+
+namespace o2::eventgen
+{
+
+/*
+ * A simple mono-pdg "BoxGenerator". Or particle gun.
+ * Re-implements FairBoxGenerator for more convenient O2-processing.
+ */
+class BoxGenerator : public Generator
+{
+ public:
+  BoxGenerator() = default;
+  BoxGenerator(int pdgid, int mult = 1);
+
+  BoxGenerator(int pdgid,
+               int mult,
+               double etamin,
+               double etamax,
+               double pmin,
+               double pmax,
+               double phimin,
+               double phimax) : mPDG{pdgid}, mMult{mult}
+  {
+    SetEtaRange(etamin, etamax);
+    SetPRange(pmin, pmax);
+    SetPhiRange(phimin, phimax);
+  }
+
+  void SetPRange(Double32_t pmin = 0, Double32_t pmax = 10)
+  {
+    mPMin = pmin;
+    mPMax = pmax;
+    mPRangeIsSet = true;
+  }
+
+  void SetPhiRange(double phimin = 0, double phimax = 360)
+  {
+    mPhiMin = phimin;
+    mPhiMax = phimax;
+  }
+
+  void SetEtaRange(double etamin = -5, double etamax = 5)
+  {
+    mEtaMin = etamin;
+    mEtaMax = etamax;
+    mEtaRangeIsSet = true;
+  }
+
+  /// generates a single particle conforming to particle gun parameters
+  TParticle sampleParticle() const;
+
+  /// implements the main O2 generator interfaces
+  bool generateEvent() override
+  {
+    mEvent.clear();
+    for (int i = 0; i < mMult; ++i) {
+      mEvent.push_back(sampleParticle());
+    }
+    return true;
+  }
+  bool importParticles() override
+  {
+    mParticles.clear();
+    std::copy(mEvent.begin(), mEvent.end(), std::back_insert_iterator(mParticles));
+    return true;
+  }
+
+ private:
+  double mPtMin{0.}, mPtMax{0.};       // Transverse momentum range [GeV]
+  double mPhiMin{0.}, mPhiMax{360.};   // Azimuth angle range [degree]
+  double mEtaMin{0.}, mEtaMax{0.};     // Pseudorapidity range in lab system
+  double mYMin{0.}, mYMax{0.};         // Rapidity range in lab system
+  double mPMin{0.}, mPMax{0.};         // Momentum range in lab system
+  double mThetaMin{0.}, mThetaMax{0.}; // Polar angle range in lab system [degree]
+  double mEkinMin{0.}, mEkinMax{0.};   // Kinetic Energy range in lab system [GeV]
+
+  int mPDG{0};
+  int mMult{1};
+
+  bool mEtaRangeIsSet{false};   // True if eta range is set
+  bool mYRangeIsSet{false};     // True if rapidity range is set
+  bool mThetaRangeIsSet{false}; // True if theta range is set
+  bool mCosThetaIsSet{false};   // True if uniform distribution in
+  // cos(theta) is set (default -> not set)
+  bool mPtRangeIsSet{false};   // True if transverse momentum range is set
+  bool mPRangeIsSet{false};    // True if abs.momentum range is set
+  bool mEkinRangeIsSet{false}; // True if kinetic energy range is set
+
+  std::vector<TParticle> mEvent; // internal event container
+};
+
+} // namespace o2::eventgen
+
+#endif
diff --git a/Generators/include/Generators/Generator.h b/Generators/include/Generators/Generator.h
index 3b3e056efe..a488e31ace 100644
--- a/Generators/include/Generators/Generator.h
+++ b/Generators/include/Generators/Generator.h
@@ -71,8 +71,8 @@ class Generator : public FairGenerator
   Bool_t ReadEvent(FairPrimaryGenerator* primGen) final;
 
   /** methods to override **/
-  virtual Bool_t generateEvent() = 0;
-  virtual Bool_t importParticles() = 0;
+  virtual Bool_t generateEvent() = 0;   // generates event (in structure internal to generator)
+  virtual Bool_t importParticles() = 0; // fills the mParticles vector (transfer from generator state)
 
   /** setters **/
   void setMomentumUnit(double val) { mMomentumUnit = val; };
diff --git a/Generators/src/BoxGenerator.cxx b/Generators/src/BoxGenerator.cxx
new file mode 100644
index 0000000000..478934d98c
--- /dev/null
+++ b/Generators/src/BoxGenerator.cxx
@@ -0,0 +1,78 @@
+// Copyright 2019-2020 CERN and copyright holders of ALICE O2.
+// See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
+// All rights not expressly granted are reserved.
+//
+// This software is distributed under the terms of the GNU General Public
+// License v3 (GPL Version 3), copied verbatim in the file "COPYING".
+//
+// In applying this license CERN does not waive the privileges and immunities
+// granted to it by virtue of its status as an Intergovernmental Organization
+// or submit itself to any jurisdiction.
+
+/// \author Sandro Wenzel - April 2024
+
+#include "Generators/BoxGenerator.h"
+#include "TRandom.h"
+#include "TDatabasePDG.h"
+
+using namespace o2::eventgen;
+
+double GetPDGMass(int pdg)
+{
+  static TDatabasePDG* pid = TDatabasePDG::Instance();
+  TParticlePDG* p = pid->GetParticle(pdg);
+  if (p != nullptr) {
+    // LOG(info) << this->ClassName() << ": particle with PDG =" << GetPDGType() << " Found";
+    return p->Mass(); // fPDGMass = p->Mass();
+  }
+  // LOG(warn) << "pdg not known";
+  return 0.;
+}
+
+TParticle o2::eventgen::BoxGenerator::sampleParticle() const
+{
+  // Primary particles are distributed uniformly along
+  // those kinematics variables which were limitted by setters.
+  // if SetCosTheta() function is used, the distribution will be uniform in
+  // cos(theta)
+
+  static double mass = GetPDGMass(mPDG);
+
+  double pabs = 0, phi, pt = 0, theta = 0, eta, y, mt, px, py, pz = 0;
+  phi = gRandom->Uniform(mPhiMin, mPhiMax) * TMath::DegToRad();
+  if (mPRangeIsSet) {
+    pabs = gRandom->Uniform(mPMin, mPMax);
+  } else if (mPtRangeIsSet) {
+    pt = gRandom->Uniform(mPtMin, mPtMax);
+  }
+  if (mThetaRangeIsSet) {
+    if (mCosThetaIsSet) {
+      theta = acos(gRandom->Uniform(cos(mThetaMin * TMath::DegToRad()), cos(mThetaMax * TMath::DegToRad())));
+    } else {
+      theta = gRandom->Uniform(mThetaMin, mThetaMax) * TMath::DegToRad();
+    }
+  } else if (mEtaRangeIsSet) {
+    eta = gRandom->Uniform(mEtaMin, mEtaMax);
+    theta = 2 * TMath::ATan(TMath::Exp(-eta));
+  } else if (mYRangeIsSet) {
+    y = gRandom->Uniform(mYMin, mYMax);
+    mt = TMath::Sqrt(mass * mass + pt * pt);
+    pz = mt * TMath::SinH(y);
+  }
+
+  if (mThetaRangeIsSet || mEtaRangeIsSet) {
+    if (mPRangeIsSet) {
+      pz = pabs * TMath::Cos(theta);
+      pt = pabs * TMath::Sin(theta);
+    } else if (mPtRangeIsSet) {
+      pz = pt / TMath::Tan(theta);
+    }
+  }
+  px = pt * TMath::Cos(phi);
+  py = pt * TMath::Sin(phi);
+
+  double vx = 0., vy = 0., vz = 0.;
+  double etot = TMath::Sqrt(px * px + py * py + pz * pz + mass * mass);
+  return TParticle(mPDG, 1 /*status*/, -1 /* mother1 */, -1 /* mother2 */,
+                   -1 /* daughter1 */, -1 /* daughter2 */, px, py, pz, etot, vx, vy, vz, 0. /*time*/);
+}
diff --git a/Generators/src/Generator.cxx b/Generators/src/Generator.cxx
index 99a00f154c..530e418add 100644
--- a/Generators/src/Generator.cxx
+++ b/Generators/src/Generator.cxx
@@ -75,19 +75,23 @@ Bool_t
 
     /** generate event **/
     if (!generateEvent()) {
+      LOG(error) << "ReadEvent failed in generateEvent";
       return kFALSE;
     }
 
     /** import particles **/
     if (!importParticles()) {
+      LOG(error) << "ReadEvent failed in importParticles";
       return kFALSE;
     }
 
     if (mSubGeneratorsIdToDesc.empty() && mSubGeneratorId > -1) {
+      LOG(error) << "ReadEvent failed because no SubGenerator description given";
       return kFALSE;
     }
 
     if (!mSubGeneratorsIdToDesc.empty() && mSubGeneratorId < 0) {
+      LOG(error) << "ReadEvent failed because SubGenerator description given but sub-generator not set";
       return kFALSE;
     }
 
@@ -102,6 +106,7 @@ Bool_t
 
   /** add tracks **/
   if (!addTracks(primGen)) {
+    LOG(error) << "ReadEvent failed in addTracks";
     return kFALSE;
   }
 
diff --git a/Generators/src/GeneratorFromFile.cxx b/Generators/src/GeneratorFromFile.cxx
index ee0709f00f..069c92ec86 100644
--- a/Generators/src/GeneratorFromFile.cxx
+++ b/Generators/src/GeneratorFromFile.cxx
@@ -298,6 +298,8 @@ void GeneratorFromO2Kine::updateHeader(o2::dataformats::MCEventHeader* eventHead
   if (mOrigMCEventHeader.get()) {
     eventHeader->copyInfoFrom(*mOrigMCEventHeader.get());
   }
+  // we forward also the original basic vertex information contained in FairMCEventHeader
+  static_cast<FairMCEventHeader&>(*eventHeader) = static_cast<FairMCEventHeader&>(*mOrigMCEventHeader.get());
 
   // put additional information about input file and event number of the current event
   eventHeader->putInfo<std::string>("forwarding-generator", "generatorFromO2Kine");
diff --git a/Generators/src/GeneratorsLinkDef.h b/Generators/src/GeneratorsLinkDef.h
index 35e77febee..537b012cee 100644
--- a/Generators/src/GeneratorsLinkDef.h
+++ b/Generators/src/GeneratorsLinkDef.h
@@ -73,4 +73,6 @@
 #pragma link C++ class o2::eventgen::GeneratorFileOrCmdParam + ;
 #pragma link C++ class o2::conf::ConfigurableParamHelper < o2::eventgen::GeneratorFileOrCmdParam> + ;
 
+#pragma link C++ class o2::eventgen::BoxGenerator + ;
+
 #endif
diff --git a/Steer/DigitizerWorkflow/src/HMPIDDigitWriterSpec.h b/Steer/DigitizerWorkflow/src/HMPIDDigitWriterSpec.h
index ecedc21e98..2aa2fbbabd 100644
--- a/Steer/DigitizerWorkflow/src/HMPIDDigitWriterSpec.h
+++ b/Steer/DigitizerWorkflow/src/HMPIDDigitWriterSpec.h
@@ -38,7 +38,7 @@ o2::framework::DataProcessorSpec getHMPIDDigitWriterSpec(bool mctruth = true)
                                 1,
                                 BranchDefinition<std::vector<o2::hmpid::Digit>>{InputSpec{"hmpdigitinput", "HMP", "DIGITS"}, "HMPDigit"},
                                 BranchDefinition<std::vector<o2::hmpid::Trigger>>{InputSpec{"hmpinteractionrecords", "HMP", "INTRECORDS"}, "InteractionRecords"},
-                                BranchDefinition<o2::dataformats::MCTruthContainer<o2::MCCompLabel>>{InputSpec{"hmplabelinput", "HMP", "DIGITLBL"}, "HMPDigitLabels", mctruth ? 1 : 0})();
+                                BranchDefinition<o2::dataformats::MCTruthContainer<o2::MCCompLabel>>{InputSpec{"hmplabelinput", "HMP", "DIGITLBL"}, "HMPDigitLabels", mctruth ? 1 : 0})(); // DIGITLBL == > DIGITSMCTR?
 }
 
 } // end namespace hmpid
diff --git a/Steer/DigitizerWorkflow/src/HMPIDDigitizerSpec.cxx b/Steer/DigitizerWorkflow/src/HMPIDDigitizerSpec.cxx
index 0adb9eb0a9..9ae1234bc6 100644
--- a/Steer/DigitizerWorkflow/src/HMPIDDigitizerSpec.cxx
+++ b/Steer/DigitizerWorkflow/src/HMPIDDigitizerSpec.cxx
@@ -34,7 +34,6 @@
 using namespace o2::framework;
 using SubSpecificationType = o2::framework::DataAllocator::SubSpecificationType;
 
-
 namespace o2
 {
 namespace hmpid
@@ -134,6 +133,8 @@ class HMPIDDPLDigitizerTask : public o2::base::BaseDPLDigitizer
     // send out to next stage
     pc.outputs().snapshot(Output{"HMP", "DIGITS", 0}, digitsAccum);
     pc.outputs().snapshot(Output{"HMP", "INTRECORDS", 0}, mIntRecord);
+
+    // DIGITLBL == > DIGITSMCTR?
     if (pc.outputs().isAllowed({"HMP", "DIGITLBL", 0})) {
       pc.outputs().snapshot(Output{"HMP", "DIGITLBL", 0}, labelAccum);
     }
@@ -167,7 +168,7 @@ o2::framework::DataProcessorSpec getHMPIDDigitizerSpec(int channel, bool mctruth
   outputs.emplace_back("HMP", "DIGITS", 0, Lifetime::Timeframe);
   outputs.emplace_back("HMP", "INTRECORDS", 0, Lifetime::Timeframe);
   if (mctruth) {
-    outputs.emplace_back("HMP", "DIGITLBL", 0, Lifetime::Timeframe);
+    outputs.emplace_back("HMP", "DIGITLBL", 0, Lifetime::Timeframe); // DIGITLBL == > DIGITSMCTR?
   }
   outputs.emplace_back("HMP", "ROMode", 0, Lifetime::Timeframe);
 
diff --git a/Steer/DigitizerWorkflow/src/SimpleDigitizerWorkflow.cxx b/Steer/DigitizerWorkflow/src/SimpleDigitizerWorkflow.cxx
index 523c1f2cf6..a30294a240 100644
--- a/Steer/DigitizerWorkflow/src/SimpleDigitizerWorkflow.cxx
+++ b/Steer/DigitizerWorkflow/src/SimpleDigitizerWorkflow.cxx
@@ -228,6 +228,18 @@ void customize(std::vector<o2::framework::DispatchPolicy>& policies)
   policies.push_back({"prompt-for-simreader", matcher, DispatchOp::WhenReady});
 }
 
+void setTimingInfoInHeaders(o2::header::DataHeader& dh, o2::framework::DataProcessingHeader& dph)
+{
+  const auto& hbfu = o2::raw::HBFUtils::Instance();
+  const auto offset = int64_t(hbfu.getFirstIRofTF({0, hbfu.orbitFirstSampled}).orbit);
+  const auto increment = int64_t(hbfu.nHBFPerTF);
+  const auto startTime = hbfu.startTime;
+  const auto orbitFirst = hbfu.orbitFirst;
+  dh.firstTForbit = offset + increment * dh.tfCounter;
+  dh.runNumber = hbfu.runNumber;
+  dph.creation = startTime + (dh.firstTForbit - orbitFirst) * o2::constants::lhc::LHCOrbitMUS * 1.e-3;
+}
+
 void customize(std::vector<o2::framework::CallbacksPolicy>& policies)
 {
   // we customize the time information sent in DPL headers
@@ -239,17 +251,10 @@ void customize(std::vector<o2::framework::CallbacksPolicy>& policies)
       // simple linear enumeration from already updated HBFUtils (set via config key values)
       service.set<o2::framework::CallbackService::Id::NewTimeslice>(
         [](o2::header::DataHeader& dh, o2::framework::DataProcessingHeader& dph) {
-          const auto& hbfu = o2::raw::HBFUtils::Instance();
-          const auto offset = int64_t(hbfu.getFirstIRofTF({0, hbfu.orbitFirstSampled}).orbit);
-          const auto increment = int64_t(hbfu.nHBFPerTF);
-          const auto startTime = hbfu.startTime;
-          const auto orbitFirst = hbfu.orbitFirst;
-          dh.firstTForbit = offset + increment * dh.tfCounter;
-          LOG(info) << "Setting firstTForbit to " << dh.firstTForbit;
-          dh.runNumber = hbfu.runNumber;
-          LOG(info) << "Setting runNumber to " << dh.runNumber;
-          dph.creation = startTime + (dh.firstTForbit - orbitFirst) * o2::constants::lhc::LHCOrbitMUS * 1.e-3;
-          LOG(info) << "Setting timeframe creation time to " << dph.creation;
+          setTimingInfoInHeaders(dh, dph);
+          LOG(info) << "Setting DPL-header firstTForbit to " << dh.firstTForbit;
+          LOG(info) << "Setting DPL-header runNumber to " << dh.runNumber;
+          LOG(info) << "Setting DPL-header timeframe creation time to " << dph.creation;
         });
     }} // end of struct
   );
@@ -486,7 +491,13 @@ WorkflowSpec defineDataProcessing(ConfigContext const& configcontext)
     // init on a high level, the time for the CCDB queries
     // we expect that digitizers do not play with the manager themselves
     // this will only be needed until digitizers take CCDB objects via DPL mechanism
-    o2::ccdb::BasicCCDBManager::instance().setTimestamp(hbfu.startTime);
+
+    // fix the timestamp for CCDB manager in the same way as for DPL-CCDB-fetcher
+    o2::header::DataHeader dh;
+    o2::framework::DataProcessingHeader dph;
+    setTimingInfoInHeaders(dh, dph);
+    LOG(info) << "Setting timestamp of BasicCCDBManager to " << dph.creation;
+    o2::ccdb::BasicCCDBManager::instance().setTimestamp(dph.creation);
     // activate caching
     o2::ccdb::BasicCCDBManager::instance().setCaching(true);
     // this is asking the manager to check validity only locally - no further query to server done
diff --git a/Utilities/EPNMonitoring/src/EPNstderrMonitor.cxx b/Utilities/EPNMonitoring/src/EPNstderrMonitor.cxx
index 57d8bab96e..b0b0f96ad9 100644
--- a/Utilities/EPNMonitoring/src/EPNstderrMonitor.cxx
+++ b/Utilities/EPNMonitoring/src/EPNstderrMonitor.cxx
@@ -126,7 +126,7 @@ void EPNMonitor::sendLog(const std::string& file, const std::string& message)
     mLoggerContext->setField(InfoLogger::InfoLoggerContext::FieldName::Facility, ("stderr/" + file).substr(0, 31));
     mLoggerContext->setField(InfoLogger::InfoLoggerContext::FieldName::Run, mRunNumber != 0 ? std::to_string(mRunNumber) : "unspecified");
     static const InfoLogger::InfoLogger::InfoLoggerMessageOption opt = {InfoLogger::InfoLogger::Severity::Error, 3, InfoLogger::InfoLogger::undefinedMessageOption.errorCode, InfoLogger::InfoLogger::undefinedMessageOption.sourceFile, InfoLogger::InfoLogger::undefinedMessageOption.sourceLine};
-    mLogger->log(opt, *mLoggerContext, "stderr: %s", message.c_str());
+    mLogger->log(opt, *mLoggerContext, "stderr: %s", file == "SYSLOG" ? (std::string("[GLOBAL SYSLOG]: ") + message).c_str() : message.c_str());
   } else {
     printf("stderr: %s: %s\n", file.c_str(), message.c_str());
   }
diff --git a/Utilities/Mergers/include/Mergers/IntegratingMerger.h b/Utilities/Mergers/include/Mergers/IntegratingMerger.h
index 2fedcda0f3..8a6cecc437 100644
--- a/Utilities/Mergers/include/Mergers/IntegratingMerger.h
+++ b/Utilities/Mergers/include/Mergers/IntegratingMerger.h
@@ -55,6 +55,7 @@ class IntegratingMerger : public framework::Task
   void endOfStream(framework::EndOfStreamContext& eosContext) override;
 
  private:
+  void finishCycle(framework::DataAllocator& outputs);
   void publishIntegral(framework::DataAllocator& allocator);
   void publishMovingWindow(framework::DataAllocator& allocator);
   static void merge(ObjectStore& mMergedDelta, ObjectStore&& other);
diff --git a/Utilities/Mergers/src/FullHistoryMerger.cxx b/Utilities/Mergers/src/FullHistoryMerger.cxx
index a2836e6373..2ed05d46c0 100644
--- a/Utilities/Mergers/src/FullHistoryMerger.cxx
+++ b/Utilities/Mergers/src/FullHistoryMerger.cxx
@@ -90,6 +90,7 @@ void FullHistoryMerger::run(framework::ProcessingContext& ctx)
 
 void FullHistoryMerger::endOfStream(framework::EndOfStreamContext& eosContext)
 {
+  mergeCache();
   publish(eosContext.outputs());
 }
 
diff --git a/Utilities/Mergers/src/IntegratingMerger.cxx b/Utilities/Mergers/src/IntegratingMerger.cxx
index f935628ff9..749becd463 100644
--- a/Utilities/Mergers/src/IntegratingMerger.cxx
+++ b/Utilities/Mergers/src/IntegratingMerger.cxx
@@ -69,31 +69,37 @@ void IntegratingMerger::run(framework::ProcessingContext& ctx)
   }
 
   if (ctx.inputs().isValid("timer-publish")) {
-    mCyclesSinceReset++;
+    finishCycle(ctx.outputs());
+  }
+}
 
-    if (mConfig.publishMovingWindow.value == PublishMovingWindow::Yes) {
-      publishMovingWindow(ctx.outputs());
-    }
+void IntegratingMerger::finishCycle(DataAllocator& outputs)
+{
+  mCyclesSinceReset++;
 
-    if (!std::holds_alternative<std::monostate>(mMergedObjectLastCycle)) {
-      merge(mMergedObjectIntegral, std::move(mMergedObjectLastCycle));
-    }
-    mMergedObjectLastCycle = std::monostate{};
-    mTotalDeltasMerged += mDeltasMerged;
+  if (mConfig.publishMovingWindow.value == PublishMovingWindow::Yes) {
+    publishMovingWindow(outputs);
+  }
 
-    publishIntegral(ctx.outputs());
+  if (!std::holds_alternative<std::monostate>(mMergedObjectLastCycle)) {
+    merge(mMergedObjectIntegral, std::move(mMergedObjectLastCycle));
+  }
+  mMergedObjectLastCycle = std::monostate{};
+  mTotalDeltasMerged += mDeltasMerged;
 
-    if (mConfig.mergedObjectTimespan.value == MergedObjectTimespan::LastDifference ||
-        mConfig.mergedObjectTimespan.value == MergedObjectTimespan::NCycles && mConfig.mergedObjectTimespan.param == mCyclesSinceReset) {
-      clear();
-    }
+  publishIntegral(outputs);
 
-    mCollector->send({mTotalDeltasMerged, "total_deltas_merged"}, monitoring::DerivedMetricMode::RATE);
-    mCollector->send({mDeltasMerged, "deltas_merged_since_last_publication"});
-    mCollector->send({mCyclesSinceReset, "cycles_since_reset"});
-    mDeltasMerged = 0;
+  if (mConfig.mergedObjectTimespan.value == MergedObjectTimespan::LastDifference ||
+      mConfig.mergedObjectTimespan.value == MergedObjectTimespan::NCycles && mConfig.mergedObjectTimespan.param == mCyclesSinceReset) {
+    clear();
   }
+
+  mCollector->send({mTotalDeltasMerged, "total_deltas_merged"}, monitoring::DerivedMetricMode::RATE);
+  mCollector->send({mDeltasMerged, "deltas_merged_since_last_publication"});
+  mCollector->send({mCyclesSinceReset, "cycles_since_reset"});
+  mDeltasMerged = 0;
 }
+
 void IntegratingMerger::merge(ObjectStore& target, ObjectStore&& other)
 {
   if (std::holds_alternative<std::monostate>(target)) {
@@ -121,7 +127,7 @@ void IntegratingMerger::merge(ObjectStore& target, ObjectStore&& other)
 
 void IntegratingMerger::endOfStream(framework::EndOfStreamContext& eosContext)
 {
-  publishIntegral(eosContext.outputs());
+  finishCycle(eosContext.outputs());
 }
 
 // I am not calling it reset(), because it does not have to be performed during the FairMQs reset.
diff --git a/Utilities/Mergers/test/common.h b/Utilities/Mergers/test/common.h
index e85e256cd5..c2726959bb 100644
--- a/Utilities/Mergers/test/common.h
+++ b/Utilities/Mergers/test/common.h
@@ -15,6 +15,7 @@
 #include <sstream>
 #include <gsl/span>
 #include <TH1.h>
+#include <Framework/CallbackService.h>
 
 namespace o2::mergers::test
 {
@@ -22,6 +23,26 @@ inline auto to_span(const TH1F& histo)
 {
   return gsl::span(histo.GetArray(), histo.GetSize());
 }
+
+void registerCallbacksForTestFailure(framework::CallbackService& cb, std::shared_ptr<bool> success)
+{
+  cb.set<framework::CallbackService::Id::EndOfStream>([success](framework::EndOfStreamContext& ctx) {
+    if (*success == false) {
+      LOG(fatal) << "Received an EndOfStream without having received the expected object";
+    }
+  });
+  cb.set<framework::CallbackService::Id::Stop>([success]() {
+    if (*success == false) {
+      LOG(fatal) << "STOP transition without having received the expected object";
+    }
+  });
+  cb.set<framework::CallbackService::Id::ExitRequested>([success](framework::ServiceRegistryRef) {
+    if (*success == false) {
+      LOG(fatal) << "EXIT transition without having received the expected object";
+    }
+  });
+}
+
 } // namespace o2::mergers::test
 
 namespace std
diff --git a/Utilities/Mergers/test/customTopologyCommon.h b/Utilities/Mergers/test/customTopologyCommon.h
index 13c745d6f8..6233cb53bd 100644
--- a/Utilities/Mergers/test/customTopologyCommon.h
+++ b/Utilities/Mergers/test/customTopologyCommon.h
@@ -24,6 +24,7 @@
 #include <Mergers/CustomMergeableObject.h>
 #include <Mergers/MergerBuilder.h>
 #include <Mergers/MergerInfrastructureBuilder.h>
+#include "common.h"
 
 void customize(std::vector<o2::framework::CompletionPolicy>& policies)
 {
@@ -109,9 +110,12 @@ class CustomMergerTestGenerator
       },
       Outputs{},
       AlgorithmSpec{
-        AlgorithmSpec::InitCallback{[expectedResult = mExpectedResult](InitContext&) {
+        AlgorithmSpec::InitCallback{[expectedResult = mExpectedResult](InitContext& initContext) {
+          auto success = std::make_shared<bool>(false);
+          mergers::test::registerCallbacksForTestFailure(initContext.services().get<CallbackService>(), success);
+
           return AlgorithmSpec::ProcessCallback{
-            [expectedResult, numberOfCalls = 0, numberOfObjects = 0, numberOfMovingWindows = 0, lastObjectValue = 0, retries = 5](ProcessingContext& processingContext) mutable {
+            [expectedResult, numberOfCalls = 0, numberOfObjects = 0, numberOfMovingWindows = 0, lastObjectValue = 0, retries = 5, success](ProcessingContext& processingContext) mutable {
               numberOfCalls++;
 
               if (processingContext.inputs().isValid("custom")) {
@@ -139,7 +143,10 @@ class CustomMergerTestGenerator
                   if (lastObjectValue != expectedResult) {
                     LOG(fatal) << "got wrong secret from object: " << lastObjectValue << ", expected: " << expectedResult;
                   }
+                  return;
                 }
+                LOG(info) << "Received the expected objects, test successful";
+                *success = true;
               }
             }};
         }}}});
@@ -154,12 +161,17 @@ class CustomMergerTestGenerator
       },
       Outputs{},
       AlgorithmSpec{
-        AlgorithmSpec::InitCallback{[expectedResult = mExpectedResult](InitContext&) {
+        AlgorithmSpec::InitCallback{[expectedResult = mExpectedResult](InitContext& initContext) {
+          auto success = std::make_shared<bool>(false);
+          mergers::test::registerCallbacksForTestFailure(initContext.services().get<CallbackService>(), success);
+
           return AlgorithmSpec::ProcessCallback{
-            [expectedResult, retryNumber = 0, numberOfRetries = 5](ProcessingContext& processingContext) mutable {
+            [expectedResult, retryNumber = 0, numberOfRetries = 5, success](ProcessingContext& processingContext) mutable {
               const auto obj = processingContext.inputs().get<mergers::CustomMergeableObject*>("custom");
 
               if (obj->getSecret() == expectedResult) {
+                LOG(info) << "Received the expected object, test successful";
+                *success = true;
                 processingContext.services().get<ControlService>().readyToQuit(QuitRequest::All);
                 return;
               }
diff --git a/Utilities/Mergers/test/histosTopologyCommon.h b/Utilities/Mergers/test/histosTopologyCommon.h
index 7c713b3409..d2305e3f6e 100644
--- a/Utilities/Mergers/test/histosTopologyCommon.h
+++ b/Utilities/Mergers/test/histosTopologyCommon.h
@@ -71,6 +71,7 @@ class HistosMergerTestGenerator
               "histo", "histo", histoBinsCount, histoMin, histoMax);
             histo.Fill(5);
             histo.Fill(producerIdx);
+            processingContext.services().get<ControlService>().endOfStream();
             processingContext.services().get<ControlService>().readyToQuit(QuitRequest::Me);
           })}});
     }
@@ -103,14 +104,19 @@ class HistosMergerTestGenerator
       Inputs{{"histo", origin, description, 0, Lifetime::Sporadic}},
       Outputs{},
       AlgorithmSpec{
-        AlgorithmSpec::InitCallback{[expectedResult = mExpectedResult](InitContext&) {
+        AlgorithmSpec::InitCallback{[expectedResult = mExpectedResult](InitContext& initContext) {
+          auto success = std::make_shared<bool>(false);
+          mergers::test::registerCallbacksForTestFailure(initContext.services().get<CallbackService>(), success);
+
           // reason for this crude retry is that multiple layers are not synchronized between each other and publish on their own timers,
           // number of retries is chosen arbitrarily as we need to retry at least twice
-          return AlgorithmSpec::ProcessCallback{[expectedResult, retryNumber = 1, retries = 5](ProcessingContext& processingContext) mutable {
+          return AlgorithmSpec::ProcessCallback{[expectedResult, retryNumber = 1, retries = 5, success](ProcessingContext& processingContext) mutable {
             const auto histo = processingContext.inputs().get<TH1F*>("histo");
 
             LOG(info) << "RETRY: " << retryNumber << ": comparing: " << std::to_string(histo) << " to the expected: " << std::to_string(expectedResult);
             if (std::equal(expectedResult.begin(), expectedResult.end(), histo->GetArray(), histo->GetArray() + histo->GetSize())) {
+              LOG(info) << "Received the expected object, test successful";
+              *success = true;
               processingContext.services().get<ControlService>().readyToQuit(QuitRequest::All);
               return;
             }
diff --git a/Utilities/Mergers/test/test_MergerTopologyHistosFullHistory.cxx b/Utilities/Mergers/test/test_MergerTopologyHistosFullHistory.cxx
index d08f6ee077..5ac18f998d 100644
--- a/Utilities/Mergers/test/test_MergerTopologyHistosFullHistory.cxx
+++ b/Utilities/Mergers/test/test_MergerTopologyHistosFullHistory.cxx
@@ -32,7 +32,7 @@ WorkflowSpec defineDataProcessing(ConfigContext const&)
 
   const auto mergersInputs = generator.generateHistoProducers(specs, producersCount);
 
-  generator.generateMergers(specs, mergersInputs, InputObjectsTimespan::LastDifference);
+  generator.generateMergers(specs, mergersInputs, InputObjectsTimespan::FullHistory);
 
   generator.generateChecker(specs);
 
diff --git a/Utilities/Mergers/test/vectorTopologyCommon.h b/Utilities/Mergers/test/vectorTopologyCommon.h
index d98576fd09..34dcc8515a 100644
--- a/Utilities/Mergers/test/vectorTopologyCommon.h
+++ b/Utilities/Mergers/test/vectorTopologyCommon.h
@@ -127,15 +127,20 @@ class VectorMergerTestGenerator
       Inputs{{"vec", origin, description, 0, Lifetime::Sporadic}},
       Outputs{},
       AlgorithmSpec{
-        AlgorithmSpec::InitCallback{[expectedResult = mExpectedResult](InitContext&) {
+        AlgorithmSpec::InitCallback{[expectedResult = mExpectedResult](InitContext& initContext) {
+          auto success = std::make_shared<bool>(false);
+          mergers::test::registerCallbacksForTestFailure(initContext.services().get<CallbackService>(), success);
+
           // reason for this crude retry is that multiple layers are not synchronized between each other and publish on their own timers.
           // number of retries was chosen a bit randomly, as we need to have at least 2 runs through this function because of publish
           // timers inside of the mergers
-          return AlgorithmSpec::ProcessCallback{[expectedResult, retryNumber = 1, retries = 5](ProcessingContext& processingContext) mutable {
+          return AlgorithmSpec::ProcessCallback{[expectedResult, retryNumber = 1, retries = 5, success](ProcessingContext& processingContext) mutable {
             const auto vectorOfHistos = processingContext.inputs().get<std::vector<TObject*>*>("vec");
 
             LOG(info) << "RETRY: " << retryNumber << ": comparing: " << std::to_string(vectorOfHistos) << " to the expected: " << std::to_string(expectedResult);
             if (vectorOfHistos == expectedResult) {
+              LOG(info) << "Received the expected object, test successful";
+              *success = true;
               processingContext.services().get<ControlService>().readyToQuit(QuitRequest::All);
               return;
             }
diff --git a/dependencies/FindO2GPU.cmake b/dependencies/FindO2GPU.cmake
index 1805c046d0..302f5ab932 100644
--- a/dependencies/FindO2GPU.cmake
+++ b/dependencies/FindO2GPU.cmake
@@ -25,6 +25,9 @@ string(TOUPPER "${ENABLE_CUDA}" ENABLE_CUDA)
 string(TOUPPER "${ENABLE_OPENCL1}" ENABLE_OPENCL1)
 string(TOUPPER "${ENABLE_OPENCL2}" ENABLE_OPENCL2)
 string(TOUPPER "${ENABLE_HIP}" ENABLE_HIP)
+if(NOT DEFINED CMAKE_BUILD_TYPE_UPPER)
+  string(TOUPPER "${CMAKE_BUILD_TYPE}" CMAKE_BUILD_TYPE_UPPER)
+endif()
 
 if(CUDA_COMPUTETARGET AND CUDA_COMPUTETARGET STREQUAL "default")
   set(CUDA_COMPUTETARGET 86 89)
@@ -66,7 +69,7 @@ endfunction()
 STRING(REGEX REPLACE "\-std=[^ ]*" "" O2_GPU_CMAKE_CXX_FLAGS_NOSTD "${CMAKE_CXX_FLAGS}") # Need to strip c++17 imposed by alidist defaults
 
 if(ENABLE_CUDA)
-  set(CMAKE_CUDA_STANDARD 17)
+  set(CMAKE_CUDA_STANDARD ${CMAKE_CXX_STANDARD})
   set(CMAKE_CUDA_STANDARD_REQUIRED TRUE)
   include(CheckLanguage)
   check_language(CUDA)
@@ -108,7 +111,7 @@ if(ENABLE_CUDA)
     endif()
   endif()
   if(CMAKE_CUDA_COMPILER)
-    set(CMAKE_CUDA_FLAGS "${CMAKE_CUDA_FLAGS} -Xcompiler \"${O2_GPU_CMAKE_CXX_FLAGS_NOSTD}\" --expt-relaxed-constexpr --extended-lambda --allow-unsupported-compiler -Xptxas -v")
+    set(CMAKE_CUDA_FLAGS "${CMAKE_CUDA_FLAGS} -Xcompiler \"${O2_GPU_CMAKE_CXX_FLAGS_NOSTD}\" --expt-relaxed-constexpr --extended-lambda --allow-unsupported-compiler -Xptxas -v -Wno-attributes")
     if(CMAKE_CUDA_COMPILER_VERSION VERSION_GREATER_EQUAL "12.3")
       string(APPEND CMAKE_CUDA_FLAGS " -Xcudafe --diag_suppress=20257") # TODO: Cleanup
     endif()
@@ -206,7 +209,7 @@ endif()
 # Detect and enable HIP
 if(ENABLE_HIP)
   if("$ENV{CMAKE_PREFIX_PATH}" MATCHES "rocm")
-    set(CMAKE_HIP_STANDARD 17)
+    set(CMAKE_HIP_STANDARD ${CMAKE_CXX_STANDARD})
     set(CMAKE_HIP_STANDARD_REQUIRED TRUE)
     if(HIP_AMDGPUTARGET)
       set(AMDGPU_TARGETS "${HIP_AMDGPUTARGET}" CACHE STRING "AMD GPU targets to compile for" FORCE)
diff --git a/dependencies/FindONNXRuntime.cmake b/dependencies/FindONNXRuntime.cmake
new file mode 100644
index 0000000000..b34782e990
--- /dev/null
+++ b/dependencies/FindONNXRuntime.cmake
@@ -0,0 +1,19 @@
+# Copyright 2019-2020 CERN and copyright holders of ALICE O2.
+# See https://alice-o2.web.cern.ch/copyright for details of the copyright holders.
+# All rights not expressly granted are reserved.
+#
+# This software is distributed under the terms of the GNU General Public
+# License v3 (GPL Version 3), copied verbatim in the file "COPYING".
+#
+# In applying this license CERN does not waive the privileges and immunities
+# granted to it by virtue of its status as an Intergovernmental Organization
+# or submit itself to any jurisdiction.
+
+find_package(onnxruntime CONFIG)
+if (NOT onnxruntime_FOUND)
+  find_package(ONNXRuntime::ONNXRuntime CONFIG)
+  if (ONNXRuntime::ONNXRuntime_FOUND)
+    set(onnxruntime_FOUND 1)
+    add_library(onnxruntime::onnxruntime ALIAS ONNXRuntime::ONNXRuntime)
+  endif()
+endif()
diff --git a/macro/runTPCRefit.C b/macro/runTPCRefit.C
index ab1b141d86..02c79a8b36 100644
--- a/macro/runTPCRefit.C
+++ b/macro/runTPCRefit.C
@@ -87,7 +87,7 @@ int runTPCRefit(TString trackFile = "tpctracks.root", TString clusterFile = "tpc
       std::cout << "Error reading clusters (code " << retVal << ")\n";
       return 1;
     }
-    GPUO2InterfaceRefit refit(&clusterIndex, &transHelper, bz, trackHitRefs->data(), nullptr, tracks, prop);
+    GPUO2InterfaceRefit refit(&clusterIndex, &transHelper, bz, trackHitRefs->data(), 0, nullptr, nullptr, -1, tracks, prop);
     //refit.setGPUTrackFitInProjections(false); // Enable full 3D fit without assuming y and Z are uncorrelated
     for (unsigned int i = 0; i < tracks->size(); i++) {
       TrackTPC trk = (*tracks)[i];
diff --git a/objs/DartConfiguration.tcl b/objs/DartConfiguration.tcl
deleted file mode 100644
index e269f12391..0000000000
--- a/objs/DartConfiguration.tcl
+++ /dev/null
@@ -1,105 +0,0 @@
-# This file is configured by CMake automatically as DartConfiguration.tcl
-# If you choose not to use CMake, this file may be hand configured, by
-# filling in the required variables.
-
-
-# Configuration directories and files
-SourceDirectory: /home/eflatlan/alice/O2
-BuildDirectory: /home/eflatlan/alice/O2/objs
-
-# Where to place the cost data store
-CostDataFile: 
-
-# Site is something like machine.domain, i.e. pragmatic.crd
-Site: aliceml
-
-# Build name is osname-revision-compiler, i.e. Linux-2.4.2-2smp-c++
-BuildName: Linux-c++
-
-# Subprojects
-LabelsForSubprojects: 
-
-# Submission information
-SubmitURL: http://
-
-# Dashboard start time
-NightlyStartTime: 00:00:00 EDT
-
-# Commands for the build/test/submit cycle
-ConfigureCommand: "/usr/bin/cmake" "/home/eflatlan/alice/O2"
-MakeCommand: /usr/bin/cmake --build . --config "${CTEST_CONFIGURATION_TYPE}"
-DefaultCTestConfigurationType: Release
-
-# version control
-UpdateVersionOnly: 
-
-# CVS options
-# Default is "-d -P -A"
-CVSCommand: 
-CVSUpdateOptions: 
-
-# Subversion options
-SVNCommand: 
-SVNOptions: 
-SVNUpdateOptions: 
-
-# Git options
-GITCommand: /usr/bin/git
-GITInitSubmodules: 
-GITUpdateOptions: 
-GITUpdateCustom: 
-
-# Perforce options
-P4Command: 
-P4Client: 
-P4Options: 
-P4UpdateOptions: 
-P4UpdateCustom: 
-
-# Generic update command
-UpdateCommand: /usr/bin/git
-UpdateOptions: 
-UpdateType: git
-
-# Compiler info
-Compiler: /usr/bin/c++
-CompilerVersion: 11.4.0
-
-# Dynamic analysis (MemCheck)
-PurifyCommand: 
-ValgrindCommand: 
-ValgrindCommandOptions: 
-DrMemoryCommand: 
-DrMemoryCommandOptions: 
-CudaSanitizerCommand: 
-CudaSanitizerCommandOptions: 
-MemoryCheckType: 
-MemoryCheckSanitizerOptions: 
-MemoryCheckCommand: /usr/bin/valgrind
-MemoryCheckCommandOptions: 
-MemoryCheckSuppressionFile: 
-
-# Coverage
-CoverageCommand: /usr/bin/gcov
-CoverageExtraFlags: -l
-
-# Testing options
-# TimeOut is the amount of time in seconds to wait for processes
-# to complete during testing.  After TimeOut seconds, the
-# process will be summarily terminated.
-# Currently set to 25 minutes
-TimeOut: 1500
-
-# During parallel testing CTest will not start a new test if doing
-# so would cause the system load to exceed this value.
-TestLoad: 
-
-UseLaunchers: 
-CurlOptions: 
-# warning, if you add new options here that have to do with submit,
-# you have to update cmCTestSubmitCommand.cxx
-
-# For CTest submissions that timeout, these options
-# specify behavior for retrying the submission
-CTestSubmitRetryDelay: 5
-CTestSubmitRetryCount: 3
diff --git a/prodtests/full-system-test/dpl-workflow.sh b/prodtests/full-system-test/dpl-workflow.sh
index a9fc62a704..71de02d8ff 100755
--- a/prodtests/full-system-test/dpl-workflow.sh
+++ b/prodtests/full-system-test/dpl-workflow.sh
@@ -5,7 +5,6 @@ set -o pipefail
 
 # Abort in case any variable is not bound
 if [[ ${IGNORE_UNBOUND_VARIABLES:-} != 1 ]]; then  set -u; fi
-
 # ---------------------------------------------------------------------------------------------------------------------
 # Get this script's directory and load common settings
 : ${GEN_TOPO_MYDIR:=$(dirname $(realpath $0))}
@@ -30,8 +29,6 @@ fi
 : ${CTF_FREE_DISK_WAIT:="10"}         # if disk on EPNs is close to full, wait X seconds before retrying to write
 : ${CTF_MAX_FREE_DISK_WAIT:="600"}    # if not enough disk space after this time throw error
 
-export CALIB_RCT_UPDATER=0
-
 # entropy encoding/decoding mode, '' is equivalent to '--ans-version compat' (compatible with < 09/2023 data),
 # use '--ans-version 1.0 --ctf-dict none' for the new per-TF dictionary mode
 : ${RANS_OPT:="--ans-version 1.0 --ctf-dict none"}
@@ -358,6 +355,9 @@ WORKFLOW= # Make sure we start with an empty workflow
 # ---------------------------------------------------------------------------------------------------------------------
 # Input workflow
 INPUT_DETECTOR_LIST=$WORKFLOW_DETECTORS
+: ${GLOBAL_READER_OPTIONS:=}
+: ${GLOBAL_READER_NEEDS_PV:=}
+: ${GLOBAL_READER_NEEDS_SV:=}
 if [[ ! -z ${WORKFLOW_DETECTORS_USE_GLOBAL_READER_TRACKS} ]] || [[ ! -z ${WORKFLOW_DETECTORS_USE_GLOBAL_READER_CLUSTERS} ]]; then
   for i in ${WORKFLOW_DETECTORS_USE_GLOBAL_READER_TRACKS//,/ }; do
     export INPUT_DETECTOR_LIST=$(echo $INPUT_DETECTOR_LIST | sed -e "s/,$i,/,/g" -e "s/^$i,//" -e "s/,$i"'$'"//" -e "s/^$i"'$'"//")
@@ -366,8 +366,9 @@ if [[ ! -z ${WORKFLOW_DETECTORS_USE_GLOBAL_READER_TRACKS} ]] || [[ ! -z ${WORKFL
     export INPUT_DETECTOR_LIST=$(echo $INPUT_DETECTOR_LIST | sed -e "s/,$i,/,/g" -e "s/^$i,//" -e "s/,$i"'$'"//" -e "s/^$i"'$'"//")
   done
 
-  GLOBAL_READER_OPTIONS=
   has_detector ITS && SYNCMODE==1 && GLOBAL_READER_OPTIONS+=" --ir-frames-its"
+  [[ $GLOBAL_READER_NEEDS_PV == 1 ]] && GLOBAL_READER_OPTIONS+=" --primary-vertices"
+  [[ $GLOBAL_READER_NEEDS_SV == 1 ]] && GLOBAL_READER_OPTIONS+=" --secondary-vertices"
 
   if [[ ! -z ${TIMEFRAME_RATE_LIMIT:-} ]] && [[ $TIMEFRAME_RATE_LIMIT != 0 ]]; then
     HBFINI_OPTIONS=" --hbfutils-config o2_tfidinfo.root,upstream "
@@ -384,6 +385,7 @@ if [[ ! -z ${WORKFLOW_DETECTORS_USE_GLOBAL_READER_TRACKS} ]] || [[ ! -z ${WORKFL
   has_detector MCH && has_detector_from_global_reader MCH && add_W o2-mch-clusters-reader-workflow "$HBFINI_OPTIONS" "" 0
   has_detector MCH && has_detector_from_global_reader MCH && add_W o2-mch-preclusters-reader-workflow "$HBFINI_OPTIONS" "" 0
   has_detector TRD && has_detector_from_global_reader TRD && add_W o2-trd-digit-reader-workflow "$DISABLE_MC --digit-subspec 0 --disable-trigrec $HBFINI_OPTIONS"
+  has_detector TRD && has_detector_from_global_reader TRD && [[ ! -z "$TRD_SOURCES" ]] && has_detector_from_global_reader_tracks "$(echo "$TRD_SOURCES" | cut -d',' -f1)-TRD" && add_W o2-trd-calib-reader-workflow "--trd-calib-infile trdcaliboutput.root $HBFINI_OPTIONS"
   has_detector TOF && has_detector_from_global_reader TOF && add_W o2-tof-reco-workflow "$DISABLE_MC --input-type digits --output-type NONE $HBFINI_OPTIONS"
 fi
 
@@ -513,9 +515,9 @@ fi
 has_detector_reco ITS && ! has_detector_from_global_reader ITS && add_W o2-its-reco-workflow "--trackerCA $ITS_CONFIG $DISABLE_MC $DISABLE_DIGIT_CLUSTER_INPUT $DISABLE_ROOT_OUTPUT --pipeline $(get_N its-tracker ITS REST 1 ITSTRK),$(get_N its-clusterer ITS REST 1 ITSCL)" "$ITS_CONFIG_KEY;$ITSMFT_STROBES;$ITSEXTRAERR"
 has_detector_reco FT0 && ! has_detector_from_global_reader FT0 && add_W o2-ft0-reco-workflow "$DISABLE_DIGIT_ROOT_INPUT $DISABLE_ROOT_OUTPUT $DISABLE_MC --pipeline $(get_N ft0-reconstructor FT0 REST 1)"
 has_detector_reco TRD && ! has_detector_from_global_reader TRD && add_W o2-trd-tracklet-transformer "--disable-irframe-reader $DISABLE_DIGIT_ROOT_INPUT $DISABLE_ROOT_OUTPUT $DISABLE_MC $TRD_FILTER_CONFIG --pipeline $(get_N TRDTRACKLETTRANSFORMER TRD REST 1 TRDTRKTRANS)"
-has_detectors_reco ITS TPC && has_detector_matching ITSTPC && add_W o2-tpcits-match-workflow "$DISABLE_ROOT_INPUT $DISABLE_ROOT_OUTPUT $DISABLE_MC $SEND_ITSTPC_DTGL  $TPC_CORR_OPT --nthreads $ITSTPC_THREADS --pipeline $(get_N itstpc-track-matcher MATCH REST $ITSTPC_THREADS TPCITS)" "$ITSTPC_CONFIG_KEY;$INTERACTION_TAG_CONFIG_KEY;$ITSMFT_STROBES;$ITSEXTRAERR;$TPC_CORR_KEY"
-has_detector_reco TRD && [[ ! -z "$TRD_SOURCES" ]] && add_W o2-trd-global-tracking "$DISABLE_ROOT_INPUT $DISABLE_ROOT_OUTPUT $DISABLE_MC $TRD_CONFIG $TRD_FILTER_CONFIG $TPC_CORR_OPT --track-sources $TRD_SOURCES --pipeline $(get_N trd-globaltracking_TPC_ITS-TPC_ TRD REST 1 TRDTRK),$(get_N trd-globaltracking_TPC_FT0_ITS-TPC_ TRD REST 1 TRDTRK),$(get_N trd-globaltracking_TPC_FT0_ITS-TPC_CTP_ TRD REST 1 TRDTRK)" "$TRD_CONFIG_KEY;$INTERACTION_TAG_CONFIG_KEY;$ITSMFT_STROBES;$ITSEXTRAERR;$TPC_CORR_KEY"
-has_detector_reco TOF && [[ ! -z "$TOF_SOURCES" ]] && add_W o2-tof-matcher-workflow "$TOF_MATCH_OPT $DISABLE_ROOT_INPUT $DISABLE_ROOT_OUTPUT $DISABLE_MC $TPC_CORR_OPT ${TOFMATCH_THREADS:+--tof-lanes ${TOFMATCH_THREADS}} --track-sources $TOF_SOURCES --pipeline $(get_N tof-matcher TOF REST 1 TOFMATCH)" "$ITSMFT_STROBES;$ITSEXTRAERR;$TPC_CORR_KEY"
+has_detectors_reco ITS TPC && ! has_detector_from_global_reader_tracks ITS-TPC && has_detector_matching ITSTPC && add_W o2-tpcits-match-workflow "$DISABLE_ROOT_INPUT $DISABLE_ROOT_OUTPUT $DISABLE_MC $SEND_ITSTPC_DTGL  $TPC_CORR_OPT --nthreads $ITSTPC_THREADS --pipeline $(get_N itstpc-track-matcher MATCH REST $ITSTPC_THREADS TPCITS)" "$ITSTPC_CONFIG_KEY;$INTERACTION_TAG_CONFIG_KEY;$ITSMFT_STROBES;$ITSEXTRAERR;$TPC_CORR_KEY"
+has_detector_reco TRD && [[ ! -z "$TRD_SOURCES" ]] && ! has_detector_from_global_reader_tracks "$(echo "$TRD_SOURCES" | cut -d',' -f1)-TRD" && add_W o2-trd-global-tracking "$DISABLE_ROOT_INPUT $DISABLE_ROOT_OUTPUT $DISABLE_MC $TRD_CONFIG $TRD_FILTER_CONFIG $TPC_CORR_OPT --track-sources $TRD_SOURCES --pipeline $(get_N trd-globaltracking_TPC_ITS-TPC_ TRD REST 1 TRDTRK),$(get_N trd-globaltracking_TPC_FT0_ITS-TPC_ TRD REST 1 TRDTRK),$(get_N trd-globaltracking_TPC_FT0_ITS-TPC_CTP_ TRD REST 1 TRDTRK)" "$TRD_CONFIG_KEY;$INTERACTION_TAG_CONFIG_KEY;$ITSMFT_STROBES;$ITSEXTRAERR;$TPC_CORR_KEY"
+has_detector_reco TOF && [[ ! -z "$TOF_SOURCES" ]] && ! has_detector_from_global_reader_tracks "$(echo "$TOF_SOURCES" | cut -d',' -f1)-TOF" && add_W o2-tof-matcher-workflow "$TOF_MATCH_OPT $DISABLE_ROOT_INPUT $DISABLE_ROOT_OUTPUT $DISABLE_MC $TPC_CORR_OPT ${TOFMATCH_THREADS:+--tof-lanes ${TOFMATCH_THREADS}} --track-sources $TOF_SOURCES --pipeline $(get_N tof-matcher TOF REST 1 TOFMATCH)" "$ITSMFT_STROBES;$ITSEXTRAERR;$TPC_CORR_KEY"
 has_detectors TPC && [[ -z "$DISABLE_ROOT_OUTPUT" && "${SKIP_TPC_CLUSTERSTRACKS_OUTPUT:-}" != 1 ]] && ! has_detector_from_global_reader TPC && add_W o2-tpc-reco-workflow "--input-type pass-through --output-type clusters,tpc-triggers,tracks,send-clusters-per-sector $DISABLE_MC"
 
 # ---------------------------------------------------------------------------------------------------------------------
@@ -527,9 +529,9 @@ has_detector FDD && ! has_detector_from_global_reader FDD && has_processing_step
 has_detector FV0 && ! has_detector_from_global_reader FV0 && has_processing_step FV0_RECO && add_W o2-fv0-reco-workflow "$DISABLE_DIGIT_ROOT_INPUT $DISABLE_ROOT_OUTPUT $DISABLE_MC"
 has_detector ZDC && ! has_detector_from_global_reader ZDC && has_processing_step ZDC_RECO && add_W o2-zdc-digits-reco "$DISABLE_DIGIT_ROOT_INPUT $DISABLE_ROOT_OUTPUT $DISABLE_MC"
 has_detector HMP && ! has_detector_from_global_reader HMP && has_processing_step HMP_RECO && add_W o2-hmpid-digits-to-clusters-workflow "$DISABLE_DIGIT_ROOT_INPUT $DISABLE_ROOT_OUTPUT --pipeline $(get_N HMP-Clusterization HMP REST 1 HMPCLUS)"
-has_detector HMP && has_detector_matching HMP && ! has_detector_from_global_reader_tracks HMP && has_processing_step HMP_RECO && add_W o2-hmpid-matcher-workflow "$DISABLE_DIGIT_ROOT_INPUT $DISABLE_ROOT_OUTPUT $DISABLE_MC --track-sources ${HMP_SOURCES:-all} --pipeline $(get_N hmp-matcher HMP REST 1 HMPMATCH)"
-has_detectors_reco MCH MID && has_detector_matching MCHMID && add_W o2-muon-tracks-matcher-workflow "$DISABLE_ROOT_INPUT $DISABLE_MC $DISABLE_ROOT_OUTPUT --pipeline $(get_N muon-track-matcher MATCH REST 1)"
-has_detectors_reco MFT MCH && has_detector_matching MFTMCH && add_W o2-globalfwd-matcher-workflow "$DISABLE_ROOT_INPUT $DISABLE_ROOT_OUTPUT $DISABLE_MC --pipeline $(get_N globalfwd-track-matcher MATCH REST 1 FWDMATCH)" "$MFTMCHConf"
+has_detector HMP && [[ ! -z "$HMP_SOURCES" ]] && has_detector_matching HMP && ! has_detector_from_global_reader_tracks HMP && add_W o2-hmpid-matcher-workflow "$DISABLE_DIGIT_ROOT_INPUT $DISABLE_ROOT_OUTPUT $DISABLE_MC --track-sources $HMP_SOURCES --pipeline $(get_N hmp-matcher HMP REST 1 HMPMATCH)"
+has_detectors_reco MCH MID && has_detector_matching MCHMID && ! has_detector_from_global_reader_tracks "MCH-MID" && add_W o2-muon-tracks-matcher-workflow "$DISABLE_ROOT_INPUT $DISABLE_MC $DISABLE_ROOT_OUTPUT --pipeline $(get_N muon-track-matcher MATCH REST 1)"
+has_detectors_reco MFT MCH && has_detector_matching MFTMCH && ! has_detector_from_global_reader_tracks "MFT-MCH" && add_W o2-globalfwd-matcher-workflow "$DISABLE_ROOT_INPUT $DISABLE_ROOT_OUTPUT $DISABLE_MC --pipeline $(get_N globalfwd-track-matcher MATCH REST 1 FWDMATCH)" "$MFTMCHConf"
 
 # ---------------------------------------------------------------------------------------------------------------------
 # Reconstruction workflows needed only in case QC or CALIB was requested
@@ -557,10 +559,10 @@ has_detector_reco MCH && ( [[ -z "$DISABLE_ROOT_OUTPUT" ]] || needs_root_output
 
 # always run vertexing if requested and if there are some sources, but in cosmic mode we work in pass-trough mode (create record for non-associated tracks)
 ( [[ $BEAMTYPE == "cosmic" ]] || ! has_detector_reco ITS) && PVERTEX_CONFIG+=" --skip"
-has_detector_matching PRIMVTX && [[ ! -z "$VERTEXING_SOURCES" ]] && add_W o2-primary-vertexing-workflow "$DISABLE_MC $DISABLE_ROOT_INPUT $DISABLE_ROOT_OUTPUT $PVERTEX_CONFIG --pipeline $(get_N primary-vertexing MATCH REST 1 PRIMVTX),$(get_N pvertex-track-matching MATCH REST 1 PRIMVTXMATCH)" "${PVERTEXING_CONFIG_KEY};${INTERACTION_TAG_CONFIG_KEY};"
+has_detector_matching PRIMVTX && [[ ! -z "$VERTEXING_SOURCES" ]] && [[ $GLOBAL_READER_NEEDS_PV != 1 ]] && add_W o2-primary-vertexing-workflow "$DISABLE_MC $DISABLE_ROOT_INPUT $DISABLE_ROOT_OUTPUT $PVERTEX_CONFIG --pipeline $(get_N primary-vertexing MATCH REST 1 PRIMVTX),$(get_N pvertex-track-matching MATCH REST 1 PRIMVTXMATCH)" "${PVERTEXING_CONFIG_KEY};${INTERACTION_TAG_CONFIG_KEY};"
 
 if [[ $BEAMTYPE != "cosmic" ]] && has_detectors_reco ITS && has_detector_matching SECVTX && [[ ! -z "$SVERTEXING_SOURCES" ]]; then
-  add_W o2-secondary-vertexing-workflow "$DISABLE_MC $STRTRACKING $DISABLE_ROOT_INPUT $DISABLE_ROOT_OUTPUT $TPC_CORR_OPT --vertexing-sources $SVERTEXING_SOURCES --threads $SVERTEX_THREADS --pipeline $(get_N secondary-vertexing MATCH REST $SVERTEX_THREADS SECVTX)" "$TPC_CORR_KEY"
+  [[ $GLOBAL_READER_NEEDS_SV != 1 ]] && add_W o2-secondary-vertexing-workflow "$DISABLE_MC $STRTRACKING $DISABLE_ROOT_INPUT $DISABLE_ROOT_OUTPUT $TPC_CORR_OPT --vertexing-sources $SVERTEXING_SOURCES --threads $SVERTEX_THREADS --pipeline $(get_N secondary-vertexing MATCH REST $SVERTEX_THREADS SECVTX)" "$TPC_CORR_KEY"
   SECTVTX_ON="1"
 else
   SECTVTX_ON="0"
@@ -603,7 +605,6 @@ if has_processing_step ENTROPY_ENCODER && [[ ! -z "$WORKFLOW_DETECTORS_CTF" ]] &
   if [[ $CREATECTFDICT == 1 ]] && [[ $EXTINPUT == 1 ]]; then CONFIG_CTF+=" --save-dict-after $SAVE_CTFDICT_NTIMEFRAMES"; fi
   [[ $EPNSYNCMODE == 1 ]] && CONFIG_CTF+=" --require-free-disk 53687091200 --wait-for-free-disk $CTF_FREE_DISK_WAIT --max-wait-for-free-disk $CTF_MAX_FREE_DISK_WAIT"
   add_W o2-ctf-writer-workflow "$CONFIG_CTF"
-  [[ $SYNCMODE == 1 ]] && export CALIB_RCT_UPDATER=1
 fi
 
 # ---------------------------------------------------------------------------------------------------------------------
diff --git a/prodtests/sim_challengeCust.sh b/prodtests/sim_challengeCust.sh
deleted file mode 100755
index 9e777acdb9..0000000000
--- a/prodtests/sim_challengeCust.sh
+++ /dev/null
@@ -1,298 +0,0 @@
-#!/bin/bash
-
-# A simple chain of algorithms from MC to reco (and analysis)
-
-# ------------ LOAD UTILITY FUNCTIONS ----------------------------
-. ${O2_ROOT}/share/scripts/jobutils.sh
-# ----------- START WITH ACTUAL SCRIPT ---------------------------
-
-
-if [ -z "$SHMSIZE" ]; then export SHMSIZE=10000000000; fi
-
-# default run number
-# (for now set to a pilot beam run until we have all CCDB objects for default unanchored MC)
-runNumDef=300000
-
-# default time stamp --> will be determined from run number during the sim stage
-# startTimeDef=$(($(date +%s%N)/1000000))
-
-# default number of events
-nevPP=10
-nevPbPb=10
-
-# default interaction rates in kHz
-intRatePP=400
-intRatePbPb=2
-
-# default collision system
-collSyst="pp"
-
-generPP="pythia8pp"
-generPbPb="pythia8hi"
-
-# default sim engine
-engine="TGeant3"
-
-# options to pass to every workflow
-gloOpt=" -b --run --shm-segment-size $SHMSIZE"
-
-# ITS reco options depends on pp or pbpb
-ITSRecOpt=""
-
-# option to set the number of sim workers
-simWorker=""
-
-# option to set the number of tpc-lanes
-tpcLanes=""
-
-#
-Usage()
-{
-  echo "Usage: ${0##*/} [-s system /pp[Def] or pbpb/] [-r IR(kHz) /Def = $intRatePP(pp)/$intRatePbPb(pbpb)] [-n Number of events /Def = $nevPP(pp) or $nevPbPb(pbpb)/] [-e TGeant3|TGeant4] [-t startTime/Def = $startTimeDef] [-run runNumber/Def = $runNumDef] [-f fromstage sim|digi|reco /Def = sim]"
-  exit
-}
-
-fromstage="sim"
-while [ $# -gt 0 ] ; do
-  case $1 in
-    -n) nev=$2;  shift 2 ;;
-    -s) collSyst=$2; shift 2 ;;
-    -r) intRate=$2; shift 2 ;;
-    -e) engine=$2; shift 2 ;;
-    -f) fromstage=$2; shift 2 ;;
-    -j) simWorker="-j $2"; shift 2 ;;
-    -l) tpcLanes="--tpc-lanes $2"; shift 2 ;;
-    -t) startTime=$2; shift 2 ;;
-    -p) pdg=$2; shift 2 ;;
-    -run) runNumber=$2; shift 2 ;;
-    -h) Usage ;;
-    *) echo "Wrong input"; Usage;
-  esac
-done
-
-# convert to lower case (the bash construct ${collSyst,,} is less portable)
-collSyst=`echo "$collSyst" | awk '{print tolower($0)}'`
-if [ "$collSyst" == "pp" ]; then
-    gener="$generPP"
-    ITSRecOpt=" --configKeyValues \"ITSVertexerParam.phiCut=0.5;ITSVertexerParam.clusterContributorsCut=3;ITSVertexerParam.tanLambdaCut=0.2\""
-    [[ "nev" -lt "1"  ]] && nev="$nevPP"
-    [[ "intRate" -lt "1"  ]] && intRate="$intRatePP"
-elif [ "$collSyst" == "pbpb" ]; then
-    gener="$generPbPb"
-    [[ "nev" -lt "1"  ]] && nev="$nevPbPb"
-    [[ "intRate" -lt "1"  ]] && intRate="$intRatePbPb"
-else
-    echo "Wrong collision system $collSyst provided, should be pp or pbpb"
-
-fi
-
-[[ -z $startTime ]] && startTime=$startTimeDef
-[[ -z $runNumber ]] && runNumber=$runNumDef
-
-dosimp="0"
-dosimk="0"
-dosimpr="0"
-dodigi="0"
-dotrdtrap="0"
-doreco="0"
-# convert to lowercase
-fromstage=`echo "$fromstage" | awk '{print tolower($0)}'`
-if [ "$fromstage" == "simp" ]; then
-  dosimp="1"
-  dodigi="1"
-  dotrdtrap="1"
-  doreco="1"
-elif [ "$fromstage" == "simk" ]; then
-  dosimk="1"
-  dodigi="1"
-  dotrdtrap="1"
-  doreco="1"
-elif [ "$fromstage" == "simpr" ]; then
-  dosimpr="1"
-  dodigi="1"
-  dotrdtrap="1"
-  doreco="1"
-elif [ "$fromstage" == "sim" ]; then
-  dosim="1"
-  dodigi="1"
-  dotrdtrap="1"
-  doreco="1"
-elif [ "$fromstage" == "digi" ]; then
-  dodigi="1"
-  dotrdtrap="1"
-  doreco="1"
-elif [ "$fromstage" == "reco" ]; then
-  doreco="1"
-else
-  echo "Wrong stage string $fromstage provided, should be sim or digi or reco"
-fi
-
-
-if [ "$dosimp" == "1" ]; then
-  #---- GRP creation ------
-  echo "Creating GRPs ... and publishing in local CCDB overwrite"
-  taskwrapper grp.log o2-grp-simgrp-tool createGRPs --run ${runNumber} --publishto GRP -o mcGRP
-
-  #---------------------------------------------------
-  echo "Running Pion gun simulation for $nev  "
-  #taskwrapper sim.log o2-sim -n"$nev" --configKeyValues "Diamond.width[2]=6." -g "$gener" -e "$engine" $simWorker --run ${runNumber}
-
-	o2-sim -n"$nev" -e TGeant3 -g boxgen --configKeyValues "BoxGun.pdg=211; BoxGun.phirange[0]=-5; BoxGun.phirange[1]=60; BoxGun.number=60; BoxGun.eta[0]=-0.5 ; BoxGun.eta[1]=0.5; BoxGun.prange[0]=2.8; BoxGun.prange[1]=2.83;" $simWorker --run ${runNumber}
-
-
-
-  ##------ extract number of hits
-  taskwrapper hitstats.log root -q -b -l ${O2_ROOT}/share/macro/analyzeHits.C
-fi
-
-if [ "$dosimk" == "1" ]; then
-  #---- GRP creation ------
-  echo "Creating GRPs ... and publishing in local CCDB overwrite"
-  taskwrapper grp.log o2-grp-simgrp-tool createGRPs --run ${runNumber} --publishto GRP -o mcGRP
-
-  #---------------------------------------------------
-  echo "Running Ka gun simulation for $nev  "
-  #taskwrapper sim.log o2-sim -n"$nev" --configKeyValues "Diamond.width[2]=6." -g "$gener" -e "$engine" $simWorker --run ${runNumber}
-
-	o2-sim -n"$nev" -e TGeant3 -g boxgen --configKeyValues "BoxGun.pdg=321; BoxGun.phirange[0]=-5; BoxGun.phirange[1]=60; BoxGun.number=30; BoxGun.eta[0]=-0.5 ; BoxGun.eta[1]=0.5; BoxGun.prange[0]=2.8; BoxGun.prange[1]=2.83;" $simWorker --run ${runNumber}
-
-
-
-  ##------ extract number of hits
-  taskwrapper hitstats.log root -q -b -l ${O2_ROOT}/share/macro/analyzeHits.C
-fi
-
-
-
-if [ "$dosimpr" == "1" ]; then
-  #---- GRP creation ------
-  echo "Creating GRPs ... and publishing in local CCDB overwrite"
-  taskwrapper grp.log o2-grp-simgrp-tool createGRPs --run ${runNumber} --publishto GRP -o mcGRP
-
-  #---------------------------------------------------
-  echo "Running Proton gun simulation for $nev  "
-  #taskwrapper sim.log o2-sim -n"$nev" --configKeyValues "Diamond.width[2]=6." -g "$gener" -e "$engine" $simWorker --run ${runNumber}
-
-	o2-sim -n"$nev" -e TGeant3 -g boxgen --configKeyValues "BoxGun.pdg=2212; BoxGun.phirange[0]=-5; BoxGun.phirange[1]=60; BoxGun.number=60; BoxGun.eta[0]=-0.5 ; BoxGun.eta[1]=0.5; BoxGun.prange[0]=2.8; BoxGun.prange[1]=2.83;" $simWorker --run ${runNumber}
-
-
-
-  ##------ extract number of hits
-  taskwrapper hitstats.log root -q -b -l ${O2_ROOT}/share/macro/analyzeHits.C
-fi
-
-if [ "$dosim" == "1" ]; then
-  #---- GRP creation ------
-  echo "Creating GRPs ... and publishing in local CCDB overwrite"
-  taskwrapper grp.log o2-grp-simgrp-tool createGRPs --run ${runNumber} --publishto GRP -o mcGRP
-
-  #---------------------------------------------------
-  echo "Running simulation for $nev $collSyst events with $gener generator and engine $engine and run number $runNumber"
-  taskwrapper sim.log o2-sim -n"$nev" --configKeyValues "Diamond.width[2]=6." -g "$gener" -e "$engine" $simWorker --run ${runNumber}
-
-  ##------ extract number of hits
-  taskwrapper hitstats.log root -q -b -l ${O2_ROOT}/share/macro/analyzeHits.C
-fi
-
-if [ "$dodigi" == "1" ]; then
-  echo "Running digitization for $intRate kHz interaction rate"
-  intRate=$((1000*(intRate)));
-  if [[ "$dotrdtrap" == "1" ]]; then trddigioption="--disable-trd-trapsim"; fi # no need to run the TRAP simulation twice
-  taskwrapper digi.log o2-sim-digitizer-workflow $gloOpt $trddigioption --interactionRate $intRate $tpcLanes --configKeyValues "HBFUtils.runNumber=${runNumber}" --early-forward-policy always --combine-devices # --onlyDet HMP, ITS, MFT, FT0, FV0, TPC, TOF, TRD
-  echo "Return status of digitization: $?"
-  # existing checks
-  #root -b -q O2/Detectors/ITSMFT/ITS/macros/test/CheckDigits.C+
-fi
-
-if [ "$dotrdtrap" == "1" ]; then
-  echo "Running TRD trap simulator"
-  taskwrapper trdtrap.log o2-trd-trap-sim $gloOpt
-  echo "Return status of trd trap sim: $?"
-fi
-
-
-if [ "$doreco" == "1" ]; then
-
-  echo "Running TPC reco flow"
-  #needs TPC digitized data
-  taskwrapper tpcreco.log o2-tpc-reco-workflow $gloOpt --input-type digits --output-type clusters,tracks,send-clusters-per-sector  --configKeyValues "GPU_rec.maxTrackQPtB5=20"
-  echo "Return status of tpcreco: $?"
-
-  echo "Running ITS reco flow"
-  taskwrapper itsreco.log  o2-its-reco-workflow --trackerCA --tracking-mode async $gloOpt $ITSRecOpt
-  echo "Return status of itsreco: $?"
-
-  # existing checks
-  # root -b -q O2/Detectors/ITSMFT/ITS/macros/test/CheckClusters.C+
-  # root -b -q O2/Detectors/ITSMFT/ITS/macros/test/CheckTracks.C+
-
-  echo "Running MFT reco flow"
-  #needs MFT digitized data
-  MFTRecOpt=" --configKeyValues \"MFTTracking.forceZeroField=false;MFTTracking.LTFclsRCut=0.0100;\""
-  taskwrapper mftreco.log  o2-mft-reco-workflow  $gloOpt $MFTRecOpt
-  echo "Return status of mftreco: $?"
-
-  #echo "Running MCH reco flow"
-  #taskwrapper mchreco.log o2-mch-reco-workflow $gloOpt
-  #echo "Return status of mchreco: $?"
-
-  echo "Running FT0 reco flow"
-  #needs FT0 digitized data
-  taskwrapper ft0reco.log o2-ft0-reco-workflow $gloOpt
-  echo "Return status of ft0reco: $?"
-
-  # trengs ikke
-  #echo "Running FDD reco flow"
-  #needs FDD digitized data
-  #taskwrapper fddreco.log o2-fdd-reco-workflow $gloOpt
-  #echo "Return status of fddreco: $?"
-
-  echo "Running FV0 reco flow"
-  #needs FV0 digitized data
-  taskwrapper fv0reco.log o2-fv0-reco-workflow $gloOpt
-  echo "Return status of fv0reco: $?"
-
-
-  # trengs ikke
-  #echo "Running MID reco flow"
-  #needs MID digitized data
-  #taskwrapper midreco.log "o2-mid-digits-reader-workflow | o2-mid-reco-workflow $gloOpt"
-  #echo "Return status of midreco: $?"
-
-  echo "Running HMPID reco flow to produce clusters"
-  #needs HMPID digitized data
-  taskwrapper hmpreco.log "o2-hmpid-digits-to-clusters-workflow $gloOpt"
-  echo "Return status of hmpid cluster reco: $?"
-
-  #echo "Running MCH-MID matching flow"
-  #taskwrapper mchmidMatch.log "o2-muon-tracks-matcher-workflow $gloOpt"
-  #echo "Return status of mchmidmatch: $?"
-
-  echo "Running ITS-TPC matching flow"
-  #needs results of o2-tpc-reco-workflow, o2-its-reco-workflow and o2-fit-reco-workflow
-  taskwrapper itstpcMatch.log o2-tpcits-match-workflow --use-ft0 $gloOpt
-  echo "Return status of itstpcMatch: $?"
-
-  echo "Running TRD matching to ITS-TPC and TPC"
-  #needs results of o2-tpc-reco-workflow, o2-tpcits-match-workflow and o2-trd-tracklet-transformer
-  taskwrapper trdTrkltTransf.log o2-trd-tracklet-transformer $gloOpt
-  echo "Return status of trdTrkltTransf: $?"
-  taskwrapper trdMatch.log o2-trd-global-tracking $gloOpt
-  echo "Return status of trdTracker: $?"
-
-
-  echo "Running TOF reco flow to produce clusters"
-  #needs results of TOF digitized data and results of o2-tpcits-match-workflow
-  taskwrapper tofReco.log o2-tof-reco-workflow $gloOpt
-  echo "Return status of tof cluster reco : $?"
-
-  echo "Running Track-TOF macthing flow"
-  #needs results of TOF clusters data from o2-tof-reco-workflow and results of o2-tpc-reco-workflow and ITS-TPC matching
-  taskwrapper tofMatchTracks.log o2-tof-matcher-workflow $gloOpt
-  echo "Return status of o2-tof-matcher-workflow: $?"
-
-  echo "Running Track-HMPID macthing flow"
-  #needs results of HMPID clusters data from o2-hmpid-digits-to-clusters-workflow
-  taskwrapper hmpidMatchTracks.log o2-hmpid-matcher-workflow $gloOpt
-  echo "Return status of o2-hmpid-matcher-workflow: $?"
-fi
